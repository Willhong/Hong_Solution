<?xml version="1.0"?>
<doc>
    <assembly>
        "Cognex.VisionPro.Comm"
    </assembly>
    <members>
        <member name="M:Cognex.VisionPro.Comm.CogCommCards.#ctor">
            <summary>
Constructs a new instance of the CogCommCards class.
After construction the CogCommCards is populated with a CogCommCard instance
for each comm card found in the system.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogCommCards">
            <summary>
A collection containing every 
<see cref="T:Cognex.VisionPro.Comm.CogCommCard" /> installed in the system.
<para>
Upon construction, CogCommCards is automatically initialized to contain
one instance for <see cref="T:Cognex.VisionPro.Comm.CogCommCard" />
found in the system.
</para></summary>
            <example>
                <!-- CogCommCardExample1 -->
                <!-- Shows simple use of comm card API
     The sample:
     1. initializes software access to the comm card.
     2. initializes software access to the Network Data Model (NDM).
          a. Signs up for the NewUserData event     
-->
                <code lang="Visual Basic" />
                <code lang="C#">
using Cognex.VisionPro;
using Cognex.VisionPro.Comm;

// Shows simple use of comm card API.
//
// Initializes a connection to a Rockwell Control Logix PLC
// using the EtherNet/IP protocol and the Cognex generic
// Factory Floor Protocol (FFP) interface known as the 
// Network Data Model (NDM).
//
// Signs up for the NDM's "NewUserData" event and prints out the 
// NewUserData as it's received.
public void Example()
{
  CogCommCards commCardCollection = new CogCommCards();
      
  Console.WriteLine("Found: {0} comm cards", commCardCollection.Count);
      
  if (commCardCollection.Count == 0)
    return;

  CogCommCard card = commCardCollection[0];

  Console.WriteLine("Name: {0}", card.Name);
  Console.WriteLine("Serial: {0}", card.SerialNumber);

  Console.WriteLine("Initializing comm card Factory Floor Protocol (FFP)");

  CogFfpAccess ffpAccess = card.FfpAccess;

  if (ffpAccess == null)
    throw new Exception("FFP is not supported.");     

  CogNdm ffpNdm =
    ffpAccess.CreateNetworkDataModel(CogFfpProtocolConstants.EthernetIp);

  ffpNdm.Start();

  Console.WriteLine("Sign up for the NewUserData Event");
  ffpNdm.NewUserData += new CogNdmNewUserDataEventHandler(ffpNdm_NewUserData);    
}

void ffpNdm_NewUserData(object sender, CogNdmNewUserDataEventArgs e)
{
  CogNdm ndm = sender as CogNdm;
  if (ndm != null)
    Console.WriteLine(BitConverter.ToString(ndm.ReadUserData(0, 100)));
}
</code>
            </example>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogCommCard.EthernetPortAccess">
            <summary>
Gets the Ethernet port access object.
<para>
Use the Ethernet port access object to configure
the IP settings (IP address, subnet mask, etc...)
of the Ethernet ports on the hardware.
</para><para>
The IP settings of the card can also be configured using
Comm Card Configurator utility.
</para><para>
This property returns null if the hardware does not support
Ethernet port configuration.
</para></summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogCommCard.DiscreteIOAccess">
            <summary>
Gets a discrete I/O access object.
<para>
Use the discrete I/O access object to access the discrete I/O and 
precision I/O features of the comm card.
</para><para>
This property returns null if the hardware does not support discrete I/O.
</para></summary>
            <remarks>
                <para>
Precision I/O supports getting and setting the state of 
the Comm Card's Discrete I/O lines.
</para>
                <para>
Precision I/O also supports configuration of an event system
that runs on the Comm Card's real-time processor.
</para>
                <para>
The precision I/O event system allows the Comm Card to receive
inputs and automatically react to them without involving the host PC.
</para>
                <para>
This enables accurate configuration and reporting of I/O 
events and avoids typical host PC latency issues.
</para>
                <list type="bullet">
                    <item>
Use 
<see cref="M:Cognex.VisionPro.Comm.CogPrio.SetOutput(Cognex.VisionPro.Comm.CogPrioBankConstants,System.Int32,Cognex.VisionPro.Comm.CogPrioOutputLineValueConstants)" />
to manually set an I/O line high or low.</item>
                    <item>
Use
<see cref="M:Cognex.VisionPro.Comm.CogPrio.ReadState" />
to get the current state the I/O lines.
</item>
                    <item>
Construct instances of
<see cref="T:Cognex.VisionPro.Comm.CogPrioEvent" />
and add them to the 
<see cref="P:Cognex.VisionPro.Comm.CogPrio.Events" /> 
collection to configure a set of named events that correspond to
different actions of interest that occur on the I/O card.
</item>
                    <item>
Use
<see cref="P:Cognex.VisionPro.Comm.CogPrioEvent.CausesLine" />
to configure which I/O line transitions cause a precision I/O event to occur.
</item>
                    <item>
Use
<see cref="P:Cognex.VisionPro.Comm.CogPrioEvent.CausesNdm" />
to configure which NDM signals of the factory floor protocol cause a precision I/O event to occur.
</item>
                    <item>
Use
<see cref="P:Cognex.VisionPro.Comm.CogPrioEvent.ResponsesLine" />
to configure an automatic I/O line response to a precision I/O event.
</item>
                    <item>
Use
<see cref="M:Cognex.VisionPro.Comm.CogPrioEvent.Schedule(Cognex.VisionPro.Comm.CogPrioEventScheduleTypeConstants,System.Double,Cognex.VisionPro.Comm.CogPrioState)" />
to manually schedule a configured precision I/O event to occur at an precise instant.
</item>
                    <item>
Use
<see cref="E:Cognex.VisionPro.Comm.CogPrioEvent.HostNotification" />
to receive notifications whenever a configured event occurs.
</item>
                </list>
            </remarks>
            <example>
                <!-- CogCommCardExample1 -->
                <!-- Shows simple use of comm card API
     The sample:
     1. initializes software access to the comm card.
     2. initializes software access to the Network Data Model (NDM).
          a. Signs up for the NewUserData event     
-->
                <code lang="Visual Basic" />
                <code lang="C#">
  // This code shows simple use of
  // Comm Card API. This sample:
  //
  // 1. Initializes comm card's i/o interface.
  // 2. Reads input line 0.
  // 3. Signs up for host notification when input line 0 toggles.
  // 4. Sets an output line 0 high.
  [Test]
  public void Example2()
  {
  CogCommCards commCardCollection = new CogCommCards();

  Console.WriteLine("Found: {0} comm cards", commCardCollection.Count);

  if (commCardCollection.Count == 0)
  return;

  CogCommCard card = commCardCollection[0];

  Console.WriteLine("Name: {0}", card.Name);
  Console.WriteLine("Serial: {0}", card.SerialNumber);

  CogDiscreteIOAccess discreteIOAccess = card.DiscreteIOAccess;
  if (discreteIOAccess == null)
  throw new Exception("discrete IO is not supported.");

  // Create the prio interface
  CogPrio prio = discreteIOAccess.CreatePrecisionIO();

  // Read input 0
  bool isInputLine0High = mPrio.ReadState()[CogPrioBankConstants.InputBank0, 0];
  Console.WriteLine("Input line 0 is " + (isInputLine0High ? "high" : "low"));

  // Create an event that occurs when Input 0 changes
  prio.Events.Add(
  new CogPrioEvent() {
  Name = "InputChanged_0",
  CausesLine = new CogPrioEventCauseLineCollection() {
  new CogPrioEventCauseLine() {
  LineBank = CogPrioBankConstants.InputBank0,
  LineNumber = 0,
  LineTransition = CogPrioLineTransitionConstants.Any }}});

  // Sign up for host notification when on the event
  prio.Events["InputChanged_0"].HostNotification +=
  new CogPrioEventHandler(InputChanged_0_HostNotification);

  // Always ensure the events collection is valid.
  if(!prio.Valid)
  { 
    Console.WrtieLine(prio.ValidationErrorMsg[0]);
  }

  // Set output 0 high
  prio.SetOutput(CogPrioBankConstants.OutputBank0,         // i/o bank
  0,                                        // line number
  CogPrioOutputLineValueConstants.SetHigh); // line value to set
  }

  void InputChanged_0_HostNotification(object sender, CogPrioEventArgs e)
  {
  Console.WriteLine("rcvd host notification for InputChanged_0 event");
  }
</code>
            </example>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogCommCard.FfpAccess">
            <summary>
Gets a factory floor protocol (FFP) access object.
<para>
Use the factory floor protocol access object to access the 
factory floor protocol features of the comm card.
</para><para>
This property returns null if the hardware 
does not support factory floor protocols.
</para></summary>
            <example>
                <!-- CogCommCardExample1 -->
                <!-- Shows simple use of comm card API
     The sample:
     1. initializes software access to the comm card.
     2. initializes software access to the Network Data Model (NDM).
          a. Signs up for the NewUserData event     
-->
                <code lang="Visual Basic" />
                <code lang="C#">
using Cognex.VisionPro;
using Cognex.VisionPro.Comm;

// Shows simple use of comm card API.
//
// Initializes a connection to a Rockwell Control Logix PLC
// using the EtherNet/IP protocol and the Cognex generic
// Factory Floor Protocol (FFP) interface known as the 
// Network Data Model (NDM).
//
// Signs up for the NDM's "NewUserData" event and prints out the 
// NewUserData as it's received.
public void Example()
{
  CogCommCards commCardCollection = new CogCommCards();
      
  Console.WriteLine("Found: {0} comm cards", commCardCollection.Count);
      
  if (commCardCollection.Count == 0)
    return;

  CogCommCard card = commCardCollection[0];

  Console.WriteLine("Name: {0}", card.Name);
  Console.WriteLine("Serial: {0}", card.SerialNumber);

  Console.WriteLine("Initializing comm card Factory Floor Protocol (FFP)");

  CogFfpAccess ffpAccess = card.FfpAccess;

  if (ffpAccess == null)
    throw new Exception("FFP is not supported.");     

  CogNdm ffpNdm =
    ffpAccess.CreateNetworkDataModel(CogFfpProtocolConstants.EthernetIp);

  ffpNdm.Start();

  Console.WriteLine("Sign up for the NewUserData Event");
  ffpNdm.NewUserData += new CogNdmNewUserDataEventHandler(ffpNdm_NewUserData);    
}

void ffpNdm_NewUserData(object sender, CogNdmNewUserDataEventArgs e)
{
  CogNdm ndm = sender as CogNdm;
  if (ndm != null)
    Console.WriteLine(BitConverter.ToString(ndm.ReadUserData(0, 100)));
}
</code>
            </example>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogCommCard.FirmwareVersion">
            <summary>
Gets the version of the firmware running on the hardware.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogCommCard.ProductIdentity">
            <summary>
Gets the product identity of the hardware.
</summary>
            <remarks>
                <para>
format is [family].[series].[model].[revision]
</para>
                <para>
family: 4 (VisionPro)
</para>
                <para>
series: 56 (Vm56)
</para>
                <para>
model: 1 (for A) or 2 (for C)
</para>
                <para>
revision: 0 (reserved for future use)
</para>
                <para>
current VM56A = 4.56.1.0
</para>
                <para>
current VM56C = 4.56.2.0
</para>
            </remarks>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogCommCard.SerialNumber">
            <summary>
Gets the serial number of the comm card.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogCommCard.Name">
            <summary>
Gets the name of the comm card.
</summary>
            <remarks>
The name of the comm card includes information about the
model number (e.g. 24A, 24C).
</remarks>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogCommCard.fCallback(System.Void*,System.Void*,csBoardErrorCallbackData_*)">
            <summary>
Called when a card status error event/callback happens
</summary>
        </member>
        <member name="E:Cognex.VisionPro.Comm.CogCommCard.CardStatus">
            <summary>
This event is raised by the Comm Card to report very specific status or error
events to the host PC. CardStatus events are typically used to inform the 
host PC of important "out of band" information that cannot be reported
synchronously.
</summary>
            <remarks>
                <para>
Sign up for the <see cref="E:Cognex.VisionPro.Comm.CogCommCard.CardStatus" /> 
event and use the use the
<see cref="P:Cognex.VisionPro.Comm.CogCardStatusEventArgs.StatusCode" />
property of the event args to identify which status event code is being reported
by the Comm Card.
</para>
                <para>
Refer to the documentation for
<see cref="T:Cognex.VisionPro.Comm.CogCommCardStatusEventConstants" />
to learn what kinds of status codes are reported by the Comm Card.
</para>
            </remarks>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogCommCard">
            <summary>
The CogCommCard class represents a single VisionPro Communication Card
installed in the system.
<para>
VisionPro comm cards are hardware devices designed to handle 
communication between a VisionPro vision system and the outside world.
</para><para>
VisionPro comm cards utilize dedicated real-time processors to manage I/O.
This allows VisionPro vision systems to integrate with demanding real-time
control scenarios, and reserves PC hardware resources for image processing
and machine vision related tasks.
</para><para>
VisionPro comm cards support one or more communication modules, each
communication module supports a different type or style of communication.
</para><para>
For example, a single VisionPro comm card may support discrete (digital) 
inputs and outputs, and/or Ethernet based Factory Floor Protocols (FFP)
such as EtherNet/IP.
</para><para>
This class cannot be constructed. Instances must be retrieved from a 
<see cref="T:Cognex.VisionPro.Comm.CogCommCards" />
collection.
</para><para>
This class provides access to the communication capabilities of
a VisionPro Communication Card via its supported module interfaces.
</para><list type="bullet"><item>
Access the factory floor protocol (FFP) capabilities of the comm card via 
<see cref="P:Cognex.VisionPro.Comm.CogCommCard.FfpAccess" />.
</item><item>
Access the precision I/O (discrete I/O) capabilities of the comm card via
<see cref="P:Cognex.VisionPro.Comm.CogCommCard.DiscreteIOAccess" />.
</item></list></summary>
            <example>
                <!-- CogCommCardExample1 -->
                <!-- Shows simple use of comm card API
     The sample:
     1. initializes software access to the comm card.
     2. initializes software access to the Network Data Model (NDM).
          a. Signs up for the NewUserData event     
-->
                <code lang="Visual Basic" />
                <code lang="C#">
using Cognex.VisionPro;
using Cognex.VisionPro.Comm;

// Shows simple use of comm card API.
//
// Initializes a connection to a Rockwell Control Logix PLC
// using the EtherNet/IP protocol and the Cognex generic
// Factory Floor Protocol (FFP) interface known as the 
// Network Data Model (NDM).
//
// Signs up for the NDM's "NewUserData" event and prints out the 
// NewUserData as it's received.
public void Example()
{
  CogCommCards commCardCollection = new CogCommCards();
      
  Console.WriteLine("Found: {0} comm cards", commCardCollection.Count);
      
  if (commCardCollection.Count == 0)
    return;

  CogCommCard card = commCardCollection[0];

  Console.WriteLine("Name: {0}", card.Name);
  Console.WriteLine("Serial: {0}", card.SerialNumber);

  Console.WriteLine("Initializing comm card Factory Floor Protocol (FFP)");

  CogFfpAccess ffpAccess = card.FfpAccess;

  if (ffpAccess == null)
    throw new Exception("FFP is not supported.");     

  CogNdm ffpNdm =
    ffpAccess.CreateNetworkDataModel(CogFfpProtocolConstants.EthernetIp);

  ffpNdm.Start();

  Console.WriteLine("Sign up for the NewUserData Event");
  ffpNdm.NewUserData += new CogNdmNewUserDataEventHandler(ffpNdm_NewUserData);    
}

void ffpNdm_NewUserData(object sender, CogNdmNewUserDataEventArgs e)
{
  CogNdm ndm = sender as CogNdm;
  if (ndm != null)
    Console.WriteLine(BitConverter.ToString(ndm.ReadUserData(0, 100)));
}
</code>
            </example>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogCardStatusEventHandler">
            <summary>
Event handler for 
<see cref="E:Cognex.VisionPro.Comm.CogCommCard.CardStatus" />
event.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogCardStatusEventArgs.StatusCode">
            <summary>
The status code being reported by the Comm Card.
</summary>
            <remarks>
                <para>
Sign up for the <see cref="E:Cognex.VisionPro.Comm.CogCommCard.CardStatus" /> 
event and use the use the
<see cref="P:Cognex.VisionPro.Comm.CogCardStatusEventArgs.StatusCode" />
property of the event args to identify which status event code is being reported
by the Comm Card.
</para>
                <para>
Refer to the documentation for
<see cref="T:Cognex.VisionPro.Comm.CogCommCardStatusEventConstants" />
to learn what kinds of status codes are reported by the Comm Card.
</para>
            </remarks>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogCardStatusEventArgs.#ctor(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Construct the event args.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogCardStatusEventArgs">
            <summary>
Event args returned as part the Comm Card's CardStatus event.
</summary>
            <remarks>
                <para>
Sign up for the <see cref="E:Cognex.VisionPro.Comm.CogCommCard.CardStatus" /> 
event and use the use the
<see cref="P:Cognex.VisionPro.Comm.CogCardStatusEventArgs.StatusCode" />
property of the event args to identify which status event code is being reported
by the Comm Card.
</para>
                <para>
Refer to the documentation for
<see cref="T:Cognex.VisionPro.Comm.CogCommCardStatusEventConstants" />
to learn what kinds of status codes are reported by the Comm Card.
</para>
            </remarks>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogCardStatusUnmanagedCallbackDelegate">
            <summary>
Delegate type which is marshaled to an unmanaged function pointer and
passed to the module error call back.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogCommCardStatusEventConstants">
            <summary>
Constants enumerating the possible Comm Card status event values.
<para>
Sign up for the <see cref="E:Cognex.VisionPro.Comm.CogCommCard.CardStatus" /> 
event and use the use the
<see cref="P:Cognexi.VisionPro.Comm.CogCardStatusEventArgs.StatusCode" />
property of the event args to identify which status event code is being reported
by the Comm Card.
</para><para>
Refer to the documentation for
<see cref="T:Cognex.VisionPro.Comm.CogCommCardStatusEventConstants" />
to learn what kinds of status codes are reported by the Comm Card.
</para></summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogCommCardStatusEventConstants.ItemScheduledLate">
            <summary>
A precision I/O event or response was dropped by the internal scheduling mechanism!
The Comm Card was not able to schedule an event or response in time.
<para>
Cognex Internal Use Only
</para></summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogCommCardStatusEventConstants.OutOfDelayedEvents">
            <summary>
A precision I/O delayed output line response was dropped!
The number of outstanding delayed line responses exceeded the maximum.
<para>
Cognex Internal Use Only
</para></summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogCommCardStatusEventConstants.OutOfPulsedEvents">
            <summary>
A precision I/O pulsed output line response was dropped!
The number of outstanding pulsed line responses exceeded the maximum.
<para>
Cognex Internal Use Only
</para></summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogCommCardStatusEventConstants.HostNotificationDropped">
            <summary>
Indicates that some of the Comm Card's precision I/O HostNotification
Events may have been dropped because the queue is full.
This can happen when the Host PC does not process the
<see cref="E:Cognex.VisionPro.Comm.CogPrioEvent.HostNotification" />
events quickly enough, for instance: if your host application is 
stopped at a breakpoint while inputs to the Comm Card continue to cause 
CogPrio events on the card, you may see the HostNotificationDropped card 
status event when you resume your application.
<para>
Listen for the HostNotificationDropped card status event to know when
a precision I/O HostNotification event has been dropped. 
Note that the corresponding CogPrio event, and any responses will still
have occurred on the board, and only the notification to the host
PC has been lost.
</para><para>
The HostNotificationDropped card status event should not occur while running
a stable, well behaved application.
</para><para>
If your application causes a HostNotificationDropped card status event,
and your application wasn't just sitting at a breakpoint, it's likely
that the CogPrio HostNotification events are significantly delayed
from when the actual event has occurred on the card and you may need to slow
down you input events or reduce the number of CogPrio events that have  
HostNotification event handlers.
</para><para>
You can monitor whether HostNotification for the events are falling behind
the actual events on the board using the state information contained 
in the HostNotification event args 
(<see cref="P:Cognex.VisionPro.Comm.CogPrioEventArgs.State" />).
Comparing the TimeStamp from the HostNotification event args with the 
TimeStamp from the current State 
(i.e.  e.State.TimeDifference(mPrio.ReadState()) ) will tell
you how long ago the actual event occurred on the board relative to
when HostNotification was received.
</para><para>
Note that the HostNotificationDropped card status event is raised
as soon as possible after HostNotification queue has overflowed.
HostNotification events that are already in the queue will continue
to arrive, however, the card status event will arrive well before
the HostNotification queue has been drained to the point where the 
dropped notifications would have been.
</para></summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogFfpAccess.GetActiveNetworkDataModel">
            <summary>
Returns a reference to the currently active Network Data Model (NDM)
object held by the Comm Card or null if no currently active NDM exists. 
<para>
An active Network Data Model will only exist if one of the
<see cref="M:Cognex.VisionPro.Comm.CogFfpAccess.CreateNetworkDataModel(Cognex.VisionPro.Comm.CogFfpProtocolConstants)" />
methods has been called previously.
</para></summary>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogHardwareInUseException">
Thrown if the hardware is in use by another process.
Only a single process may access the hardware.
When this exception is thrown, you must close any other processes that are
using the hardware, and re-start this process in order to access the hardware.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogIncompatibleFirmwareException">
Thrown if the version of the Comm Card firmware is incompatible with
the version of the host library.
Run "%VPRO_ROOT%\bin\fwuphost.exe --pkg vm56_firmware_X_X_X_X.pkg" to upgrade firmware."
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogFfpAccess.CreateNetworkDataModelSlmp">
            <summary>
Creates a network data model interface on the comm card 
using the SLMP protocol.
</summary>
            <exception cref="T:System.InvalidOperationException">
Thrown if an NDM has already been created on this board.
</exception>
            <exception cref="T:System.ArgumentException">
Thrown if SLMP is not a valid protocol.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogHardwareInUseException">
Thrown if the hardware is in use by another process.
Only a single process may access the hardware.
When this exception is thrown, you must close any other processes that are
using the hardware, and re-start this process in order to access the hardware.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogIncompatibleFirmwareException">
Thrown if the version of the Comm Card firmware is incompatible with
the version of the host library.
Run "%VPRO_ROOT%\bin\fwuphost.exe --pkg vm56_firmware_X_X_X_X.pkg" to upgrade firmware."
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogFfpAccess.CreateNetworkDataModelEip">
            <summary>
Creates a network data model interface on the comm card 
using the EtherNet/IP protocol.
</summary>
            <exception cref="T:System.InvalidOperationException">
Thrown if an NDM has already been created on this board.
</exception>
            <exception cref="T:System.ArgumentException">
Thrown if EtherNet/IP is not a valid protocol.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogHardwareInUseException">
Thrown if the hardware is in use by another process.
Only a single process may access the hardware.
When this exception is thrown, you must close any other processes that are
using the hardware, and re-start this process in order to access the hardware.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogIncompatibleFirmwareException">
Thrown if the version of the Comm Card firmware is incompatible with
the version of the host library.
Run "%VPRO_ROOT%\bin\fwuphost.exe --pkg vm56_firmware_X_X_X_X.pkg" to upgrade firmware."
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogFfpAccess.CreateNetworkDataModelProfinet">
            <summary>
Creates a network data model interface on the comm card 
using the PROFINET protocol.
</summary>
            <exception cref="T:System.InvalidOperationException">
Thrown if an NDM has already been created on this board.
</exception>
            <exception cref="T:System.ArgumentException">
Thrown if PROFINET is not a valid protocol.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogHardwareInUseException">
Thrown if the hardware is in use by another process.
Only a single process may access the hardware.
When this exception is thrown, you must close any other processes that are
using the hardware, and re-start this process in order to access the hardware.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogIncompatibleFirmwareException">
Thrown if the version of the Comm Card firmware is incompatible with
the version of the host library.
Run "%VPRO_ROOT%\bin\fwuphost.exe --pkg vm56_firmware_X_X_X_X.pkg" to upgrade firmware."
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogFfpAccess.CreateNetworkDataModel(Cognex.VisionPro.Comm.CogFfpProtocolConstants)">
            <summary>
Creates a network data model (NDM) interface on the comm card.
The network data model is used to send and receive
messages between the vision system and a remote device
(usually a PLC).
</summary>
            <exception cref="T:System.InvalidOperationException">
Thrown if an NDM has already been created on this board.
Note that you can get access to a previously created NDM instance
held by the CommCard via 
<see cref="M:Cognex.VisionPro.Comm.CogNdm.GetActiveNetworkDataModel" /></exception>
            <exception cref="T:System.ArgumentException">
Thrown if protocolType is invalid.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogHardwareInUseException">
Thrown if the hardware is in use by another process.
Only a single process may access the hardware.
When this exception is thrown, you must close any other processes that are
using the hardware, and re-start this process in order to access the hardware.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogIncompatibleFirmwareException">
Thrown if the version of the Comm Card firmware is incompatible with
the version of the host library.
Run "%VPRO_ROOT%\bin\fwuphost.exe --pkg vm56_firmware_X_X_X_X.pkg" to upgrade firmware."
</exception>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogFfpAccess.AvailableProtocols">
            <summary>
Returns a list of the available protocols.
</summary>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogHardwareInUseException">
Thrown if the hardware is in use by another process.
Only a single process may access the hardware.
When this exception is thrown, you must close any other processes that are
using the hardware, and re-start this process in order to access the hardware.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogIncompatibleFirmwareException">
Thrown if the version of the Comm Card firmware is incompatible with
the version of the host library.
Run "%VPRO_ROOT%\bin\fwuphost.exe --pkg vm56_firmware_X_X_X_X.pkg" to upgrade firmware."
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogFfpAccess.#ctor(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Construct a useless object with no underlying module
interface that will return hardware in use errors 
when its methods are called.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogFfpAccess">
            <summary>
Instances of CogFfpAccess class are held by the 
<see cref="T:Cognex.VisionPro.Comm.CogCommCard" /> comm card class.
<para>
CogFfpAccess is used to factory/initialize instances of the 
factory floor protocols running on the comm card by calling 
<see cref="M:Cognex.VisionPro.Comm.CogFfpAccess.CreateNetworkDataModel(Cognex.VisionPro.Comm.CogFfpProtocolConstants)" />.
</para><para>
The Network Data Model (NDM) is the way Cognex VisionPro Vision Systems
interact with a PLC.
</para></summary>
            <example>
                <!-- CogCommCardExample1 -->
                <!-- Shows simple use of comm card API
     The sample:
     1. initializes software access to the comm card.
     2. initializes software access to the Network Data Model (NDM).
          a. Signs up for the NewUserData event     
-->
                <code lang="Visual Basic" />
                <code lang="C#">
using Cognex.VisionPro;
using Cognex.VisionPro.Comm;

// Shows simple use of comm card API.
//
// Initializes a connection to a Rockwell Control Logix PLC
// using the EtherNet/IP protocol and the Cognex generic
// Factory Floor Protocol (FFP) interface known as the 
// Network Data Model (NDM).
//
// Signs up for the NDM's "NewUserData" event and prints out the 
// NewUserData as it's received.
public void Example()
{
  CogCommCards commCardCollection = new CogCommCards();
      
  Console.WriteLine("Found: {0} comm cards", commCardCollection.Count);
      
  if (commCardCollection.Count == 0)
    return;

  CogCommCard card = commCardCollection[0];

  Console.WriteLine("Name: {0}", card.Name);
  Console.WriteLine("Serial: {0}", card.SerialNumber);

  Console.WriteLine("Initializing comm card Factory Floor Protocol (FFP)");

  CogFfpAccess ffpAccess = card.FfpAccess;

  if (ffpAccess == null)
    throw new Exception("FFP is not supported.");     

  CogNdm ffpNdm =
    ffpAccess.CreateNetworkDataModel(CogFfpProtocolConstants.EthernetIp);

  ffpNdm.Start();

  Console.WriteLine("Sign up for the NewUserData Event");
  ffpNdm.NewUserData += new CogNdmNewUserDataEventHandler(ffpNdm_NewUserData);    
}

void ffpNdm_NewUserData(object sender, CogNdmNewUserDataEventArgs e)
{
  CogNdm ndm = sender as CogNdm;
  if (ndm != null)
    Console.WriteLine(BitConverter.ToString(ndm.ReadUserData(0, 100)));
}
</code>
            </example>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmSlmp.GetSlmpConfig">
            <summary>
Gets the SLMP specific NDM settings from the hardware.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmSlmp.SetSlmpConfig(Cognex.VisionPro.Comm.CogNdmSlmpConfig)">
            <summary>
Sets the SLMP specific NDM settings.
</summary>
            <exception cref="T:System.ArgumentNullException">
Thrown if slmpConfig is null.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidSlmpConfigException">
Thrown if the NDM is currently running, the slmp config NdmSignalBlockMapping is invalid,
or the slmp config contains invalid parameters.
<list type="table"><listheader><term>SLMP Config Property</term><term>Default</term><term>Valid Range</term></listheader><item><term>Timeout</term><term>1000.0</term><term>5.0 - 1000.0</term></item><item><term>PollRate</term><term>1000.0</term><term>5.0 - 1000.0</term></item><item><term>MessageFormat</term><term>QLSeries_3E</term><term>QLSeries_3E or FXSeries_1E</term></item><item><term>TartgetAddress</term><term>null</term><term>0.0.0.1 - 223.255.255.254</term></item><item><term>TargetPort</term><term>12288 (0x3000)</term><term>1 - 65535</term></item><item><term>RemoteStationID</term><term>255</term><term>0-120, 126, 255</term></item><item><term>RemoteStationNetworkID</term><term>0</term><term>0 - 239</term></item><item><term>RemoteStationDestStationID</term><term>0</term><term>0</term></item></list></exception>
            <remarks>
Note that this function automatically persists the SLMP settings to
flash storage on the hardware.
</remarks>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmSlmp">
            <summary>
The Network Data Model (NDM) allows Cognex Vision Systems interact with 
different PLCs and Ethernet based factory floor protocols in a uniform fashion.
<para>
The Network Data Model SeamLess Messaging Protocol (SLMP) class supports sending
and receiving messages between a Vision System and a Mitsubishi PLC using
the following variants of the SLMP protocol:
<list type="bullet"><item>
1E MC Protocol Frames over TCP/IP (FX series PLCs over Ethernet).
</item><item>
3E SLMP Protocol Frames over TCP/IP (Q and L series PLCs over Ethernet and CC-Link IE field gateways).
</item></list></para><para>
Use <see cref="M:Cognex.VisionPro.Comm.CogNdmSlmp.GetSlmpConfig" /> and
<see cref="M:Cognex.VisionPro.Comm.CogNdmSlmp.SetSlmpConfig(Cognex.VisionPro.Comm.CogNdmSlmpConfig)" /> to read and 
write settings which are specific to SLMP communications. 
</para></summary>
            <remarks>
                <para>
The following table describes host the NDM signal table is layed
out into 4 seperate blocks specific to SLMP.
</para>
                <code>
The SLMP "ControlBit" signal table/block organizes the single bit NDM signals
sent from the PLC to Vision System. The ControlBit block is 80 bits long.
+----------------+---------+-------+----------+-----------+-----------+------------+-----------+---------+
|                | Bit 7   | Bit 6 | Bit 5    | Bit 4     | Bit 3     | Bit 2      | Bit 1     | Bit 0   |
+----------------+---------+-------+----------+-----------+-----------+------------+-----------+---------+
| 0              | Set     | Clear | Rsvd     | Initiate  | Rsvd      | Rsvd       | Buffer    | Trigger |
|                | Offline | Error |          | Job       |           |            | Results   | Enable  |
|                |         |       |          | Load      |           |            | Enable    |         |
+--------------------------------------------------------------------------------------------------------+
| 1              |                              Rsvd                                                     |
+--------------------------------------------------------------------------------------------------------+
| 2-5            |                              SoftEvent 0-31                                           |
+--------------------------------------------------------------------------------------------------------+
| 6              | Rsvd    | Rsvd  | Rsvd     | Rsvd      | Set User | Clear      | Inspection | Trigger |
|                |         |       |          |           | Data 0   | Exposure   | Results    | Camera  |
|                |         |       |          |           |          | Complete 0 | Ack 0      | 0       |
+--------------------------------------------------------------------------------------------------------+
| 7              | Rsvd    | Rsvd  | Rsvd     | Rsvd      | Set User | Clear      | Inspection | Trigger |
|                |         |       |          |           | Data 1   | Exposure   | Results    | Camera  |
|                |         |       |          |           |          | Complete 1 | Ack 1      | 1       |
+--------------------------------------------------------------------------------------------------------+
| 8              | Rsvd    | Rsvd  | Rsvd     | Rsvd      | Set User | Clear      | Inspection | Trigger |
|                |         |       |          |           | Data 2   | Exposure   | Results    | Camera  |
|                |         |       |          |           |          | Complete 2 | Ack 2      | 2       |
+--------------------------------------------------------------------------------------------------------+
| 9              | Rsvd    | Rsvd  | Rsvd     | Rsvd      | Set User | Clear      | Inspection | Trigger |
|                |         |       |          |           | Data 3   | Exposure   | Results    | Camera  |
|                |         |       |          |           |          | Complete 3 | Ack 3      | 3       |
+--------------------------------------------------------------------------------------------------------+

The SLMP "StatusBit" signal table/block organizes the single bit NDM signals
sent from the Vision System to the PLC.  The StatusBit block is 112 bits long.
+----------------------------------------------------------------------------------------------------------+
¦        ¦ Bit 7     ¦ Bit 6       ¦ Bit 5     ¦ Bit 4       ¦ Bit 3      ¦ Bit 2   ¦ Bit 1    ¦ Bit 0     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 0      ¦ Online    ¦               Offline                 ¦ Rsvd       ¦ Rsvd    ¦ System   ¦ System    ¦
¦        ¦           ¦               Reason                  ¦            ¦         ¦ Busy     ¦ Ready     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 1      ¦ General   ¦ Rsvd        ¦ Job Load  ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Rsvd      ¦
¦        ¦ Fault     ¦             ¦ Completed ¦             ¦            ¦         ¦          ¦           ¦
+----------------------------------------------------------------------------------------------------------+
¦ 2-5    ¦                                  Soft Event Ack 0-31                                            ¦
+----------------------------------------------------------------------------------------------------------+
¦ 6      ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦
¦        ¦ Buffer    ¦ Passed 0    ¦ Valid 0   ¦ Completed 0 ¦ Complete 0 ¦ Error 0 ¦ Ack      ¦ Ready     ¦
¦        ¦ Overrun 0 ¦             ¦           ¦             ¦            ¦         ¦ Camera 0 ¦ Camera 0  ¦
+----------------------------------------------------------------------------------------------------------+
¦ 7      ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 0     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 8      ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦
¦        ¦ Buffer    ¦ Passed 1    ¦ Valid 1   ¦ Completed 1 ¦ Complete 1 ¦ Error 1 ¦ Ack      ¦ Ready     ¦
¦        ¦ Overrun 1 ¦             ¦           ¦             ¦            ¦         ¦ Camera 1 ¦ Camera 1  ¦
+----------------------------------------------------------------------------------------------------------+
¦ 9      ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 1     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 10     ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦
¦        ¦ Buffer    ¦ Passed 2    ¦ Valid 2   ¦ Completed 2 ¦ Complete 2 ¦ Error 2 ¦ Ack      ¦ Ready     ¦
¦        ¦ Overrun 2 ¦             ¦           ¦             ¦            ¦         ¦ Camera 2 ¦ Camera 2  ¦
+----------------------------------------------------------------------------------------------------------+
¦ 11     ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 2     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 12     ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦
¦        ¦ Buffer    ¦ Passed 3    ¦ Valid 3   ¦ Completed 3 ¦ Complete 3 ¦ Error 3 ¦ Ack      ¦ Ready     ¦
¦        ¦ Overrun 3 ¦             ¦           ¦             ¦            ¦         ¦ Camera 3 ¦ Camera 3  ¦
+----------------------------------------------------------------------------------------------------------+
¦ 13     ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 3     ¦
+----------------------------------------------------------------------------------------------------------+

The SLMP "StatusWord" signal table/block organizes the word length signals sent from the Vision System to the PLC.
The size of the StatusWord block can vary depending on the size of the inspection results section.
+----------------------------------------------+
¦        ¦             16Bit Word              ¦
+----------------------------------------------+
¦ 0      ¦        Current Job ID               ¦
+----------------------------------------------+
¦ 1      ¦        Error ID                     ¦
+----------------------------------------------+
¦ 2      ¦        Acquisition ID 0             ¦
+----------------------------------------------+
¦ 3      ¦        Inspected Image ID 0         ¦
+----------------------------------------------+
¦ 4      ¦        Inspection Result Code 0     ¦
+----------------------------------------------+
¦ 5      ¦        Acquisition ID 1             ¦
+----------------------------------------------+
¦ 6      ¦        Inspected Image ID 1         ¦
+----------------------------------------------+
¦ 7      ¦        Inspection Result Code 1     ¦
+----------------------------------------------+
¦ 8      ¦        Acquisition ID 2             ¦
+----------------------------------------------+
¦ 9      ¦        Inspected Image ID 2         ¦
+----------------------------------------------+
¦ 10     ¦        Inspection Result Code 2     ¦
+----------------------------------------------+
¦ 11     ¦        Acquisition ID 3             ¦
+----------------------------------------------+
¦ 12     ¦        Inspected Image ID 3         ¦
+----------------------------------------------+
¦ 13     ¦        Inspection Result Code 3     ¦
+----------------------------------------------+
¦ 14-960 ¦        Inspection Results           ¦
+----------------------------------------------+

The SLMP "ControlWord" signal table/block organizes the word length signals sent from the PLC to the Vision System.
The size of the ControlWord block can vary depending on the size of the user data section.
+----------------------------------------------+
¦        ¦             16Bit Word              ¦
+----------------------------------------------+
¦ 0      ¦         Job Load ID                 ¦
+----------------------------------------------+
¦ 1-960  ¦         User Data                   ¦
+----------------------------------------------+

You can use CogNdmSlmpSignalBlockConstants and CogNdmSlmpDeviceConstants to map blocks of NDM signals to
SLMP devices with the CogNdmSlmpBlockMappingCollection class.

The following table describes the SLMP memory block addresses supported on the Q, L, and FX PLCs:

+-------------------------------+--------+----------------+----------------------------------+-----+----+
|          Device Name          | Prefix | Bit/Word based |      Address Representation      | Q/L | FX |
+-------------------------------+--------+----------------+----------------------------------+-----+----+
| Input Relay                   | X      | Bit            | Hex(Q/L Series) Octal(FX series) | X   | X  |
| Output Relay                  | Y      | Bit            | Hex(Q/L Series) Octal(FX series) | X   | X  |
| Internal Relay                | M      | Bit            | Decimal                          | X   | X  |
| Latch Relay                   | L      | Bit            | Decimal                          | X   | -  |
| Annunciator                   | F      | Bit            | Decimal                          | X   | -  |
| Link Relay                    | B      | Bit            | Hex                              | X   | -  |
| State Relay                   | S      | Bit            | Decimal                          | -   | X  |
| Data Register                 | D      | Word           | Decimal                          | X   | X  |
| Link Register                 | W      | Word           | Hex                              | X   | -  |
| File Register                 | R      | Word           | Decimal                          | X   | X  |
| File Register Multiple Blocks | ZR     | Word           | Hex                              | X   | -  |
| Timer                         | TN     | Word           | Decimal                          | X   | X  |
| Counter                       | CN     | Word           | Decimal                          | X   | X  |
+-------------------------------+--------+----------------+----------------------------------+-----+----+

The most commonly used devices used to communicate vision data to a PLC, are the M (Internal Relay) and
D (Data Register) types.
</code>
            </remarks>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmEip">
            <summary>
                <para>
The Network Data Model (NDM) allows Cognex Vision Systems interact with 
different PLCs and Ethernet based factory floor protocols in a uniform fashion.
</para>
                <para>
The Network Data Model EtherNet/IP class supports sending and receiving
messages between the vision system and a Rockwell Control Logix PLC using
the EtherNet/IP protocol
</para>
                <para>
Note: The instance number for the Rockwell Input Assembly is 11 and for the Output Assembly is 21.
</para>
            </summary>
            <remarks>
                <code>
NDM Status Signal Table (Status signals are signals sent from the Vision System to the PLC)
+----------------------------------------------------------------------------------------------------------+
¦        ¦ Bit 7     ¦ Bit 6       ¦ Bit 5     ¦ Bit 4       ¦ Bit 3      ¦ Bit 2   ¦ Bit 1    ¦ Bit 0     ¦
+----------------------------------------------------------------------------------------------------------+  ---
¦ 0      ¦ Online    ¦               Offline                 ¦ Rsvd       ¦ Rsvd    ¦ System   ¦ System    ¦     |
¦        ¦           ¦               Reason                  ¦            ¦         ¦ Busy     ¦ Ready     ¦  S  |
+----------------------------------------------------------------------------------------------------------+  y  |
¦ 1      ¦ General   ¦ Rsvd        ¦ Job Load  ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Rsvd      ¦  s  |
¦        ¦ Fault     ¦             ¦ Completed ¦             ¦            ¦         ¦          ¦           ¦  t  |
+----------------------------------------------------------------------------------------------------------+  e  |
¦ 2      ¦                                  Reserved                                                       ¦  m  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 3      ¦                                  Reserved                                                       ¦  S  |
+----------------------------------------------------------------------------------------------------------+  t  |
¦ 4-5    ¦                                  Current Job ID                                                 ¦  a  |
+----------------------------------------------------------------------------------------------------------+  t  |
¦ 6-7    ¦                                  Error ID                                                       ¦  u  |
+----------------------------------------------------------------------------------------------------------+  s  |
¦ 8-11   ¦                                  Soft Event Ack 0-31                                            ¦     |
+----------------------------------------------------------------------------------------------------------+     |
¦ 12-15  ¦                                  Reserved                                                       ¦     |
+----------------------------------------------------------------------------------------------------------+  ---
¦ 16     ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦     |
¦        ¦ Buffer    ¦ Passed 0    ¦ Valid 0   ¦ Completed 0 ¦ Complete 0 ¦ Error 0 ¦ Ack      ¦ Ready     ¦  E  |
¦        ¦ Overrun 0 ¦             ¦           ¦             ¦            ¦         ¦ Camera 0 ¦ Camera 0  ¦  n  |
+----------------------------------------------------------------------------------------------------------+  g  |
¦ 17     ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦  i  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦  n  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 0     ¦  e  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 18-19  ¦                                  Acquisition ID 0                                               ¦  0  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 20-21  ¦                                  Inspected Image ID 0                                           ¦     |
+----------------------------------------------------------------------------------------------------------+     |
¦ 22-23  ¦                                  Inspection Result Code 0                                       ¦     |
+----------------------------------------------------------------------------------------------------------+  ---
¦ 24     ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦     |
¦        ¦ Buffer    ¦ Passed 1    ¦ Valid 1   ¦ Completed 1 ¦ Complete 1 ¦ Error 1 ¦ Ack      ¦ Ready     ¦  E  |
¦        ¦ Overrun 1 ¦             ¦           ¦             ¦            ¦         ¦ Camera 1 ¦ Camera 1  ¦  n  |
+----------------------------------------------------------------------------------------------------------+  g  |
¦ 25     ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦  i  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦  n  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 1     ¦  e  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 26-27  ¦                                  Acquisition ID 1                                               ¦  1  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 28-29  ¦                                  Inspected Image ID 1                                           ¦     |
+----------------------------------------------------------------------------------------------------------+     |
¦ 30-31  ¦                                  Inspection Result Code 1                                       ¦     |
+----------------------------------------------------------------------------------------------------------+  ---
¦ 32     ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦     |
¦        ¦ Buffer    ¦ Passed 2    ¦ Valid 2   ¦ Completed 2 ¦ Complete 2 ¦ Error 2 ¦ Ack      ¦ Ready     ¦  E  |
¦        ¦ Overrun 2 ¦             ¦           ¦             ¦            ¦         ¦ Camera 2 ¦ Camera 2  ¦  n  |
+----------------------------------------------------------------------------------------------------------+  g  |
¦ 33     ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦  i  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦  n  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 2     ¦  e  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 34-35  ¦                                  Acquisition ID 2                                               ¦  2  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 36-37  ¦                                  Inspected Image ID 2                                           ¦     |
+----------------------------------------------------------------------------------------------------------+     |
¦ 38-39  ¦                                  Inspection Result Code 2                                       ¦     |
+----------------------------------------------------------------------------------------------------------+  ---
¦ 40     ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦     |
¦        ¦ Buffer    ¦ Passed 3    ¦ Valid 3   ¦ Completed 3 ¦ Complete 3 ¦ Error 3 ¦ Ack      ¦ Ready     ¦  E  |
¦        ¦ Overrun 3 ¦             ¦           ¦             ¦            ¦         ¦ Camera 3 ¦ Camera 3  ¦  n  |
+----------------------------------------------------------------------------------------------------------+  g  |
¦ 41     ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦  i  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦  n  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 3     ¦  e  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 42-43  ¦                                  Acquisition ID 3                                               ¦  3  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 44-45  ¦                                  Inspected Image ID 3                                           ¦     |
+----------------------------------------------------------------------------------------------------------+     |
¦ 46-47  ¦                                  Inspection Result Code 3                                       ¦     |
+----------------------------------------------------------------------------------------------------------+  ---
¦ 48-??? ¦                                  Inspection Results                                             ¦     |
¦        ¦                                                                                                 ¦  R  |
¦        ¦                                                                                                 ¦  e  |
¦        ¦                                                                                                 ¦  s  |
¦        ¦                                                                                                 ¦  u  |
¦        ¦                                                                                                 ¦  l  |
¦        ¦                                                                                                 ¦  t  |
¦        ¦                                                                                                 ¦  s  |
¦        ¦                                                                                                 ¦     |
+----------------------------------------------------------------------------------------------------------+ ----
</code>
                <code>
NDM Control Signal Table (Controls signals are signals sent from the PLC to the Vision System)
+--------------------------------------------------------------------------------------------------+
¦        ¦ Bit 7   ¦ Bit 6  ¦ Bit 5    ¦ Bit 4     ¦ Bit 3  ¦ Bit 2       ¦ Bit 1       ¦ Bit 0    ¦
+--------------------------------------------------------------------------------------------------+  ---
¦ 0      ¦ Set     ¦ Clear  ¦ Reserved ¦ Initiate  ¦  Rsvd  ¦ Rsvd        ¦ Buffer      ¦ Trigger  ¦     |
¦        ¦ Offline ¦ Error  ¦          ¦ Job       ¦        ¦             ¦ Results     ¦ Enable   ¦  S  |
¦        ¦         ¦        ¦          ¦ Load      ¦        ¦             ¦ Enable      ¦          ¦  y  |
+--------------------------------------------------------------------------------------------------+  s  |
¦ 1      ¦                          Reserved                                                       ¦  t  |
+--------------------------------------------------------------------------------------------------+  e  |
¦ 2-3    ¦                          Job Load ID                                                    ¦  m  |
+--------------------------------------------------------------------------------------------------+     |
¦ 4-7    ¦                          SoftEvent 0-31                                                 ¦  C  |
+--------------------------------------------------------------------------------------------------+  o  |
¦ 8-9    ¦                          Reserved                                                       ¦  n  |
+--------------------------------------------------------------------------------------------------+  t  |
¦ 10-11  ¦                          Reserved                                                       ¦  r  |
+--------------------------------------------------------------------------------------------------+  o  |
¦ 12-13  ¦                          Reserved                                                       ¦  l  |
+--------------------------------------------------------------------------------------------------+     |
¦ 14-15  ¦                          Reserved                                                       ¦     |
+--------------------------------------------------------------------------------------------------+  ---
¦ 16     ¦ Rsvd    ¦ Rsvd   ¦ Rsvd     ¦ Rsvd      ¦ Set    ¦ Clear       ¦ Inspection  ¦ Trigger  ¦     |
¦        ¦         ¦        ¦          ¦           ¦ User   ¦ Exposure    ¦ Results     ¦ Camera 0 ¦  E  |
¦        ¦         ¦        ¦          ¦           ¦ Data 0 ¦ Complete 0  ¦ Ack 0       ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  g  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  i  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  e  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  0  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
+--------------------------------------------------------------------------------------------------+  ---
¦ 17     ¦ Rsvd    ¦ Rsvd   ¦ Rsvd     ¦ Rsvd      ¦ Set    ¦ Clear       ¦ Inspection  ¦ Trigger  ¦     |
¦        ¦         ¦        ¦          ¦           ¦ User   ¦ Exposure    ¦ Results     ¦ Camera 1 ¦  E  |
¦        ¦         ¦        ¦          ¦           ¦ Data 1 ¦ Complete 1  ¦ Ack 1       ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  g  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  i  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  e  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  l  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
+--------------------------------------------------------------------------------------------------+  ---
¦ 18     ¦ Rsvd    ¦ Rsvd   ¦ Rsvd     ¦ Rsvd      ¦ Set    ¦ Clear       ¦ Inspection  ¦ Trigger  ¦     |
¦        ¦         ¦        ¦          ¦           ¦ User   ¦ Exposure    ¦ Results     ¦ Camera 2 ¦  E  |
¦        ¦         ¦        ¦          ¦           ¦ Data 2 ¦ Complete 2  ¦ Ack 2       ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  g  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  i  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  e  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  2  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
+--------------------------------------------------------------------------------------------------+  ---
¦ 19     ¦ Rsvd    ¦ Rsvd   ¦ Rsvd     ¦ Rsvd      ¦ Set    ¦ Clear       ¦ Inspection  ¦ Trigger  ¦     |
¦        ¦         ¦        ¦          ¦           ¦ User   ¦ Exposure    ¦ Results     ¦ Camera 3 ¦  E  |
¦        ¦         ¦        ¦          ¦           ¦ Data 3 ¦ Complete 3  ¦ Ack 3       ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  g  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  i  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  e  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  3  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
+--------------------------------------------------------------------------------------------------+  ---
¦ 20-??? ¦                          User Data                                                      ¦     |
¦        ¦                                                                                         ¦  U  |
¦        ¦                                                                                         ¦  s  |
¦        ¦                                                                                         ¦  e  |
¦        ¦                                                                                         ¦  r  |
¦        ¦                                                                                         ¦     |
¦        ¦                                                                                         ¦  D  |
¦        ¦                                                                                         ¦  a  |
¦        ¦                                                                                         ¦  t  |
¦        ¦                                                                                         ¦  a  |
¦        ¦                                                                                         ¦     |
+--------------------------------------------------------------------------------------------------+ ----
</code>
            </remarks>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmProfinet.GetProfinetConfig">
            <summary>
Gets the PROFINET specific NDM settings.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmProfinet.SetProfinetConfig(Cognex.VisionPro.Comm.CogNdmProfinetConfig)">
            <summary>
Sets the PROFINET specific NDM settings.
Use this method to set the PROFINET Station Name.
</summary>
            <exception cref="T:System.ArgumentNullException">
Thrown if profinetConfig is null.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidOperationException">
Thrown if the <see cref="P:Cognex.VisionPro.Comm.CogNdmProfinetConfig.StationName" /> is set to an invalid value.
<para>
EXAMPLE 1 “device-1.machine-1.plant-1.vendor”
</para><para>
EXAMPLE 2 “device-1.bögeholz“ is coded as “device-1.xn-bgeholz-90a“
</para><list type="bullet"><item>
1 or more labels, separated by [.]    
</item><item>
Total length is 1 to 240
</item><item>
Label length is 1 to 63     
</item><item>
Labels consist of [a-z0-9-]      
</item><item>
Labels do not start with [-]      
</item><item>
Labels do not end with [-]
</item><item>
The first label does not start with "port-xyz" or "port-xyz-abcde" with a,b,c,d,e, x, y, z = 0...9   
</item><item>
Station-names do not have the form n.n.n.n, n = 0...999
</item><item>
Labels do only start with 'xn-' if RFC 3490 is applied
</item><item>
The definition of RFC 3490 shall be applied.
</item></list></exception>
        </member>
        <member name="E:Cognex.VisionPro.Comm.CogNdmProfinet.ProfinetConfigChanged">
            <summary>
The NDM raises the ProfinetConfigChanged event to tell the vision system
that the PROFINET specific configuration settings have changed.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmProfinet">
            <summary>
                <para>
The Network Data Model (NDM) allows Cognex Vision Systems interact
with different PLCs and Ethernet based factory floor protocols in a 
uniform fashion.
</para>
                <para>
This class is the PROFINET specific implementation of the NDM.
There are three members of this class that are specific to PROFINET and
are not part of the CogNdm base class. They are:
<list type="bullet"><item><see cref="M:Cognex.VisionPro.Comm.CogNdmProfinet.GetProfinetConfig" /></item><item><see cref="M:Cognex.VisionPro.Comm.CogNdmProfinet.SetProfinetConfig(Cognex.VisionPro.Comm.CogNdmProfinetConfig)" /></item><item><see cref="E:Cognex.VisionPro.Comm.CogNdmProfinet.ProfinetConfigChanged" /></item></list></para>
            </summary>
            <remarks>
                <code>
NDM Status Signal Table (Status signals are signals sent from the Vision System to the PLC)
+----------------------------------------------------------------------------------------------------------+
¦        ¦ Bit 7     ¦ Bit 6       ¦ Bit 5     ¦ Bit 4       ¦ Bit 3      ¦ Bit 2   ¦ Bit 1    ¦ Bit 0     ¦
+----------------------------------------------------------------------------------------------------------+  ---
¦ 0      ¦ Online    ¦               Offline                 ¦ Rsvd       ¦ Rsvd    ¦ System   ¦ System    ¦     |
¦        ¦           ¦               Reason                  ¦            ¦         ¦ Busy     ¦ Ready     ¦  S  |
+----------------------------------------------------------------------------------------------------------+  y  |
¦ 1      ¦ General   ¦ Rsvd        ¦ Job Load  ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Rsvd      ¦  s  |
¦        ¦ Fault     ¦             ¦ Completed ¦             ¦            ¦         ¦          ¦           ¦  t  |
+----------------------------------------------------------------------------------------------------------+  e  |
¦ 2      ¦                                  Reserved                                                       ¦  m  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 3      ¦                                  Reserved                                                       ¦  S  |
+----------------------------------------------------------------------------------------------------------+  t  |
¦ 4-5    ¦                                  Current Job ID                                                 ¦  a  |
+----------------------------------------------------------------------------------------------------------+  t  |
¦ 6-7    ¦                                  Error ID                                                       ¦  u  |
+----------------------------------------------------------------------------------------------------------+  s  |
¦ 8-11   ¦                                  Soft Event Ack 0-31                                            ¦     |
+----------------------------------------------------------------------------------------------------------+     |
¦ 12-15  ¦                                  Reserved                                                       ¦     |
+----------------------------------------------------------------------------------------------------------+  ---
¦ 16     ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦     |
¦        ¦ Buffer    ¦ Passed 0    ¦ Valid 0   ¦ Completed 0 ¦ Complete 0 ¦ Error 0 ¦ Ack      ¦ Ready     ¦  E  |
¦        ¦ Overrun 0 ¦             ¦           ¦             ¦            ¦         ¦ Camera 0 ¦ Camera 0  ¦  n  |
+----------------------------------------------------------------------------------------------------------+  g  |
¦ 17     ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦  i  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦  n  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 0     ¦  e  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 18-19  ¦                                  Acquisition ID 0                                               ¦  0  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 20-21  ¦                                  Inspected Image ID 0                                           ¦     |
+----------------------------------------------------------------------------------------------------------+     |
¦ 22-23  ¦                                  Inspection Result Code 0                                       ¦     |
+----------------------------------------------------------------------------------------------------------+  ---
¦ 24     ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦     |
¦        ¦ Buffer    ¦ Passed 1    ¦ Valid 1   ¦ Completed 1 ¦ Complete 1 ¦ Error 1 ¦ Ack      ¦ Ready     ¦  E  |
¦        ¦ Overrun 1 ¦             ¦           ¦             ¦            ¦         ¦ Camera 1 ¦ Camera 1  ¦  n  |
+----------------------------------------------------------------------------------------------------------+  g  |
¦ 25     ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦  i  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦  n  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 1     ¦  e  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 26-27  ¦                                  Acquisition ID 1                                               ¦  1  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 28-29  ¦                                  Inspected Image ID 1                                           ¦     |
+----------------------------------------------------------------------------------------------------------+     |
¦ 30-31  ¦                                  Inspection Result Code 1                                       ¦     |
+----------------------------------------------------------------------------------------------------------+  ---
¦ 32     ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦     |
¦        ¦ Buffer    ¦ Passed 2    ¦ Valid 2   ¦ Completed 2 ¦ Complete 2 ¦ Error 2 ¦ Ack      ¦ Ready     ¦  E  |
¦        ¦ Overrun 2 ¦             ¦           ¦             ¦            ¦         ¦ Camera 2 ¦ Camera 2  ¦  n  |
+----------------------------------------------------------------------------------------------------------+  g  |
¦ 33     ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦  i  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦  n  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 2     ¦  e  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 34-35  ¦                                  Acquisition ID 2                                               ¦  2  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 36-37  ¦                                  Inspected Image ID 2                                           ¦     |
+----------------------------------------------------------------------------------------------------------+     |
¦ 38-39  ¦                                  Inspection Result Code 2                                       ¦     |
+----------------------------------------------------------------------------------------------------------+  ---
¦ 40     ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦     |
¦        ¦ Buffer    ¦ Passed 3    ¦ Valid 3   ¦ Completed 3 ¦ Complete 3 ¦ Error 3 ¦ Ack      ¦ Ready     ¦  E  |
¦        ¦ Overrun 3 ¦             ¦           ¦             ¦            ¦         ¦ Camera 3 ¦ Camera 3  ¦  n  |
+----------------------------------------------------------------------------------------------------------+  g  |
¦ 41     ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦  i  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦  n  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 3     ¦  e  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 42-43  ¦                                  Acquisition ID 3                                               ¦  3  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 44-45  ¦                                  Inspected Image ID 3                                           ¦     |
+----------------------------------------------------------------------------------------------------------+     |
¦ 46-47  ¦                                  Inspection Result Code 3                                       ¦     |
+----------------------------------------------------------------------------------------------------------+  ---
¦ 48-??? ¦                                  Inspection Results                                             ¦     |
¦        ¦                                                                                                 ¦  R  |
¦        ¦                                                                                                 ¦  e  |
¦        ¦                                                                                                 ¦  s  |
¦        ¦                                                                                                 ¦  u  |
¦        ¦                                                                                                 ¦  l  |
¦        ¦                                                                                                 ¦  t  |
¦        ¦                                                                                                 ¦  s  |
¦        ¦                                                                                                 ¦     |
+----------------------------------------------------------------------------------------------------------+ ----
</code>
                <code>
NDM Control Signal Table (Controls signals are signals sent from the PLC to the Vision System)
+--------------------------------------------------------------------------------------------------+
¦        ¦ Bit 7   ¦ Bit 6  ¦ Bit 5    ¦ Bit 4     ¦ Bit 3  ¦ Bit 2       ¦ Bit 1       ¦ Bit 0    ¦
+--------------------------------------------------------------------------------------------------+  ---
¦ 0      ¦ Set     ¦ Clear  ¦ Reserved ¦ Initiate  ¦  Rsvd  ¦ Rsvd        ¦ Buffer      ¦ Trigger  ¦     |
¦        ¦ Offline ¦ Error  ¦          ¦ Job       ¦        ¦             ¦ Results     ¦ Enable   ¦  S  |
¦        ¦         ¦        ¦          ¦ Load      ¦        ¦             ¦ Enable      ¦          ¦  y  |
+--------------------------------------------------------------------------------------------------+  s  |
¦ 1      ¦                          Reserved                                                       ¦  t  |
+--------------------------------------------------------------------------------------------------+  e  |
¦ 2-3    ¦                          Job Load ID                                                    ¦  m  |
+--------------------------------------------------------------------------------------------------+     |
¦ 4-7    ¦                          SoftEvent 0-31                                                 ¦  C  |
+--------------------------------------------------------------------------------------------------+  o  |
¦ 8-9    ¦                          Reserved                                                       ¦  n  |
+--------------------------------------------------------------------------------------------------+  t  |
¦ 10-11  ¦                          Reserved                                                       ¦  r  |
+--------------------------------------------------------------------------------------------------+  o  |
¦ 12-13  ¦                          Reserved                                                       ¦  l  |
+--------------------------------------------------------------------------------------------------+     |
¦ 14-15  ¦                          Reserved                                                       ¦     |
+--------------------------------------------------------------------------------------------------+  ---
¦ 16     ¦ Rsvd    ¦ Rsvd   ¦ Rsvd     ¦ Rsvd      ¦ Set    ¦ Clear       ¦ Inspection  ¦ Trigger  ¦     |
¦        ¦         ¦        ¦          ¦           ¦ User   ¦ Exposure    ¦ Results     ¦ Camera 0 ¦  E  |
¦        ¦         ¦        ¦          ¦           ¦ Data 0 ¦ Complete 0  ¦ Ack 0       ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  g  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  i  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  e  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  0  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
+--------------------------------------------------------------------------------------------------+  ---
¦ 17     ¦ Rsvd    ¦ Rsvd   ¦ Rsvd     ¦ Rsvd      ¦ Set    ¦ Clear       ¦ Inspection  ¦ Trigger  ¦     |
¦        ¦         ¦        ¦          ¦           ¦ User   ¦ Exposure    ¦ Results     ¦ Camera 1 ¦  E  |
¦        ¦         ¦        ¦          ¦           ¦ Data 1 ¦ Complete 1  ¦ Ack 1       ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  g  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  i  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  e  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  l  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
+--------------------------------------------------------------------------------------------------+  ---
¦ 18     ¦ Rsvd    ¦ Rsvd   ¦ Rsvd     ¦ Rsvd      ¦ Set    ¦ Clear       ¦ Inspection  ¦ Trigger  ¦     |
¦        ¦         ¦        ¦          ¦           ¦ User   ¦ Exposure    ¦ Results     ¦ Camera 2 ¦  E  |
¦        ¦         ¦        ¦          ¦           ¦ Data 2 ¦ Complete 2  ¦ Ack 2       ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  g  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  i  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  e  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  2  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
+--------------------------------------------------------------------------------------------------+  ---
¦ 19     ¦ Rsvd    ¦ Rsvd   ¦ Rsvd     ¦ Rsvd      ¦ Set    ¦ Clear       ¦ Inspection  ¦ Trigger  ¦     |
¦        ¦         ¦        ¦          ¦           ¦ User   ¦ Exposure    ¦ Results     ¦ Camera 3 ¦  E  |
¦        ¦         ¦        ¦          ¦           ¦ Data 3 ¦ Complete 3  ¦ Ack 3       ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  g  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  i  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  e  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  3  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
+--------------------------------------------------------------------------------------------------+  ---
¦ 20-??? ¦                          User Data                                                      ¦     |
¦        ¦                                                                                         ¦  U  |
¦        ¦                                                                                         ¦  s  |
¦        ¦                                                                                         ¦  e  |
¦        ¦                                                                                         ¦  r  |
¦        ¦                                                                                         ¦     |
¦        ¦                                                                                         ¦  D  |
¦        ¦                                                                                         ¦  a  |
¦        ¦                                                                                         ¦  t  |
¦        ¦                                                                                         ¦  a  |
¦        ¦                                                                                         ¦     |
+--------------------------------------------------------------------------------------------------+ ----
</code>
            </remarks>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.ClearNdmEvents">
            <summary>
Clears all the Ffp transition based i/o events.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.AddNdmEvent(Cognex.VisionPro.Comm.CogPrioNdmSignalConstants,System.Int32,System.Int32,System.Boolean)">
            <summary>
Enable an Ndm transition to cause an i/o event.
</summary>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidOperationException">
Thrown signal is invalid.
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.GetTestProtocolBlockData(System.String,System.Int32,System.Int32)">
            <summary>
Cognex Internal Use Only
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.SetTestProtocolBlockData(System.String,System.Int32,System.Byte[],System.Int32)">
            <summary>
Cognex Internal Use Only
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.SetTestProtocolBlockState(System.String,Cognex.VisionPro.Comm.CogNdmConnectionStatusConstants,System.Int32)">
            <summary>
Cognex Internal Use Only
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.SetTestProtocolState(Cognex.VisionPro.Comm.CogNdmConnectionStatusConstants)">
            <summary>
Cognex Internal Use Only
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.GetProtocolConnectionStatus">
            <summary>
Gets the connection status for the specified protocol.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.ReadUserData(System.Int32,System.Int32)">
            <summary>
Reads user data sent from the remote device (PLC) to the vision system.
<para>
Values returned from this function will not reflect changes to the
user data present on the remote system until the remote system signals
the vision system that new user data is available by sendng a 
"Set User Data" signal.
</para></summary>
            <param name="offset">
The offset into the user data at which to read.
</param>
            <param name="size">
The number of bytes of user data to read.
</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if the offset is less than 0 or greater than 65535 [0xFFFF]. 
</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if the size is less than 0 or greater than 65535 [0xFFFF]. 
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidOperationException">
Thrown if offset + size is greater than max data size.
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.Stop">
            <summary>
Stop the Network Data Model (NDM). Closes all connections and prevents
further connections from being established.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.Start">
            <summary>
Start the Network Data Model (NDM). Calling Start() opens network sockets and
allows connections from a remote device (PLC). You must call Start() on a CogNdm instance
returned from 
<see cref="M:Cognex.VisionPro.Comm.CogFfpAccess.CreateNetworkDataModel" />
in order for the NDM to connect to a remote device (PLC).
</summary>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidOperationException">
Thrown if the NDM has already been started. 
You can only start the NDM once during the lifetime of an application.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidSlmpConfigException">
Thrown if the NDM contains invalid SLMP config settings.
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.NotifyAsyncSoftEventComplete(System.Int64,System.Int32)">
            <summary>
Notify the remote device (PLC) that an asynchronous soft event has completed.
</summary>
            <remarks>
                <para>
Soft Events provide a mechanism for sending general purpose binary signals from the remote device
to the vision system. The NDM provides 32 individual Soft Events signals which are uniquely 
identified by their indices (0-31). The remote device and the vision system can assign specific 
meanings to the each Soft Event signal based on what is useful to their application context.
</para>
                <para>
To use a Soft Event, the remote device asserts one of the "Soft Event [0-31]" signals high.
When the vision system sees this signal transition, the NDM raises the  
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEvent" /> event.
Your vision system code can optionally handle this .NET event and perform any processing
that might be necessary.
</para>
                <para>
Your event handler code should use the
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.SoftEventID" /> 
property of the event args to identify which of the 32 Soft Event signals was received.
</para>
                <para>
Additionally, your vision system event handler code should set the
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to signal to the remote device whether the vision system has
finished processing the Soft Event when the event handler returns, or if the soft event
processing will continue asynchronously after your event handler code returns.
</para>
                <para>
If you the set the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to
<see cref="T:Cognex.VisionPro.Comm.CogNdmSoftEventResponseCodeConstants">Finshed</see>,
the NDM will automatically notify the remote device by sending the appropriately indexed "Soft Event Ack"
signal.
</para>
                <para>
If you set the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to
<see cref="T:Cognex.VisionPro.Comm.CogNdmSoftEventResponseCodeConstants">NotFinshed</see>,
The NDM will wait until you call the CogNDM's
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyAsyncSoftEventComplete(System.Int64,System.Int32)" /> method before sending the
corresponding "Soft Event Ack" to the remote device.
</para>
                <para>
Note that if you are processing soft events asynchronously you must save the
<see cref="P:Cognex.VisionPro.Comm.CogNdmEventArgsBase.MessageID" /> from the
event args so that you can latter pass it to the NDM's
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyAsyncSoftEventComplete(System.Int64,System.Int32)" /> method to notify the
remote device that soft event processing is complete.      
</para>
                <para>
In both the synchronous and asynchronous cases the remote device should send/assert the "Soft Event" signal high.
Then wait to receive to receive the "Soft Event Ack" signal while the vision system is processing the soft event.
Once the remote device sees the "Soft Event Ack" signal go high, it can then set the original "Soft Event"
signal low.
</para>
                <para>
When the remote device sets a "Soft Event" signal low the vision system is signaled via the 
NDM's <see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEventOff" /> event.
Your vision system code can optionally handle this event.
After any user event handler code returns, the NDM automatically notifies the
remote device by setting the "Soft Event Ack" signal low.
Once the remote device sees the "Soft Event Ack" signal go low, it knows that it is now
safe to signal another instance of the same soft event.
</para>
                <para>
Note that the NDM's soft event signals are supported by the Comm Card's precision i/o event system.
You can configure the NDM soft events signals to automatically cause a
<see cref="T:Cognex.VisionPro.Comm.CogPrioEvent" />
directly on the Comm Card's real time processor without involving the host OS.
This is primarily useful if you need to deterministically set or pulse a discrete output line based on a soft
event signal from the remote device.
</para>
            </remarks>
            <param name="messageID">
The ID of the message that initiates the soft event that is
being asynchronously completed.
</param>
            <param name="softEventNumber">
The number of the soft event being completed.
</param>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidOperationException">
Thrown if there is no outstanding asynchronous soft event with the given messageID
that can be completed.
</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if the softEventNumber is less than 0 or greater than 31.
</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if the messageID is less than 0 or greater than UInt32.MaxValue.
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.NotifyStopped(Cognex.VisionPro.Comm.CogNdmStoppedCodeConstants)">
            <summary>
Notify the remote device (PLC) that the Vision System stopped running or gone "offline".
</summary>
            <param name="stoppedCode">
                <para>
The stoppedCode contains user defined information about why the 
vision system stopped running or went "offline".
</para>
                <para>
The NDM supports 3 bits of stopped code information. These bits are 
reflected in the remote devices "Offline Reason" signal.
</para>
            </param>
            <remarks>
                <para>
Vision Systems often have an "online" and "offline" state.
The exact meaning of what it means to be online and offline may differ depending
on the particular vision system and application.
</para>
                <para>
The NDM allows the vision system to communicate and synchronize its online/offline state
with the remote device using the <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyRunning" />
and <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyStopped(Cognex.VisionPro.Comm.CogNdmStoppedCodeConstants)" /> methods.
</para>
                <para>
The vision system calls <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyRunning" /> to 
notify the remote device that the vision system is running or online.
</para>
                <para>
The vision system calls <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyStopped(Cognex.VisionPro.Comm.CogNdmStoppedCodeConstants)" /> to
notify the remote device that the vision system has stopped or gone offline.    
</para>
                <para>
The vision system's current online/offline state is reflected in the high or low
state of remote device's "Online" signal.
</para>
                <para>
The remote device may also signal the running vision system to go offline.   
The remote device does this by asserting its "Set Offline" signal high.
When the remote device raises the "Set Offline" signal high, the vision system receives 
the NDM <see cref="E:Cognex.VisionPro.Comm.CogNdm.OfflineRequested" /> event.
</para>
                <para>
The remote device may also signal the stopped vision system to return to its previous state.
The remote device does this by setting its "Set Offline" signal low.
When the remote device lowers the "Set Offline" signal, the vision system receives
the NDM <see cref="E:Cognex.VisionPro.Comm.CogNdm.OfflineRequested" /> event.
</para>
                <para>
Your vision system code should handle the NDM <see cref="E:Cognex.VisionPro.Comm.CogNdm.OfflineRequested" /> event.
When your code receives this event you should examine the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmOfflineRequestedEventArgs.ReturnToPreviousState" />
property of the event args to determine whether the remote device has signaled the vision system 
to go offline, or to return to the previous state.
</para>
                <para>
Once the code in your event handler has made the necessary transition,
be sure to call <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyStopped(Cognex.VisionPro.Comm.CogNdmStoppedCodeConstants)" />, or
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyRunning" /> to notify the
remote device of the new state of the vision system.
</para>
            </remarks>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidOperationException">
Thrown if the requested operation is invalid in the current state.
</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if the stoppedCode is less than 0 or greater than 7 (3 bits only).
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.NotifyRunning">
            <summary>
Notify the remote device (PLC) that the Vision System is running or "online".
</summary>
            <remarks>
                <para>
Vision Systems often have an "online" and "offline" state.
The exact meaning of what it means to be online and offline may differ depending
on the particular vision system and application.
</para>
                <para>
The NDM allows the vision system to communicate and synchronize its online/offline state
with the remote device using the <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyRunning" />
and <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyStopped(Cognex.VisionPro.Comm.CogNdmStoppedCodeConstants)" /> methods.
</para>
                <para>
The vision system calls <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyRunning" /> to 
notify the remote device that the vision system is running or online.
</para>
                <para>
The vision system calls <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyStopped(Cognex.VisionPro.Comm.CogNdmStoppedCodeConstants)" /> to
notify the remote device that the vision system has stopped or gone offline.    
</para>
                <para>
The vision system's current online/offline state is reflected in the high or low
state of remote device's "Online" signal.
</para>
                <para>
The remote device may also signal the running vision system to go offline.   
The remote device does this by asserting its "Set Offline" signal high.
When the remote device raises the "Set Offline" signal high, the vision system receives 
the NDM <see cref="E:Cognex.VisionPro.Comm.CogNdm.OfflineRequested" /> event.
</para>
                <para>
The remote device may also signal the stopped vision system to return to its previous state.
The remote device does this by setting its "Set Offline" signal low.
When the remote device lowers the "Set Offline" signal, the vision system receives
the NDM <see cref="E:Cognex.VisionPro.Comm.CogNdm.OfflineRequested" /> event.
</para>
                <para>
Your vision system code should handle the NDM <see cref="E:Cognex.VisionPro.Comm.CogNdm.OfflineRequested" /> event.
When your code receives this event you should examine the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmOfflineRequestedEventArgs.ReturnToPreviousState" />
property of the event args to determine whether the remote device has signaled the vision system 
to go offline, or to return to the previous state.
</para>
                <para>
Once the code in your event handler has made the necessary transition,
be sure to call <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyStopped(Cognex.VisionPro.Comm.CogNdmStoppedCodeConstants)" />, or
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyRunning" /> to notify the
remote device of the new state of the vision system.
</para>
            </remarks>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidOperationException">
Thrown if the requested operation is invalid in the current state.
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.NotifySystemStatus(System.Boolean,System.Boolean)">
            <summary>
Notifies the remote device (PLC) of the Vision System status.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.NotifyInspectionComplete(System.Int32,Cognex.VisionPro.Comm.CogNdmUsedAcquisitionIDCollection,System.Boolean,System.Int32,System.Byte[],System.Int32)">
            <summary>
Notify the remote device (PLC) that an inspection has finished.
</summary>
            <param name="inspectionIndex">
The index of the inspection channel/slot which completed and produced the result
</param>
            <param name="usedAcquisitionIDs">
A collection of the AcquisitionIDs that were used to create this inspection result
</param>
            <param name="inspectionPassed">
Whether the inspection passed or failed
</param>
            <param name="resultCode">
The result code of the inspection
</param>
            <param name="resultData">
The inspection result data
</param>
            <param name="resultDataOffset">
The offset at which the Result bytes for this inspection are written into the overall 
inspection results buffer
</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if 
<list type="bullet"><item>
usedAcquisitionIDs contains a camera index that is less than 0 or
greater than the number of supported camera acquisition
channels.
</item><item>
inspectionIndex is less than 0 or greater than the number of 
supported inspection channels channels.
</item></list></exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidOperationException">
Thrown if the size of resultData + resultDataOffset is outside the valid range for result data.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpQueueFullException">
Thrown if the remote device has enabled the "Buffer Results Enable" signal to enable results 
buffering and the buffer for the given inspection index/channel is full.
When this exception is thrown the "Results Buffer Overrun" signal will be sent to the 
remote device. Each inspection channel can buffer up to 16 results when results buffering 
is enabled.
</exception>
            <exception cref="T:System.ArgumentNullException">
Thrown if usedAcquisitionIDs is null.
</exception>
            <exception cref="T:System.ArgumentException">
Thrown if usedAcquisitionIDs is an empty collection.
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.NotifyInspectionComplete(Cognex.VisionPro.Comm.CogNdmInspectionResult)">
            <summary>
Notify the remote device (PLC) that an inspection has finished.
</summary>
            <param name="result">
The result of the inspection.
</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if 
<list type="bullet"><item>
result contains a camera index that is less than 0 or
greater than the number of supported camera acquisition
channels
</item><item>
result contains an inspection index that is less than 0 or
greater than the number of supported inspection channels
channels
</item></list></exception>
            <exception cref="T:System.ArgumentNullException">
Thrown if result is null.
</exception>
            <exception cref="T:System.ArgumentNullException">
Thrown if UsedAcquisitionIDs is null.
</exception>
            <exception cref="T:System.ArgumentException">
Thrown if UsedAcquisitionIDs is an empty collection.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidOperationException">
Thrown if the size of Result.ResultData + Result.ResultDataOffset is outside the valid
range for result data.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpQueueFullException">
Thrown if the remote device has enabled the "Buffer Results Enable" signal to enable results 
buffering and the buffer for the given inspection index/channel is full.
When this exception is thrown the "Results Buffer Overrun" signal will be sent to the 
remote device. Each inspection channel can buffer up to 16 results when results buffering 
is enabled.
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.NotifyAcquisitionComplete(System.Int32,System.Int32)">
            <summary>
Notify the remote device (PLC) that an acquisition has completed. 
You must call this method to notify the PLC when an an acquisiton is 
complete. If you do not call this function the Trigger Ready bit 
will never get re-enabled an no more acquisitions can occur.
</summary>
            <param name="cameraIndex">
Camera index identifier at which the acquisition has completed.
</param>
            <param name="acquisitionID">
Unique identifier for this acquisition sequence.
</param>
            <remarks>
                <para>
Calling this method automatically re-asserts the coresponding 
Trigger Ready signal bit on the PLC.
</para>
                <para>
Calling this method also automatically sets the Exposure Complete
signal bit on the PLC (if it has not already been set by an 
earlier optional call to NotifyAcqusitionMovePart).
</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if camera index is less than 0 or greater than the number of 
supported camera acquisition channels.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidOperationException">
Thrown if the requested operation is invalid in the current state.
</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if the acquisition ID is less than 0 or greater than UInt16.MaxValue. 
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.NotifyAcquisitionError(System.Int32)">
            <summary>
Notify the remote device (PLC) that an acquisition error has occurred.
</summary>
            <param name="cameraIndex">
Camera index identifier at which the error occurred.
</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if camera index is less than 0 or greater than the number of 
supported camera acquisition channels.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidOperationException">
Thrown if the requested operation is invalid in the current state.
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.NotifyAcquisitionMovePart(System.Int32,System.Int32)">
            <summary>
Optionally notify the remote device (PLC) that the exposure is complete or the
strobe has fired and it is now safe to move the part from the 
field of view.
</summary>
            <param name="cameraIndex">
Camera index identifier at which the move part signal occurred.
</param>
            <param name="acquisitionID">
Unique identifier for this acquisition sequence.
</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if camera index is less than 0 or greater than the number of 
supported camera acquisition channels.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidOperationException">
Thrown if the requested operation is invalid in the current state.
</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if the acquisition ID is less than 0 or greater than UInt16.MaxValue. 
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.NotifyAcquisitionStarted(System.Int32,System.Int32)">
            <summary>
Optionally notify the remote device (PLC) that an acquisition has started.
</summary>
            <remarks>
This event will automatically disable the Trigger Ready bit for the specified camera.
</remarks>
            <param name="cameraIndex">
Camera index on which the acquisition has started
</param>
            <param name="acquisitionID">
Unique identifier for this acquisition sequence.
</param>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidOperationException">
Thrown if the previous acquisition for a given camera has not completed, 
i.e. user code has yet to make the corresponding call to 
NotifyAcquisitionComplete() or if the requested operation is otherwise invalid.
</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if camera index is less than 0 or greater than the number of 
supported camera acquisition channels.
</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if the acquisition ID is less than 0 or greater than UInt16.MaxValue. 
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.NotifyAcquisitionDisabled(System.Int32)">
            <summary>
Optionally notify the remote device (PLC) that the Vision System is unable to 
receive acquisition triggers.
</summary>
            <param name="cameraIndex">
Camera index on which is ready to receive triggers
</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if camera index is less than 0 or greater than the number of 
supported camera acquisition channels.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidOperationException">
Thrown if the requested operation is invalid in the current state.
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.NotifyAcquisitionReady(System.Int32)">
            <summary>
Notify the remote device (PLC) that the Vision System is ready to 
receive the first acquisition trigger.
</summary>
            <param name="cameraIndex">
Camera index which is ready to receive triggers.
</param>
            <remarks>
Note that calling NotifyAcquisitionComplete() automatically re-enables
triggers for a particular camera, so calling NotifyAcquisitionReady() 
is only required to enable the very first acquisition. After the first
acquisition you must call NotifyAcquisitionComplete() for the trigger
ready signal to be sent back to the remote device or PLC.
</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if camera index is less than 0 or greater than the number of 
supported camera acquisition channels.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidOperationException">
Thrown if the requested operation is invalid in the current state.
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.NotifyError(System.Int32)">
            <summary>
Notify the remote device (PLC) that the Vision System has encountered an error.
</summary>
            <param name="errorCode">
The code which identifies the error.
</param>
            <remarks>
                <para>
The NDM supports 16 bits of error code information.
</para>
Currently the NDM does _not_ define its own error codes. 
You must supply your own meaningful error codes as arguments to
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyError(System.Int32)" />.
Cognex recommends using the lower 12-bits (0x0001 to 0x0FFF) 
for your error codes.
</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if the errorCode is less than or equal to 0 or greater than 4095 (0xFFF).
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.NotifyJobState(System.Int32[])">
            <summary>
Notify the remote device (PLC) which job is loaded.
</summary>
            <param name="jobIDs">
The list of currently loaded job ids, sorted by job slot.
An empty job slot has a job id of -1.
The current software only supports a single job slot.
The current NDM layout requires valid jobIDs fit in the range of unsigned
16 bit integers [0,65535]. 
</param>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidOperationException">
Thrown if a jobID is not valid for the current NDM layout, the current NDM
layout requires jobIDs fit in the range of unsigned 16 bit integers [0,65535]. 
</exception>
            <exception cref="T:System.NotImplementedException">
Thrown if jobIDs contains more than a single element.
</exception>
            <exception cref="T:System.ArgumentNullException">
Thrown if jobIDs is null.
</exception>
            <exception cref="T:System.ArgumentException">
Thrown if jobIDs is empty.
</exception>
        </member>
        <member name="E:Cognex.VisionPro.Comm.CogNdm.TriggerAcquisitionNotReadyError">
            <summary>
The NDM raises the TriggerAcquisitionNotReadyError event when the remote device asserts
a "Trigger Camera" signal high without waiting for the vision system to signal that 
it's ready to receive triggers by setting the "Trigger Ready" signal high.
<para>
Handle this event and use the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionNotReadyErrorEventArgs.CameraIndex" />
to identify which camera channel was triggered before it was ready.
</para><para>
Your user code should call 
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyAcquisitionComplete(System.Int32,System.Int32)" /> to signal that
the vision system that it has completed the current acquisition and is ready to receive
another "Trigger Camera" signal from the remote device.
</para></summary>
        </member>
        <member name="E:Cognex.VisionPro.Comm.CogNdm.TriggerAcquisitionDisabledError">
            <summary>
The NDM raises the TriggerAcquisitionDisabledError event to tell the vision system
that an acquisition trigger was set but the acquisition trigger was not enabled.
</summary>
        </member>
        <member name="E:Cognex.VisionPro.Comm.CogNdm.OfflineRequested">
            <summary>
The NDM raises the OfflineRequested event to tell the vision system
that it should go offline.
<para>
Handle this event and use the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmOfflineRequestedEventArgs.ReturnToPreviousState" />  
property of the event args to determine whether to transition the vision system offline
or return it to its previous state.
</para></summary>
            <remarks>
                <para>
Vision Systems often have an "online" and "offline" state.
The exact meaning of what it means to be online and offline may differ depending
on the particular vision system and application.
</para>
                <para>
The NDM allows the vision system to communicate and synchronize its online/offline state
with the remote device using the <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyRunning" />
and <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyStopped(Cognex.VisionPro.Comm.CogNdmStoppedCodeConstants)" /> methods.
</para>
                <para>
The vision system calls <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyRunning" /> to 
notify the remote device that the vision system is running or online.
</para>
                <para>
The vision system calls <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyStopped(Cognex.VisionPro.Comm.CogNdmStoppedCodeConstants)" /> to
notify the remote device that the vision system has stopped or gone offline.    
</para>
                <para>
The vision system's current online/offline state is reflected in the high or low
state of remote device's "Online" signal.
</para>
                <para>
The remote device may also signal the running vision system to go offline.   
The remote device does this by asserting its "Set Offline" signal high.
When the remote device raises the "Set Offline" signal high, the vision system receives 
the NDM <see cref="E:Cognex.VisionPro.Comm.CogNdm.OfflineRequested" /> event.
</para>
                <para>
The remote device may also signal the stopped vision system to return to its previous state.
The remote device does this by setting its "Set Offline" signal low.
When the remote device lowers the "Set Offline" signal, the vision system receives
the NDM <see cref="E:Cognex.VisionPro.Comm.CogNdm.OfflineRequested" /> event.
</para>
                <para>
Your vision system code should handle the NDM <see cref="E:Cognex.VisionPro.Comm.CogNdm.OfflineRequested" /> event.
When your code receives this event you should examine the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmOfflineRequestedEventArgs.ReturnToPreviousState" />
property of the event args to determine whether the remote device has signaled the vision system 
to go offline, or to return to the previous state.
</para>
                <para>
Once the code in your event handler has made the necessary transition,
be sure to call <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyStopped(Cognex.VisionPro.Comm.CogNdmStoppedCodeConstants)" />, or
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyRunning" /> to notify the
remote device of the new state of the vision system.
</para>
            </remarks>
        </member>
        <member name="E:Cognex.VisionPro.Comm.CogNdm.JobChangeRequested">
            <summary>
The NDM raises the JobChangeRequested event to inform the vision system 
that the remote device has requested a job change.
<para>
Handle this event and use the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmJobChangeRequestedEventArgs.JobID" /> and 
<see cref="P:Cognex.VisionPro.Comm.CogNdmJobChangeRequestedEventArgs.JobSlot" />
properties of the event args to determine which job to load and where.
</para></summary>
        </member>
        <member name="E:Cognex.VisionPro.Comm.CogNdm.ProtocolStatusChanged">
            <summary>
The NDM raises the ProtocolStatusChanged event to inform the vision system 
that the status of the underlying protocol has changed.
<para>
Handle this event and use the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmProtocolStatusChangedEventArgs.RemoteAddress" /> and 
<see cref="P:Cognex.VisionPro.Comm.CogNdmProtocolStatusChangedEventArgs.ProtocolStatus" />
properties of the event args to determine how the protocol status has changed.
</para></summary>
        </member>
        <member name="E:Cognex.VisionPro.Comm.CogNdm.ClearError">
            <summary>
The NDM raises the ClearError event to inform the vision system 
that the remote device has been notified of an error reported by the 
vision system and the error has been be cleared.
<para>
Handle this event to know when the remote device has acknowledged
an error and normal operation can continue.
</para></summary>
        </member>
        <member name="E:Cognex.VisionPro.Comm.CogNdm.NewUserData">
            <summary>
The NDM raises the NewUserData event to tell the vision system
that new user data has arrived from the remote device.
<para>
Handle this event and call 
<see cref="M:Cognex.VisionPro.Comm.CogNdm.ReadUserData(System.Int32,System.Int32)" /> to read the 
new user data.
</para><para>
Note that changes to the user data present on the remote device cannot be read
until the remote device signals the vision system that new user data is available 
by sending a "Set User Data" signal.
</para><para>
The remote device can send separate "Set User Data" signals for each user data channel.
Use the <see cref="P:Cognex.VisionPro.Comm.CogNdmNewUserDataEventArgs.ChannelIndex" />
property of the event args to determine which "Set User Data" signal was received.
</para><para>
Upon returning from the event handler, the remote device is
automatically notified by sending the “Set User Data Ack” signal.
</para></summary>
        </member>
        <member name="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEventOff">
            <summary>
The NDM raises the TriggerSoftEventOff event to tell the vision system
that the soft event trigger bit has been reset.
<para>
Handle this event and use the  
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventOffEventArgs.SoftEventID" />
property of the event args to determine which soft event has been reset.
</para></summary>
            <remarks>
                <para>
Soft Events provide a mechanism for sending general purpose binary signals from the remote device
to the vision system. The NDM provides 32 individual Soft Events signals which are uniquely 
identified by their indices (0-31). The remote device and the vision system can assign specific 
meanings to the each Soft Event signal based on what is useful to their application context.
</para>
                <para>
To use a Soft Event, the remote device asserts one of the "Soft Event [0-31]" signals high.
When the vision system sees this signal transition, the NDM raises the  
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEvent" /> event.
Your vision system code can optionally handle this .NET event and perform any processing
that might be necessary.
</para>
                <para>
Your event handler code should use the
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.SoftEventID" /> 
property of the event args to identify which of the 32 Soft Event signals was received.
</para>
                <para>
Additionally, your vision system event handler code should set the
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to signal to the remote device whether the vision system has
finished processing the Soft Event when the event handler returns, or if the soft event
processing will continue asynchronously after your event handler code returns.
</para>
                <para>
If you the set the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to
<see cref="T:Cognex.VisionPro.Comm.CogNdmSoftEventResponseCodeConstants">Finshed</see>,
the NDM will automatically notify the remote device by sending the appropriately indexed "Soft Event Ack"
signal.
</para>
                <para>
If you set the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to
<see cref="T:Cognex.VisionPro.Comm.CogNdmSoftEventResponseCodeConstants">NotFinshed</see>,
The NDM will wait until you call the CogNDM's
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyAsyncSoftEventComplete(System.Int64,System.Int32)" /> method before sending the
corresponding "Soft Event Ack" to the remote device.
</para>
                <para>
Note that if you are processing soft events asynchronously you must save the
<see cref="P:Cognex.VisionPro.Comm.CogNdmEventArgsBase.MessageID" /> from the
event args so that you can latter pass it to the NDM's
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyAsyncSoftEventComplete(System.Int64,System.Int32)" /> method to notify the
remote device that soft event processing is complete.      
</para>
                <para>
In both the synchronous and asynchronous cases the remote device should send/assert the "Soft Event" signal high.
Then wait to receive to receive the "Soft Event Ack" signal while the vision system is processing the soft event.
Once the remote device sees the "Soft Event Ack" signal go high, it can then set the original "Soft Event"
signal low.
</para>
                <para>
When the remote device sets a "Soft Event" signal low the vision system is signaled via the 
NDM's <see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEventOff" /> event.
Your vision system code can optionally handle this event.
After any user event handler code returns, the NDM automatically notifies the
remote device by setting the "Soft Event Ack" signal low.
Once the remote device sees the "Soft Event Ack" signal go low, it knows that it is now
safe to signal another instance of the same soft event.
</para>
                <para>
Note that the NDM's soft event signals are supported by the Comm Card's precision i/o event system.
You can configure the NDM soft events signals to automatically cause a
<see cref="T:Cognex.VisionPro.Comm.CogPrioEvent" />
directly on the Comm Card's real time processor without involving the host OS.
This is primarily useful if you need to deterministically set or pulse a discrete output line based on a soft
event signal from the remote device.
</para>
            </remarks>
        </member>
        <member name="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEvent">
            <summary>
The NDM raises the TriggerSoftEvent event to inform the vision system
that the remote device has requested that a soft event execute.
<para>
Handle this event and use the  
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.SoftEventID" />
property of the event args to determine which soft event should execute.
</para><para>
Set the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to notify the remote device of the status of the soft event
when the event handler returns.
</para></summary>
            <remarks>
                <para>
Soft Events provide a mechanism for sending general purpose binary signals from the remote device
to the vision system. The NDM provides 32 individual Soft Events signals which are uniquely 
identified by their indices (0-31). The remote device and the vision system can assign specific 
meanings to the each Soft Event signal based on what is useful to their application context.
</para>
                <para>
To use a Soft Event, the remote device asserts one of the "Soft Event [0-31]" signals high.
When the vision system sees this signal transition, the NDM raises the  
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEvent" /> event.
Your vision system code can optionally handle this .NET event and perform any processing
that might be necessary.
</para>
                <para>
Your event handler code should use the
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.SoftEventID" /> 
property of the event args to identify which of the 32 Soft Event signals was received.
</para>
                <para>
Additionally, your vision system event handler code should set the
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to signal to the remote device whether the vision system has
finished processing the Soft Event when the event handler returns, or if the soft event
processing will continue asynchronously after your event handler code returns.
</para>
                <para>
If you the set the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to
<see cref="T:Cognex.VisionPro.Comm.CogNdmSoftEventResponseCodeConstants">Finshed</see>,
the NDM will automatically notify the remote device by sending the appropriately indexed "Soft Event Ack"
signal.
</para>
                <para>
If you set the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to
<see cref="T:Cognex.VisionPro.Comm.CogNdmSoftEventResponseCodeConstants">NotFinshed</see>,
The NDM will wait until you call the CogNDM's
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyAsyncSoftEventComplete(System.Int64,System.Int32)" /> method before sending the
corresponding "Soft Event Ack" to the remote device.
</para>
                <para>
Note that if you are processing soft events asynchronously you must save the
<see cref="P:Cognex.VisionPro.Comm.CogNdmEventArgsBase.MessageID" /> from the
event args so that you can latter pass it to the NDM's
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyAsyncSoftEventComplete(System.Int64,System.Int32)" /> method to notify the
remote device that soft event processing is complete.      
</para>
                <para>
In both the synchronous and asynchronous cases the remote device should send/assert the "Soft Event" signal high.
Then wait to receive to receive the "Soft Event Ack" signal while the vision system is processing the soft event.
Once the remote device sees the "Soft Event Ack" signal go high, it can then set the original "Soft Event"
signal low.
</para>
                <para>
When the remote device sets a "Soft Event" signal low the vision system is signaled via the 
NDM's <see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEventOff" /> event.
Your vision system code can optionally handle this event.
After any user event handler code returns, the NDM automatically notifies the
remote device by setting the "Soft Event Ack" signal low.
Once the remote device sees the "Soft Event Ack" signal go low, it knows that it is now
safe to signal another instance of the same soft event.
</para>
                <para>
Note that the NDM's soft event signals are supported by the Comm Card's precision i/o event system.
You can configure the NDM soft events signals to automatically cause a
<see cref="T:Cognex.VisionPro.Comm.CogPrioEvent" />
directly on the Comm Card's real time processor without involving the host OS.
This is primarily useful if you need to deterministically set or pulse a discrete output line based on a soft
event signal from the remote device.
</para>
            </remarks>
        </member>
        <member name="E:Cognex.VisionPro.Comm.CogNdm.TriggerAcquisitionStop">
            <summary>
The NDM raises the TriggerAcquisitionStop event to tell the vision system
that the Acquisition trigger has been reset.
<para>
Handle this event and use the  
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionStopEventArgs.CameraIndex" />
property of the event args to determine which camera trigger was reset.
</para></summary>
        </member>
        <member name="E:Cognex.VisionPro.Comm.CogNdm.TriggerAcquisition">
            <summary>
The NDM raises the TriggerAcquisition event to inform the vision system that the
remote device has requested an image Acquisition.
<para>
Handle this event and use the  
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionEventArgs.CameraIndex" />
property of the event args to determine which camera should perform the image acquisition.
</para><para>
Set the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionEventArgs.ResponseCode" />
property of the event args to notify the remote device if an acquisition error has occurred.
</para></summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdm.fCallbackBase(System.Void*,csFfpCallbackInfo_*)">
            <summary>
This is the function that is actually called from the unmanaged callback.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdm">
            <summary>
The Network Data Model (NDM) class supports sending and receiving
messages between the vision system and a remote device
(usually a PLC) over an Ethernet based Factory Floor Protocol (FFP).
<para>
The Network Data Model (NDM) is the way Cognex Vision Systems
interact with a PLC.
</para><para>
Note: The instance number for the Rockwell Input Assembly is 11 and for the Output Assembly is 21.
</para></summary>
            <remarks>
                <code>
NDM Status Signal Table (Status signals are signals sent from the Vision System to the PLC)
+----------------------------------------------------------------------------------------------------------+
¦        ¦ Bit 7     ¦ Bit 6       ¦ Bit 5     ¦ Bit 4       ¦ Bit 3      ¦ Bit 2   ¦ Bit 1    ¦ Bit 0     ¦
+----------------------------------------------------------------------------------------------------------+  ---
¦ 0      ¦ Online    ¦               Offline                 ¦ Rsvd       ¦ Rsvd    ¦ System   ¦ System    ¦     |
¦        ¦           ¦               Reason                  ¦            ¦         ¦ Busy     ¦ Ready     ¦  S  |
+----------------------------------------------------------------------------------------------------------+  y  |
¦ 1      ¦ General   ¦ Rsvd        ¦ Job Load  ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Rsvd      ¦  s  |
¦        ¦ Fault     ¦             ¦ Completed ¦             ¦            ¦         ¦          ¦           ¦  t  |
+----------------------------------------------------------------------------------------------------------+  e  |
¦ 2      ¦                                  Reserved                                                       ¦  m  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 3      ¦                                  Reserved                                                       ¦  S  |
+----------------------------------------------------------------------------------------------------------+  t  |
¦ 4-5    ¦                                  Current Job ID                                                 ¦  a  |
+----------------------------------------------------------------------------------------------------------+  t  |
¦ 6-7    ¦                                  Error ID                                                       ¦  u  |
+----------------------------------------------------------------------------------------------------------+  s  |
¦ 8-11   ¦                                  Soft Event Ack 0-31                                            ¦     |
+----------------------------------------------------------------------------------------------------------+     |
¦ 12-15  ¦                                  Reserved                                                       ¦     |
+----------------------------------------------------------------------------------------------------------+  ---
¦ 16     ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦     |
¦        ¦ Buffer    ¦ Passed 0    ¦ Valid 0   ¦ Completed 0 ¦ Complete 0 ¦ Error 0 ¦ Ack      ¦ Ready     ¦  E  |
¦        ¦ Overrun 0 ¦             ¦           ¦             ¦            ¦         ¦ Camera 0 ¦ Camera 0  ¦  n  |
+----------------------------------------------------------------------------------------------------------+  g  |
¦ 17     ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦  i  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦  n  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 0     ¦  e  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 18-19  ¦                                  Acquisition ID 0                                               ¦  0  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 20-21  ¦                                  Inspected Image ID 0                                           ¦     |
+----------------------------------------------------------------------------------------------------------+     |
¦ 22-23  ¦                                  Inspection Result Code 0                                       ¦     |
+----------------------------------------------------------------------------------------------------------+  ---
¦ 24     ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦     |
¦        ¦ Buffer    ¦ Passed 1    ¦ Valid 1   ¦ Completed 1 ¦ Complete 1 ¦ Error 1 ¦ Ack      ¦ Ready     ¦  E  |
¦        ¦ Overrun 1 ¦             ¦           ¦             ¦            ¦         ¦ Camera 1 ¦ Camera 1  ¦  n  |
+----------------------------------------------------------------------------------------------------------+  g  |
¦ 25     ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦  i  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦  n  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 1     ¦  e  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 26-27  ¦                                  Acquisition ID 1                                               ¦  1  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 28-29  ¦                                  Inspected Image ID 1                                           ¦     |
+----------------------------------------------------------------------------------------------------------+     |
¦ 30-31  ¦                                  Inspection Result Code 1                                       ¦     |
+----------------------------------------------------------------------------------------------------------+  ---
¦ 32     ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦     |
¦        ¦ Buffer    ¦ Passed 2    ¦ Valid 2   ¦ Completed 2 ¦ Complete 2 ¦ Error 2 ¦ Ack      ¦ Ready     ¦  E  |
¦        ¦ Overrun 2 ¦             ¦           ¦             ¦            ¦         ¦ Camera 2 ¦ Camera 2  ¦  n  |
+----------------------------------------------------------------------------------------------------------+  g  |
¦ 33     ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦  i  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦  n  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 2     ¦  e  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 34-35  ¦                                  Acquisition ID 2                                               ¦  2  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 36-37  ¦                                  Inspected Image ID 2                                           ¦     |
+----------------------------------------------------------------------------------------------------------+     |
¦ 38-39  ¦                                  Inspection Result Code 2                                       ¦     |
+----------------------------------------------------------------------------------------------------------+  ---
¦ 40     ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦     |
¦        ¦ Buffer    ¦ Passed 3    ¦ Valid 3   ¦ Completed 3 ¦ Complete 3 ¦ Error 3 ¦ Ack      ¦ Ready     ¦  E  |
¦        ¦ Overrun 3 ¦             ¦           ¦             ¦            ¦         ¦ Camera 3 ¦ Camera 3  ¦  n  |
+----------------------------------------------------------------------------------------------------------+  g  |
¦ 41     ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦  i  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦  n  |
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 3     ¦  e  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 42-43  ¦                                  Acquisition ID 3                                               ¦  3  |
+----------------------------------------------------------------------------------------------------------+     |
¦ 44-45  ¦                                  Inspected Image ID 3                                           ¦     |
+----------------------------------------------------------------------------------------------------------+     |
¦ 46-47  ¦                                  Inspection Result Code 3                                       ¦     |
+----------------------------------------------------------------------------------------------------------+  ---
¦ 48-??? ¦                                  Inspection Results                                             ¦     |
¦        ¦                                                                                                 ¦  R  |
¦        ¦                                                                                                 ¦  e  |
¦        ¦                                                                                                 ¦  s  |
¦        ¦                                                                                                 ¦  u  |
¦        ¦                                                                                                 ¦  l  |
¦        ¦                                                                                                 ¦  t  |
¦        ¦                                                                                                 ¦  s  |
¦        ¦                                                                                                 ¦     |
+----------------------------------------------------------------------------------------------------------+ ----
</code>
                <code>
NDM Control Signal Table (Controls signals are signals sent from the PLC to the Vision System)
+--------------------------------------------------------------------------------------------------+
¦        ¦ Bit 7   ¦ Bit 6  ¦ Bit 5    ¦ Bit 4     ¦ Bit 3  ¦ Bit 2       ¦ Bit 1       ¦ Bit 0    ¦
+--------------------------------------------------------------------------------------------------+  ---
¦ 0      ¦ Set     ¦ Clear  ¦ Reserved ¦ Initiate  ¦  Rsvd  ¦ Rsvd        ¦ Buffer      ¦ Trigger  ¦     |
¦        ¦ Offline ¦ Error  ¦          ¦ Job       ¦        ¦             ¦ Results     ¦ Enable   ¦  S  |
¦        ¦         ¦        ¦          ¦ Load      ¦        ¦             ¦ Enable      ¦          ¦  y  |
+--------------------------------------------------------------------------------------------------+  s  |
¦ 1      ¦                          Reserved                                                       ¦  t  |
+--------------------------------------------------------------------------------------------------+  e  |
¦ 2-3    ¦                          Job Load ID                                                    ¦  m  |
+--------------------------------------------------------------------------------------------------+     |
¦ 4-7    ¦                          SoftEvent 0-31                                                 ¦  C  |
+--------------------------------------------------------------------------------------------------+  o  |
¦ 8-9    ¦                          Reserved                                                       ¦  n  |
+--------------------------------------------------------------------------------------------------+  t  |
¦ 10-11  ¦                          Reserved                                                       ¦  r  |
+--------------------------------------------------------------------------------------------------+  o  |
¦ 12-13  ¦                          Reserved                                                       ¦  l  |
+--------------------------------------------------------------------------------------------------+     |
¦ 14-15  ¦                          Reserved                                                       ¦     |
+--------------------------------------------------------------------------------------------------+  ---
¦ 16     ¦ Rsvd    ¦ Rsvd   ¦ Rsvd     ¦ Rsvd      ¦ Set    ¦ Clear       ¦ Inspection  ¦ Trigger  ¦     |
¦        ¦         ¦        ¦          ¦           ¦ User   ¦ Exposure    ¦ Results     ¦ Camera 0 ¦  E  |
¦        ¦         ¦        ¦          ¦           ¦ Data 0 ¦ Complete 0  ¦ Ack 0       ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  g  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  i  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  e  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  0  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
+--------------------------------------------------------------------------------------------------+  ---
¦ 17     ¦ Rsvd    ¦ Rsvd   ¦ Rsvd     ¦ Rsvd      ¦ Set    ¦ Clear       ¦ Inspection  ¦ Trigger  ¦     |
¦        ¦         ¦        ¦          ¦           ¦ User   ¦ Exposure    ¦ Results     ¦ Camera 1 ¦  E  |
¦        ¦         ¦        ¦          ¦           ¦ Data 1 ¦ Complete 1  ¦ Ack 1       ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  g  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  i  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  e  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  l  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
+--------------------------------------------------------------------------------------------------+  ---
¦ 18     ¦ Rsvd    ¦ Rsvd   ¦ Rsvd     ¦ Rsvd      ¦ Set    ¦ Clear       ¦ Inspection  ¦ Trigger  ¦     |
¦        ¦         ¦        ¦          ¦           ¦ User   ¦ Exposure    ¦ Results     ¦ Camera 2 ¦  E  |
¦        ¦         ¦        ¦          ¦           ¦ Data 2 ¦ Complete 2  ¦ Ack 2       ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  g  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  i  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  e  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  2  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
+--------------------------------------------------------------------------------------------------+  ---
¦ 19     ¦ Rsvd    ¦ Rsvd   ¦ Rsvd     ¦ Rsvd      ¦ Set    ¦ Clear       ¦ Inspection  ¦ Trigger  ¦     |
¦        ¦         ¦        ¦          ¦           ¦ User   ¦ Exposure    ¦ Results     ¦ Camera 3 ¦  E  |
¦        ¦         ¦        ¦          ¦           ¦ Data 3 ¦ Complete 3  ¦ Ack 3       ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  g  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  i  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  n  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  e  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦  3  |
¦        ¦         ¦        ¦          ¦           ¦        ¦             ¦             ¦          ¦     |
+--------------------------------------------------------------------------------------------------+  ---
¦ 20-??? ¦                          User Data                                                      ¦     |
¦        ¦                                                                                         ¦  U  |
¦        ¦                                                                                         ¦  s  |
¦        ¦                                                                                         ¦  e  |
¦        ¦                                                                                         ¦  r  |
¦        ¦                                                                                         ¦     |
¦        ¦                                                                                         ¦  D  |
¦        ¦                                                                                         ¦  a  |
¦        ¦                                                                                         ¦  t  |
¦        ¦                                                                                         ¦  a  |
¦        ¦                                                                                         ¦     |
+--------------------------------------------------------------------------------------------------+ ----
</code>
            </remarks>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmSlmpConfig.NdmSignalBlockMapping">
            <summary>
Gets/sets a collection of CogNdmSlmpBlockMapping which maps blocks
of the NDM signal table into SLMP devices.
</summary>
            <value>
Default value is a likely default mapping collection:
<para>
{{ControlBit,   InternalRelay,   100, 80},
</para><para>
 {StatusBit,    InternalRelay,   180, 112},
</para><para>
 {StatusWord,   DataRegister,    100, 16*100},
</para><para>
 {ControlWord,  DataRegister,    200, 16*100}}  
</para></value>
            <remarks>
                <para>
The following table describes host the NDM signal table is layed
out into 4 seperate blocks specific to SLMP.
</para>
                <code>
The SLMP "ControlBit" signal table/block organizes the single bit NDM signals
sent from the PLC to Vision System. The ControlBit block is 80 bits long.
+----------------+---------+-------+----------+-----------+-----------+------------+-----------+---------+
|                | Bit 7   | Bit 6 | Bit 5    | Bit 4     | Bit 3     | Bit 2      | Bit 1     | Bit 0   |
+----------------+---------+-------+----------+-----------+-----------+------------+-----------+---------+
| 0              | Set     | Clear | Rsvd     | Initiate  | Rsvd      | Rsvd       | Buffer    | Trigger |
|                | Offline | Error |          | Job       |           |            | Results   | Enable  |
|                |         |       |          | Load      |           |            | Enable    |         |
+--------------------------------------------------------------------------------------------------------+
| 1              |                              Rsvd                                                     |
+--------------------------------------------------------------------------------------------------------+
| 2-5            |                              SoftEvent 0-31                                           |
+--------------------------------------------------------------------------------------------------------+
| 6              | Rsvd    | Rsvd  | Rsvd     | Rsvd      | Set User | Clear      | Inspection | Trigger |
|                |         |       |          |           | Data 0   | Exposure   | Results    | Camera  |
|                |         |       |          |           |          | Complete 0 | Ack 0      | 0       |
+--------------------------------------------------------------------------------------------------------+
| 7              | Rsvd    | Rsvd  | Rsvd     | Rsvd      | Set User | Clear      | Inspection | Trigger |
|                |         |       |          |           | Data 1   | Exposure   | Results    | Camera  |
|                |         |       |          |           |          | Complete 1 | Ack 1      | 1       |
+--------------------------------------------------------------------------------------------------------+
| 8              | Rsvd    | Rsvd  | Rsvd     | Rsvd      | Set User | Clear      | Inspection | Trigger |
|                |         |       |          |           | Data 2   | Exposure   | Results    | Camera  |
|                |         |       |          |           |          | Complete 2 | Ack 2      | 2       |
+--------------------------------------------------------------------------------------------------------+
| 9              | Rsvd    | Rsvd  | Rsvd     | Rsvd      | Set User | Clear      | Inspection | Trigger |
|                |         |       |          |           | Data 3   | Exposure   | Results    | Camera  |
|                |         |       |          |           |          | Complete 3 | Ack 3      | 3       |
+--------------------------------------------------------------------------------------------------------+

The SLMP "StatusBit" signal table/block organizes the single bit NDM signals
sent from the Vision System to the PLC.  The StatusBit block is 112 bits long.
+----------------------------------------------------------------------------------------------------------+
¦        ¦ Bit 7     ¦ Bit 6       ¦ Bit 5     ¦ Bit 4       ¦ Bit 3      ¦ Bit 2   ¦ Bit 1    ¦ Bit 0     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 0      ¦ Online    ¦               Offline                 ¦ Rsvd       ¦ Rsvd    ¦ System   ¦ System    ¦
¦        ¦           ¦               Reason                  ¦            ¦         ¦ Busy     ¦ Ready     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 1      ¦ General   ¦ Rsvd        ¦ Job Load  ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Rsvd      ¦
¦        ¦ Fault     ¦             ¦ Completed ¦             ¦            ¦         ¦          ¦           ¦
+----------------------------------------------------------------------------------------------------------+
¦ 2-5    ¦                                  Soft Event Ack 0-31                                            ¦
+----------------------------------------------------------------------------------------------------------+
¦ 6      ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦
¦        ¦ Buffer    ¦ Passed 0    ¦ Valid 0   ¦ Completed 0 ¦ Complete 0 ¦ Error 0 ¦ Ack      ¦ Ready     ¦
¦        ¦ Overrun 0 ¦             ¦           ¦             ¦            ¦         ¦ Camera 0 ¦ Camera 0  ¦
+----------------------------------------------------------------------------------------------------------+
¦ 7      ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 0     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 8      ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦
¦        ¦ Buffer    ¦ Passed 1    ¦ Valid 1   ¦ Completed 1 ¦ Complete 1 ¦ Error 1 ¦ Ack      ¦ Ready     ¦
¦        ¦ Overrun 1 ¦             ¦           ¦             ¦            ¦         ¦ Camera 1 ¦ Camera 1  ¦
+----------------------------------------------------------------------------------------------------------+
¦ 9      ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 1     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 10     ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦
¦        ¦ Buffer    ¦ Passed 2    ¦ Valid 2   ¦ Completed 2 ¦ Complete 2 ¦ Error 2 ¦ Ack      ¦ Ready     ¦
¦        ¦ Overrun 2 ¦             ¦           ¦             ¦            ¦         ¦ Camera 2 ¦ Camera 2  ¦
+----------------------------------------------------------------------------------------------------------+
¦ 11     ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 2     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 12     ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦
¦        ¦ Buffer    ¦ Passed 3    ¦ Valid 3   ¦ Completed 3 ¦ Complete 3 ¦ Error 3 ¦ Ack      ¦ Ready     ¦
¦        ¦ Overrun 3 ¦             ¦           ¦             ¦            ¦         ¦ Camera 3 ¦ Camera 3  ¦
+----------------------------------------------------------------------------------------------------------+
¦ 13     ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 3     ¦
+----------------------------------------------------------------------------------------------------------+

The SLMP "StatusWord" signal table/block organizes the word length signals sent from the Vision System to the PLC.
The size of the StatusWord block can vary depending on the size of the inspection results section.
+----------------------------------------------+
¦        ¦             16Bit Word              ¦
+----------------------------------------------+
¦ 0      ¦        Current Job ID               ¦
+----------------------------------------------+
¦ 1      ¦        Error ID                     ¦
+----------------------------------------------+
¦ 2      ¦        Acquisition ID 0             ¦
+----------------------------------------------+
¦ 3      ¦        Inspected Image ID 0         ¦
+----------------------------------------------+
¦ 4      ¦        Inspection Result Code 0     ¦
+----------------------------------------------+
¦ 5      ¦        Acquisition ID 1             ¦
+----------------------------------------------+
¦ 6      ¦        Inspected Image ID 1         ¦
+----------------------------------------------+
¦ 7      ¦        Inspection Result Code 1     ¦
+----------------------------------------------+
¦ 8      ¦        Acquisition ID 2             ¦
+----------------------------------------------+
¦ 9      ¦        Inspected Image ID 2         ¦
+----------------------------------------------+
¦ 10     ¦        Inspection Result Code 2     ¦
+----------------------------------------------+
¦ 11     ¦        Acquisition ID 3             ¦
+----------------------------------------------+
¦ 12     ¦        Inspected Image ID 3         ¦
+----------------------------------------------+
¦ 13     ¦        Inspection Result Code 3     ¦
+----------------------------------------------+
¦ 14-960 ¦        Inspection Results           ¦
+----------------------------------------------+

The SLMP "ControlWord" signal table/block organizes the word length signals sent from the PLC to the Vision System.
The size of the ControlWord block can vary depending on the size of the user data section.
+----------------------------------------------+
¦        ¦             16Bit Word              ¦
+----------------------------------------------+
¦ 0      ¦         Job Load ID                 ¦
+----------------------------------------------+
¦ 1-960  ¦         User Data                   ¦
+----------------------------------------------+

You can use CogNdmSlmpSignalBlockConstants and CogNdmSlmpDeviceConstants to map blocks of NDM signals to
SLMP devices with the CogNdmSlmpBlockMappingCollection class.

The following table describes the SLMP memory block addresses supported on the Q, L, and FX PLCs:

+-------------------------------+--------+----------------+----------------------------------+-----+----+
|          Device Name          | Prefix | Bit/Word based |      Address Representation      | Q/L | FX |
+-------------------------------+--------+----------------+----------------------------------+-----+----+
| Input Relay                   | X      | Bit            | Hex(Q/L Series) Octal(FX series) | X   | X  |
| Output Relay                  | Y      | Bit            | Hex(Q/L Series) Octal(FX series) | X   | X  |
| Internal Relay                | M      | Bit            | Decimal                          | X   | X  |
| Latch Relay                   | L      | Bit            | Decimal                          | X   | -  |
| Annunciator                   | F      | Bit            | Decimal                          | X   | -  |
| Link Relay                    | B      | Bit            | Hex                              | X   | -  |
| State Relay                   | S      | Bit            | Decimal                          | -   | X  |
| Data Register                 | D      | Word           | Decimal                          | X   | X  |
| Link Register                 | W      | Word           | Hex                              | X   | -  |
| File Register                 | R      | Word           | Decimal                          | X   | X  |
| File Register Multiple Blocks | ZR     | Word           | Hex                              | X   | -  |
| Timer                         | TN     | Word           | Decimal                          | X   | X  |
| Counter                       | CN     | Word           | Decimal                          | X   | X  |
+-------------------------------+--------+----------------+----------------------------------+-----+----+

The most commonly used devices used to communicate vision data to a PLC, are the M (Internal Relay) and
D (Data Register) types.
</code>
            </remarks>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmSlmpConfig.RemoteStationDestStationID">
            <summary>
Gets/sets the Remote Station Destination Station ID.
This is the ID of the second hop station.
This is the PCID for 1C frames.
</summary>
            <value>
Default value is 0.
</value>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidSlmpConfigException">
Thrown if RemoteStationDestStationID is not 0.
</exception>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmSlmpConfig.RemoteStationDestModule">
            <summary>
Gets/sets the Remote Station Destination Module.
This is the ID of the station in the rack.
</summary>
            <value>
Default value is CogSlmpRemoteStationDestModuleConstants.LocalStation_0x3ff.
</value>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidSlmpConfigException">
Thrown if RemoteStationDestModule is not a valid CogSlmpRemoteStationDestModuleConstants enumeration.
</exception>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmSlmpConfig.RemoteStationNetworkID">
            <summary>
Gets/sets the Remote Station Network ID.
This is the network ID of the next hop.
</summary>
            <value>
Default value is 0.
</value>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidSlmpConfigException">
Thrown if RemoteStationNetworkID is less than 0 or greater than 239.
</exception>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmSlmpConfig.RemoteStationID">
            <summary>
Gets/sets the Remote Station ID.
This is the Station ID (ID of C24 on a multidrop serial connection)
This is the PCID field for 1E/3E frames.
</summary>
            <value>
Default value is 255.
</value>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidSlmpConfigException">
Thrown if RemoteStationID is not in the range 0-120, 126, or 255.
</exception>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmSlmpConfig.TargetPort">
            <summary>
Gets/sets the Target Port of the PLC to connect to.
</summary>
            <value>
Default value is 12288 (0x3000).
</value>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidSlmpConfigException">
Thrown if TargetPort is less than 1 or greater than 65535.
</exception>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmSlmpConfig.TargetAddress">
            <summary>
Gets/sets the Target Address of the PLC to connect to.
</summary>
            <value>
Default value is null.
</value>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidSlmpConfigException">
Thrown if TargetAddress is less than 0.0.0.1 or greater than 223.255.255.254.
</exception>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmSlmpConfig.MessageFormat">
            <summary>
Gets/sets the SLMP Message Format.
</summary>
            <value>
Default value is CogSlmpMessageFormatConstants.QLSeries_3E.
</value>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidSlmpConfigException">
Thrown if MessageFormat is not a valid CogSlmpMessageFormatConstants enumeration.
</exception>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmSlmpConfig.PollRate">
            <summary>
Gets/sets the SLMP Poll Rate in milliseconds.
</summary>
            <value>
Default value is 1000.0.
</value>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidSlmpConfigException">
Thrown if PollRate is less than 5.0 or greater than 1000.0.
</exception>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmSlmpConfig.Timeout">
            <summary>
Gets/sets the SLMP Timeout in milliseconds.
</summary>
            <value>
Default value is 1000.0.
</value>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidSlmpConfigException">
Thrown if Timeout is less than 5.0 or greater than 1000.0.
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmSlmpConfig.#ctor(csSlmpScannerConfig_*,csSlmpBlockMapping_*,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Construct a .NET SLMP object from the underlying CVL parts.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmSlmpConfig.#ctor(Cognex.VisionPro.Comm.CogNdmSlmpConfig)">
            <summary>
Construct a deep copy of the given CogNdmSlmpConfig object.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmSlmpConfig.#ctor">
            <summary>
Construct a default CogNdmSlmpConfig object.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmSlmpConfig.SfTargetPort">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by TargetPort may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmSlmpConfig.SfNdmSignalBlockMapping">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by NdmSignalBlockMapping may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmSlmpConfig.SfRemoteStationDestStationID">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by RemoteStationDestStationID may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmSlmpConfig.SfRemoteStationDestModule">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by RemoteStationDestModule may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmSlmpConfig.SfRemoteStationNetworkID">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by RemoteStationNetworkID may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmSlmpConfig.SfRemoteStationID">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by RemoteStationID may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmSlmpConfig.SfTargetAddress">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by TargetAddress may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmSlmpConfig.SfMessageFormat">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by MessageFormat may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmSlmpConfig.SfPollRate">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by PollRate may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmSlmpConfig.SfTimeout">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by Timeout may have changed.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmSlmpConfig">
            <summary>
Contains settings that are specific to the SLMP protocol.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmSlmpBlockMappingCollection">
            <summary>
A collection of 
<see cref="T:Cognex.VisionPro.Comm.CogNdmSlmpBlockMapping" />
used to map blocks of the NDM signal table to SLMP devices.
</summary>
            <remarks>
                <para>
The following table describes host the NDM signal table is layed
out into 4 seperate blocks specific to SLMP.
</para>
                <code>
The SLMP "ControlBit" signal table/block organizes the single bit NDM signals
sent from the PLC to Vision System. The ControlBit block is 80 bits long.
+----------------+---------+-------+----------+-----------+-----------+------------+-----------+---------+
|                | Bit 7   | Bit 6 | Bit 5    | Bit 4     | Bit 3     | Bit 2      | Bit 1     | Bit 0   |
+----------------+---------+-------+----------+-----------+-----------+------------+-----------+---------+
| 0              | Set     | Clear | Rsvd     | Initiate  | Rsvd      | Rsvd       | Buffer    | Trigger |
|                | Offline | Error |          | Job       |           |            | Results   | Enable  |
|                |         |       |          | Load      |           |            | Enable    |         |
+--------------------------------------------------------------------------------------------------------+
| 1              |                              Rsvd                                                     |
+--------------------------------------------------------------------------------------------------------+
| 2-5            |                              SoftEvent 0-31                                           |
+--------------------------------------------------------------------------------------------------------+
| 6              | Rsvd    | Rsvd  | Rsvd     | Rsvd      | Set User | Clear      | Inspection | Trigger |
|                |         |       |          |           | Data 0   | Exposure   | Results    | Camera  |
|                |         |       |          |           |          | Complete 0 | Ack 0      | 0       |
+--------------------------------------------------------------------------------------------------------+
| 7              | Rsvd    | Rsvd  | Rsvd     | Rsvd      | Set User | Clear      | Inspection | Trigger |
|                |         |       |          |           | Data 1   | Exposure   | Results    | Camera  |
|                |         |       |          |           |          | Complete 1 | Ack 1      | 1       |
+--------------------------------------------------------------------------------------------------------+
| 8              | Rsvd    | Rsvd  | Rsvd     | Rsvd      | Set User | Clear      | Inspection | Trigger |
|                |         |       |          |           | Data 2   | Exposure   | Results    | Camera  |
|                |         |       |          |           |          | Complete 2 | Ack 2      | 2       |
+--------------------------------------------------------------------------------------------------------+
| 9              | Rsvd    | Rsvd  | Rsvd     | Rsvd      | Set User | Clear      | Inspection | Trigger |
|                |         |       |          |           | Data 3   | Exposure   | Results    | Camera  |
|                |         |       |          |           |          | Complete 3 | Ack 3      | 3       |
+--------------------------------------------------------------------------------------------------------+

The SLMP "StatusBit" signal table/block organizes the single bit NDM signals
sent from the Vision System to the PLC.  The StatusBit block is 112 bits long.
+----------------------------------------------------------------------------------------------------------+
¦        ¦ Bit 7     ¦ Bit 6       ¦ Bit 5     ¦ Bit 4       ¦ Bit 3      ¦ Bit 2   ¦ Bit 1    ¦ Bit 0     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 0      ¦ Online    ¦               Offline                 ¦ Rsvd       ¦ Rsvd    ¦ System   ¦ System    ¦
¦        ¦           ¦               Reason                  ¦            ¦         ¦ Busy     ¦ Ready     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 1      ¦ General   ¦ Rsvd        ¦ Job Load  ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Rsvd      ¦
¦        ¦ Fault     ¦             ¦ Completed ¦             ¦            ¦         ¦          ¦           ¦
+----------------------------------------------------------------------------------------------------------+
¦ 2-5    ¦                                  Soft Event Ack 0-31                                            ¦
+----------------------------------------------------------------------------------------------------------+
¦ 6      ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦
¦        ¦ Buffer    ¦ Passed 0    ¦ Valid 0   ¦ Completed 0 ¦ Complete 0 ¦ Error 0 ¦ Ack      ¦ Ready     ¦
¦        ¦ Overrun 0 ¦             ¦           ¦             ¦            ¦         ¦ Camera 0 ¦ Camera 0  ¦
+----------------------------------------------------------------------------------------------------------+
¦ 7      ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 0     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 8      ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦
¦        ¦ Buffer    ¦ Passed 1    ¦ Valid 1   ¦ Completed 1 ¦ Complete 1 ¦ Error 1 ¦ Ack      ¦ Ready     ¦
¦        ¦ Overrun 1 ¦             ¦           ¦             ¦            ¦         ¦ Camera 1 ¦ Camera 1  ¦
+----------------------------------------------------------------------------------------------------------+
¦ 9      ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 1     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 10     ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦
¦        ¦ Buffer    ¦ Passed 2    ¦ Valid 2   ¦ Completed 2 ¦ Complete 2 ¦ Error 2 ¦ Ack      ¦ Ready     ¦
¦        ¦ Overrun 2 ¦             ¦           ¦             ¦            ¦         ¦ Camera 2 ¦ Camera 2  ¦
+----------------------------------------------------------------------------------------------------------+
¦ 11     ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 2     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 12     ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦
¦        ¦ Buffer    ¦ Passed 3    ¦ Valid 3   ¦ Completed 3 ¦ Complete 3 ¦ Error 3 ¦ Ack      ¦ Ready     ¦
¦        ¦ Overrun 3 ¦             ¦           ¦             ¦            ¦         ¦ Camera 3 ¦ Camera 3  ¦
+----------------------------------------------------------------------------------------------------------+
¦ 13     ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 3     ¦
+----------------------------------------------------------------------------------------------------------+

The SLMP "StatusWord" signal table/block organizes the word length signals sent from the Vision System to the PLC.
The size of the StatusWord block can vary depending on the size of the inspection results section.
+----------------------------------------------+
¦        ¦             16Bit Word              ¦
+----------------------------------------------+
¦ 0      ¦        Current Job ID               ¦
+----------------------------------------------+
¦ 1      ¦        Error ID                     ¦
+----------------------------------------------+
¦ 2      ¦        Acquisition ID 0             ¦
+----------------------------------------------+
¦ 3      ¦        Inspected Image ID 0         ¦
+----------------------------------------------+
¦ 4      ¦        Inspection Result Code 0     ¦
+----------------------------------------------+
¦ 5      ¦        Acquisition ID 1             ¦
+----------------------------------------------+
¦ 6      ¦        Inspected Image ID 1         ¦
+----------------------------------------------+
¦ 7      ¦        Inspection Result Code 1     ¦
+----------------------------------------------+
¦ 8      ¦        Acquisition ID 2             ¦
+----------------------------------------------+
¦ 9      ¦        Inspected Image ID 2         ¦
+----------------------------------------------+
¦ 10     ¦        Inspection Result Code 2     ¦
+----------------------------------------------+
¦ 11     ¦        Acquisition ID 3             ¦
+----------------------------------------------+
¦ 12     ¦        Inspected Image ID 3         ¦
+----------------------------------------------+
¦ 13     ¦        Inspection Result Code 3     ¦
+----------------------------------------------+
¦ 14-960 ¦        Inspection Results           ¦
+----------------------------------------------+

The SLMP "ControlWord" signal table/block organizes the word length signals sent from the PLC to the Vision System.
The size of the ControlWord block can vary depending on the size of the user data section.
+----------------------------------------------+
¦        ¦             16Bit Word              ¦
+----------------------------------------------+
¦ 0      ¦         Job Load ID                 ¦
+----------------------------------------------+
¦ 1-960  ¦         User Data                   ¦
+----------------------------------------------+

You can use CogNdmSlmpSignalBlockConstants and CogNdmSlmpDeviceConstants to map blocks of NDM signals to
SLMP devices with the CogNdmSlmpBlockMappingCollection class.

The following table describes the SLMP memory block addresses supported on the Q, L, and FX PLCs:

+-------------------------------+--------+----------------+----------------------------------+-----+----+
|          Device Name          | Prefix | Bit/Word based |      Address Representation      | Q/L | FX |
+-------------------------------+--------+----------------+----------------------------------+-----+----+
| Input Relay                   | X      | Bit            | Hex(Q/L Series) Octal(FX series) | X   | X  |
| Output Relay                  | Y      | Bit            | Hex(Q/L Series) Octal(FX series) | X   | X  |
| Internal Relay                | M      | Bit            | Decimal                          | X   | X  |
| Latch Relay                   | L      | Bit            | Decimal                          | X   | -  |
| Annunciator                   | F      | Bit            | Decimal                          | X   | -  |
| Link Relay                    | B      | Bit            | Hex                              | X   | -  |
| State Relay                   | S      | Bit            | Decimal                          | -   | X  |
| Data Register                 | D      | Word           | Decimal                          | X   | X  |
| Link Register                 | W      | Word           | Hex                              | X   | -  |
| File Register                 | R      | Word           | Decimal                          | X   | X  |
| File Register Multiple Blocks | ZR     | Word           | Hex                              | X   | -  |
| Timer                         | TN     | Word           | Decimal                          | X   | X  |
| Counter                       | CN     | Word           | Decimal                          | X   | X  |
+-------------------------------+--------+----------------+----------------------------------+-----+----+

The most commonly used devices used to communicate vision data to a PLC, are the M (Internal Relay) and
D (Data Register) types.
</code>
            </remarks>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmSlmpBlockMapping.SlmpDeviceSizeInBits">
            <summary>
Gets/sets the size of the NDM signal block which is 
mapped into the SLMP device. The size is always specified in 
bits even for SLMP devices memory areas which are word based.
</summary>
            <value>
Default value is 0.
</value>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidSlmpConfigException">
Thrown if SlmpDeviceSizeInBits is less than 0 or greater than 15360 (1920 * 8).
</exception>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmSlmpBlockMapping.SlmpDeviceOffset">
            <summary>
Gets/sets the offset into the SLMP device where the NDM 
signal block is mapped. The offset it specified in the units
(bits or words) of the mapped SLMP device memory area.
Consult the table below to know which SLMP Device memory areas
are bit based and which are word based.
<code>
+-------------------------------+--------+----------------+----------------------------------+-----+----+
|          Device Name          | Prefix | Bit/Word based |      Address Representation      | Q/L | FX |
+-------------------------------+--------+----------------+----------------------------------+-----+----+
| Input Relay                   | X      | Bit            | Hex(Q/L Series) Octal(FX series) | X   | X  |
| Output Relay                  | Y      | Bit            | Hex(Q/L Series) Octal(FX series) | X   | X  |
| Internal Relay                | M      | Bit            | Decimal                          | X   | X  |
| Latch Relay                   | L      | Bit            | Decimal                          | X   | -  |
| Annunciator                   | F      | Bit            | Decimal                          | X   | -  |
| Link Relay                    | B      | Bit            | Hex                              | X   | -  |
| State Relay                   | S      | Bit            | Decimal                          | -   | X  |
| Data Register                 | D      | Word           | Decimal                          | X   | X  |
| Link Register                 | W      | Word           | Hex                              | X   | -  |
| File Register                 | R      | Word           | Decimal                          | X   | X  |
| File Register Multiple Blocks | ZR     | Word           | Hex                              | X   | -  |
| Timer                         | TN     | Word           | Decimal                          | X   | X  |
| Counter                       | CN     | Word           | Decimal                          | X   | X  |
+-------------------------------+--------+----------------+----------------------------------+-----+----+
</code></summary>
            <value>
Default value is 0.
</value>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidSlmpConfigException">
Thrown if SlmpDeviceOffset is less than 0.
</exception>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmSlmpBlockMapping.SlmpDevice">
            <summary>
Gets/sets the SLMP device that it mapped.
</summary>
            <value>
Default value is InternalRelay.
</value>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidSlmpConfigException">
Thrown if SlmpDevice is not a valid CogSlmpDeviceConstants enumeration.
</exception>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmSlmpBlockMapping.NdmSignalBlock">
            <summary>
Gets/sets the NDM signal block that is mapped.
</summary>
            <value>
Default value is None.
</value>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogFfpInvalidSlmpConfigException">
Thrown if NdmSignalBlock is not a valid CogNdmSlmpSignalBlockConstants enumeration.
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmSlmpBlockMapping.#ctor(Cognex.VisionPro.Comm.CogNdmSlmpSignalBlockConstants,Cognex.VisionPro.Comm.CogSlmpDeviceConstants,System.Int64,System.Int64)">
            <summary>
Construct a CogNdmSlmpBlockMapping object from parameters.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmSlmpBlockMapping.#ctor(Cognex.VisionPro.Comm.CogNdmSlmpBlockMapping)">
            <summary>
Construct a deep copy of the given CogNdmSlmpBlockMapping object.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmSlmpBlockMapping.#ctor">
            <summary>
Construct a default CogNdmSlmpBlockMapping object.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmSlmpBlockMapping.SfSlmpDeviceSizeInBits">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by SlmpDevcieSizeInBits may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmSlmpBlockMapping.SfSlmpDeviceOffset">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by SlmpDeviceOffset may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmSlmpBlockMapping.SfSlmpDevice">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by NdmSlmpDevice may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmSlmpBlockMapping.SfNdmSignalBlock">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by NdmSignalBlock may have changed.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmSlmpBlockMapping">
            <summary>
Contains settings that map a block/section of NDM signals to a 
specific SLMP protocol device.
<para>
The following table describes host the NDM signal table is layed
out into 4 seperate blocks specific to SLMP.
</para><code>
The SLMP "ControlBit" signal table/block organizes the single bit NDM signals
sent from the PLC to Vision System. The ControlBit block is 80 bits long.
+----------------+---------+-------+----------+-----------+-----------+------------+-----------+---------+
|                | Bit 7   | Bit 6 | Bit 5    | Bit 4     | Bit 3     | Bit 2      | Bit 1     | Bit 0   |
+----------------+---------+-------+----------+-----------+-----------+------------+-----------+---------+
| 0              | Set     | Clear | Rsvd     | Initiate  | Rsvd      | Rsvd       | Buffer    | Trigger |
|                | Offline | Error |          | Job       |           |            | Results   | Enable  |
|                |         |       |          | Load      |           |            | Enable    |         |
+--------------------------------------------------------------------------------------------------------+
| 1              |                              Rsvd                                                     |
+--------------------------------------------------------------------------------------------------------+
| 2-5            |                              SoftEvent 0-31                                           |
+--------------------------------------------------------------------------------------------------------+
| 6              | Rsvd    | Rsvd  | Rsvd     | Rsvd      | Set User | Clear      | Inspection | Trigger |
|                |         |       |          |           | Data 0   | Exposure   | Results    | Camera  |
|                |         |       |          |           |          | Complete 0 | Ack 0      | 0       |
+--------------------------------------------------------------------------------------------------------+
| 7              | Rsvd    | Rsvd  | Rsvd     | Rsvd      | Set User | Clear      | Inspection | Trigger |
|                |         |       |          |           | Data 1   | Exposure   | Results    | Camera  |
|                |         |       |          |           |          | Complete 1 | Ack 1      | 1       |
+--------------------------------------------------------------------------------------------------------+
| 8              | Rsvd    | Rsvd  | Rsvd     | Rsvd      | Set User | Clear      | Inspection | Trigger |
|                |         |       |          |           | Data 2   | Exposure   | Results    | Camera  |
|                |         |       |          |           |          | Complete 2 | Ack 2      | 2       |
+--------------------------------------------------------------------------------------------------------+
| 9              | Rsvd    | Rsvd  | Rsvd     | Rsvd      | Set User | Clear      | Inspection | Trigger |
|                |         |       |          |           | Data 3   | Exposure   | Results    | Camera  |
|                |         |       |          |           |          | Complete 3 | Ack 3      | 3       |
+--------------------------------------------------------------------------------------------------------+

The SLMP "StatusBit" signal table/block organizes the single bit NDM signals
sent from the Vision System to the PLC.  The StatusBit block is 112 bits long.
+----------------------------------------------------------------------------------------------------------+
¦        ¦ Bit 7     ¦ Bit 6       ¦ Bit 5     ¦ Bit 4       ¦ Bit 3      ¦ Bit 2   ¦ Bit 1    ¦ Bit 0     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 0      ¦ Online    ¦               Offline                 ¦ Rsvd       ¦ Rsvd    ¦ System   ¦ System    ¦
¦        ¦           ¦               Reason                  ¦            ¦         ¦ Busy     ¦ Ready     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 1      ¦ General   ¦ Rsvd        ¦ Job Load  ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Rsvd      ¦
¦        ¦ Fault     ¦             ¦ Completed ¦             ¦            ¦         ¦          ¦           ¦
+----------------------------------------------------------------------------------------------------------+
¦ 2-5    ¦                                  Soft Event Ack 0-31                                            ¦
+----------------------------------------------------------------------------------------------------------+
¦ 6      ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦
¦        ¦ Buffer    ¦ Passed 0    ¦ Valid 0   ¦ Completed 0 ¦ Complete 0 ¦ Error 0 ¦ Ack      ¦ Ready     ¦
¦        ¦ Overrun 0 ¦             ¦           ¦             ¦            ¦         ¦ Camera 0 ¦ Camera 0  ¦
+----------------------------------------------------------------------------------------------------------+
¦ 7      ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 0     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 8      ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦
¦        ¦ Buffer    ¦ Passed 1    ¦ Valid 1   ¦ Completed 1 ¦ Complete 1 ¦ Error 1 ¦ Ack      ¦ Ready     ¦
¦        ¦ Overrun 1 ¦             ¦           ¦             ¦            ¦         ¦ Camera 1 ¦ Camera 1  ¦
+----------------------------------------------------------------------------------------------------------+
¦ 9      ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 1     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 10     ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦
¦        ¦ Buffer    ¦ Passed 2    ¦ Valid 2   ¦ Completed 2 ¦ Complete 2 ¦ Error 2 ¦ Ack      ¦ Ready     ¦
¦        ¦ Overrun 2 ¦             ¦           ¦             ¦            ¦         ¦ Camera 2 ¦ Camera 2  ¦
+----------------------------------------------------------------------------------------------------------+
¦ 11     ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 2     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 12     ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦
¦        ¦ Buffer    ¦ Passed 3    ¦ Valid 3   ¦ Completed 3 ¦ Complete 3 ¦ Error 3 ¦ Ack      ¦ Ready     ¦
¦        ¦ Overrun 3 ¦             ¦           ¦             ¦            ¦         ¦ Camera 3 ¦ Camera 3  ¦
+----------------------------------------------------------------------------------------------------------+
¦ 13     ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 3     ¦
+----------------------------------------------------------------------------------------------------------+

The SLMP "StatusWord" signal table/block organizes the word length signals sent from the Vision System to the PLC.
The size of the StatusWord block can vary depending on the size of the inspection results section.
+----------------------------------------------+
¦        ¦             16Bit Word              ¦
+----------------------------------------------+
¦ 0      ¦        Current Job ID               ¦
+----------------------------------------------+
¦ 1      ¦        Error ID                     ¦
+----------------------------------------------+
¦ 2      ¦        Acquisition ID 0             ¦
+----------------------------------------------+
¦ 3      ¦        Inspected Image ID 0         ¦
+----------------------------------------------+
¦ 4      ¦        Inspection Result Code 0     ¦
+----------------------------------------------+
¦ 5      ¦        Acquisition ID 1             ¦
+----------------------------------------------+
¦ 6      ¦        Inspected Image ID 1         ¦
+----------------------------------------------+
¦ 7      ¦        Inspection Result Code 1     ¦
+----------------------------------------------+
¦ 8      ¦        Acquisition ID 2             ¦
+----------------------------------------------+
¦ 9      ¦        Inspected Image ID 2         ¦
+----------------------------------------------+
¦ 10     ¦        Inspection Result Code 2     ¦
+----------------------------------------------+
¦ 11     ¦        Acquisition ID 3             ¦
+----------------------------------------------+
¦ 12     ¦        Inspected Image ID 3         ¦
+----------------------------------------------+
¦ 13     ¦        Inspection Result Code 3     ¦
+----------------------------------------------+
¦ 14-960 ¦        Inspection Results           ¦
+----------------------------------------------+

The SLMP "ControlWord" signal table/block organizes the word length signals sent from the PLC to the Vision System.
The size of the ControlWord block can vary depending on the size of the user data section.
+----------------------------------------------+
¦        ¦             16Bit Word              ¦
+----------------------------------------------+
¦ 0      ¦         Job Load ID                 ¦
+----------------------------------------------+
¦ 1-960  ¦         User Data                   ¦
+----------------------------------------------+

You can use CogNdmSlmpSignalBlockConstants and CogNdmSlmpDeviceConstants to map blocks of NDM signals to
SLMP devices with the CogNdmSlmpBlockMappingCollection class.

The following table describes the SLMP memory block addresses supported on the Q, L, and FX PLCs:

+-------------------------------+--------+----------------+----------------------------------+-----+----+
|          Device Name          | Prefix | Bit/Word based |      Address Representation      | Q/L | FX |
+-------------------------------+--------+----------------+----------------------------------+-----+----+
| Input Relay                   | X      | Bit            | Hex(Q/L Series) Octal(FX series) | X   | X  |
| Output Relay                  | Y      | Bit            | Hex(Q/L Series) Octal(FX series) | X   | X  |
| Internal Relay                | M      | Bit            | Decimal                          | X   | X  |
| Latch Relay                   | L      | Bit            | Decimal                          | X   | -  |
| Annunciator                   | F      | Bit            | Decimal                          | X   | -  |
| Link Relay                    | B      | Bit            | Hex                              | X   | -  |
| State Relay                   | S      | Bit            | Decimal                          | -   | X  |
| Data Register                 | D      | Word           | Decimal                          | X   | X  |
| Link Register                 | W      | Word           | Hex                              | X   | -  |
| File Register                 | R      | Word           | Decimal                          | X   | X  |
| File Register Multiple Blocks | ZR     | Word           | Hex                              | X   | -  |
| Timer                         | TN     | Word           | Decimal                          | X   | X  |
| Counter                       | CN     | Word           | Decimal                          | X   | X  |
+-------------------------------+--------+----------------+----------------------------------+-----+----+

The most commonly used devices used to communicate vision data to a PLC, are the M (Internal Relay) and
D (Data Register) types.
</code></summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmProfinetConfig.UseStationName">
            <summary>
Gets/sets whether to use the PROFINET station name or not.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmProfinetConfig.StationName">
            <summary>
Gets/sets the PROFINET station name.
</summary>
            <remarks>
                <para>
EXAMPLE 1 “device-1.machine-1.plant-1.vendor”
</para>
                <para>
EXAMPLE 2 “device-1.bögeholz“ is coded as “device-1.xn-bgeholz-90a“
</para>
                <list type="bullet">
                    <item>
1 or more labels, separated by [.]    
</item>
                    <item>
Total length is 1 to 240
</item>
                    <item>
Label length is 1 to 63     
</item>
                    <item>
Labels consist of [a-z0-9-]      
</item>
                    <item>
Labels do not start with [-]      
</item>
                    <item>
Labels do not end with [-]
</item>
                    <item>
The first label does not start with "port-xyz" or "port-xyz-abcde" with a,b,c,d,e, x, y, z = 0...9   
</item>
                    <item>
Station-names do not have the form n.n.n.n, n = 0...999
</item>
                    <item>
Labels do only start with 'xn-' if RFC 3490 is applied
</item>
                    <item>
The definition of RFC 3490 shall be applied.
</item>
                </list>
            </remarks>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmProfinetConfig.#ctor">
            <summary>
Construct a default CogNdmProfinetConfig object.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmProfinetConfig.SfUseStationName">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by UseStationName may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmProfinetConfig.SfStationName">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by StationName may have changed.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmProfinetConfig">
            <summary>
Contains settings that are specific to the PROFINET protocol.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogFfpUnmanagedCallbackDelegate">
            <summary>
Delegate type which is marshaled to an unmanaged function pointer and
passed to the ffp module call back.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmProfinetConfigChangedEventHandler">
            <summary>
Event handler for 
<see cref="E:Cognex.VisionPro.Comm.CogNdmProfinet.ProfinetConfigChanged" />
event.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionNotReadyErrorEventHandler">
            <summary>
Event handler for 
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerAcquisitionNotReadyError" />
event.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionDisabledErrorEventHandler">
            <summary>
Event handler for 
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerAcquisitionDisabledError" />
event.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmOfflineRequestedEventHandler">
            <summary>
Event handler for 
<see cref="E:Cognex.VisionPro.Comm.CogNdm.OfflineRequested" />
event.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmJobChangeRequestedEventHandler">
            <summary>
Event handler for 
<see cref="E:Cognex.VisionPro.Comm.CogNdm.JobChangeRequested" />
event.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmProtocolStatusChangedEventHandler">
            <summary>
Event handler for 
<see cref="E:Cognex.VisionPro.Comm.CogNdm.ProtocolStatusChanged" />
event.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmClearErrorEventHandler">
            <summary>
Event handler for 
<see cref="E:Cognex.VisionPro.Comm.CogNdm.ClearError" />
event.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmNewUserDataEventHandler">
            <summary>
Event handler for 
<see cref="E:Cognex.VisionPro.Comm.CogNdm.NewUserData" />
event.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventOffEventHandler">
            <summary>
Event handler for 
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEventOff" />
event.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventHandler">
            <summary>
Event handler for 
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEvent" />
event.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionStopEventHandler">
            <summary>
Event handler for 
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerAcquisitionStop" />
event.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionEventHandler">
            <summary>
Event handler for 
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerAcquisition" />
event.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmProfinetConfigChangedEventArgs.#ctor(csFfpCallbackInfo_*)">
            <summary>
Construct the event args from an instance of the unmanaged callback info.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmProfinetConfigChangedEventArgs">
            <summary>
Event args returned as part of Cognex's Network Data Model (NDM)
<see cref="E:Cognex.VisionPro.Comm.CogNdmProfinet.ProfinetConfigChanged" /> event.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmOfflineRequestedEventArgs.ReturnToPreviousState">
            <summary>
False if the remote device has signaled the vision system to go offline.
True if the the remote device has signaled the vision system to return to the previous state, 
</summary>
            <remarks>
                <para>
Vision Systems often have an "online" and "offline" state.
The exact meaning of what it means to be online and offline may differ depending
on the particular vision system and application.
</para>
                <para>
The NDM allows the vision system to communicate and synchronize its online/offline state
with the remote device using the <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyRunning" />
and <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyStopped" /> methods.
</para>
                <para>
The vision system calls <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyRunning" /> to 
notify the remote device that the vision system is running or online.
</para>
                <para>
The vision system calls <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyStopped" /> to
notify the remote device that the vision system has stopped or gone offline.    
</para>
                <para>
The vision system's current online/offline state is reflected in the high or low
state of remote device's "Online" signal.
</para>
                <para>
The remote device may also signal the running vision system to go offline.   
The remote device does this by asserting its "Set Offline" signal high.
When the remote device raises the "Set Offline" signal high, the vision system receives 
the NDM <see cref="E:Cognex.VisionPro.Comm.CogNdm.OfflineRequested" /> event.
</para>
                <para>
The remote device may also signal the stopped vision system to return to its previous state.
The remote device does this by setting its "Set Offline" signal low.
When the remote device lowers the "Set Offline" signal, the vision system receives
the NDM <see cref="E:Cognex.VisionPro.Comm.CogNdm.OfflineRequested" /> event.
</para>
                <para>
Your vision system code should handle the NDM <see cref="E:Cognex.VisionPro.Comm.CogNdm.OfflineRequested" /> event.
When your code receives this event you should examine the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmOfflineRequestedEventArgs.ReturnToPreviousState" />
property of the event args to determine whether the remote device has signaled the vision system 
to go offline, or to return to the previous state.
</para>
                <para>
Once the code in your event handler has made the necessary transition,
be sure to call <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyStopped" />, or
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyRunning" /> to notify the
remote device of the new state of the vision system.
</para>
            </remarks>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmOfflineRequestedEventArgs.#ctor(csFfpCallbackInfo_*)">
            <summary>
Construct the event args from an instance of the 
unmanaged callback info.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmOfflineRequestedEventArgs">
            <summary>
Event args returned as part of Cognex's Network Data Model (NDM)
<see cref="E:Cognex.VisionPro.Comm.CogNdm.OfflineRequested" /> event.
</summary>
            <remarks>
                <para>
Vision Systems often have an "online" and "offline" state.
The exact meaning of what it means to be online and offline may differ depending
on the particular vision system and application.
</para>
                <para>
The NDM allows the vision system to communicate and synchronize its online/offline state
with the remote device using the <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyRunning" />
and <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyStopped" /> methods.
</para>
                <para>
The vision system calls <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyRunning" /> to 
notify the remote device that the vision system is running or online.
</para>
                <para>
The vision system calls <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyStopped" /> to
notify the remote device that the vision system has stopped or gone offline.    
</para>
                <para>
The vision system's current online/offline state is reflected in the high or low
state of remote device's "Online" signal.
</para>
                <para>
The remote device may also signal the running vision system to go offline.   
The remote device does this by asserting its "Set Offline" signal high.
When the remote device raises the "Set Offline" signal high, the vision system receives 
the NDM <see cref="E:Cognex.VisionPro.Comm.CogNdm.OfflineRequested" /> event.
</para>
                <para>
The remote device may also signal the stopped vision system to return to its previous state.
The remote device does this by setting its "Set Offline" signal low.
When the remote device lowers the "Set Offline" signal, the vision system receives
the NDM <see cref="E:Cognex.VisionPro.Comm.CogNdm.OfflineRequested" /> event.
</para>
                <para>
Your vision system code should handle the NDM <see cref="E:Cognex.VisionPro.Comm.CogNdm.OfflineRequested" /> event.
When your code receives this event you should examine the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmOfflineRequestedEventArgs.ReturnToPreviousState" />
property of the event args to determine whether the remote device has signaled the vision system 
to go offline, or to return to the previous state.
</para>
                <para>
Once the code in your event handler has made the necessary transition,
be sure to call <see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyStopped" />, or
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyRunning" /> to notify the
remote device of the new state of the vision system.
</para>
            </remarks>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionNotReadyErrorEventArgs.CameraIndex">
            <summary>
Gets the index of the camera that was triggered resulting in the error.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionNotReadyErrorEventArgs.#ctor(csFfpCallbackInfo_*)">
            <summary>
Construct the event args from an instance of the 
unmanaged callback info.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionNotReadyErrorEventArgs">
            <summary>
Event args returned as part of Cognex's Network Data Model (NDM)
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerAcquisitionNotReadyError" /> event.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionDisabledErrorEventArgs.CameraIndex">
            <summary>
Gets the index of the camera that was triggered resulting in the error.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionDisabledErrorEventArgs.#ctor(csFfpCallbackInfo_*)">
            <summary>
Construct the event args from an instance of the 
unmanaged callback info.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionDisabledErrorEventArgs">
            <summary>
Event args returned as part of Cognex's Network Data Model (NDM)
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerAcquisitionDisabledError" /> event.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionStopEventArgs.CameraIndex">
            <summary>
Gets the index of the camera to trigger.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionStopEventArgs.#ctor(csFfpCallbackInfo_*)">
            <summary>
Construct the event args from an instance of the 
unmanaged callback info.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionStopEventArgs">
            <summary>
Event args returned as part of Cognex's Network Data Model (NDM)
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerAcquisitionStop" /> event.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionEventArgs.ResponseCode">
            <summary>
Gets/Sets the acquisition response code.
<para>
If an error status is set, an acquisition error is reported to the 
remote device.
</para></summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionEventArgs.CameraIndex">
            <summary>
Gets the index of the camera to trigger.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionEventArgs.#ctor(csFfpCallbackInfo_*)">
            <summary>
Construct the event args from an instance of the 
unmanaged callback info.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionEventArgs">
            <summary>
Event args returned as part of Cognex's Network Data Model (NDM)
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerAcquisition" /> event.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventOffEventArgs.SoftEventID">
            <summary>
Gets the ID number of the soft event to trigger.
</summary>
            <remarks>
                <para>
Soft Events provide a mechanism for sending general purpose binary signals from the remote device
to the vision system. The NDM provides 32 individual Soft Events signals which are uniquely 
identified by their indices (0-31). The remote device and the vision system can assign specific 
meanings to the each Soft Event signal based on what is useful to their application context.
</para>
                <para>
To use a Soft Event, the remote device asserts one of the "Soft Event [0-31]" signals high.
When the vision system sees this signal transition, the NDM raises the  
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEvent" /> event.
Your vision system code can optionally handle this .NET event and perform any processing
that might be necessary.
</para>
                <para>
Your event handler code should use the
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.SoftEventID" /> 
property of the event args to identify which of the 32 Soft Event signals was received.
</para>
                <para>
Additionally, your vision system event handler code should set the
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to signal to the remote device whether the vision system has
finished processing the Soft Event when the event handler returns, or if the soft event
processing will continue asynchronously after your event handler code returns.
</para>
                <para>
If you the set the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to
<see cref="T:Cognex.VisionPro.Comm.CogNdmSoftEventResponseCodeConstants">Finshed</see>,
the NDM will automatically notify the remote device by sending the appropriately indexed "Soft Event Ack"
signal.
</para>
                <para>
If you set the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to
<see cref="T:Cognex.VisionPro.Comm.CogNdmSoftEventResponseCodeConstants">NotFinshed</see>,
The NDM will wait until you call the CogNDM's
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyAsyncSoftEventComplete" /> method before sending the
corresponding "Soft Event Ack" to the remote device.
</para>
                <para>
Note that if you are processing soft events asynchronously you must save the
<see cref="P:Cognex.VisionPro.Comm.CogNdmEventArgsBase.MessageID" /> from the
event args so that you can latter pass it to the NDM's
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyAsyncSoftEventComplete" /> method to notify the
remote device that soft event processing is complete.      
</para>
                <para>
In both the synchronous and asynchronous cases the remote device should send/assert the "Soft Event" signal high.
Then wait to receive to receive the "Soft Event Ack" signal while the vision system is processing the soft event.
Once the remote device sees the "Soft Event Ack" signal go high, it can then set the original "Soft Event"
signal low.
</para>
                <para>
When the remote device sets a "Soft Event" signal low the vision system is signaled via the 
NDM's <see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEventOff" /> event.
Your vision system code can optionally handle this event.
After any user event handler code returns, the NDM automatically notifies the
remote device by setting the "Soft Event Ack" signal low.
Once the remote device sees the "Soft Event Ack" signal go low, it knows that it is now
safe to signal another instance of the same soft event.
</para>
                <para>
Note that the NDM's soft event signals are supported by the Comm Card's precision i/o event system.
You can configure the NDM soft events signals to automatically cause a
<see cref="T:Cognex.VisionPro.Comm.CogPrioEvent" />
directly on the Comm Card's real time processor without involving the host OS.
This is primarily useful if you need to deterministically set or pulse a discrete output line based on a soft
event signal from the remote device.
</para>
            </remarks>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventOffEventArgs.#ctor(csFfpCallbackInfo_*)">
            <summary>
Construct the event args from an instance of the 
unmanaged callback info.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventOffEventArgs">
            <summary>
Event args returned as part of Cognex's Network Data Model (NDM)
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEventOff" /> event.
</summary>
            <remarks>
                <para>
Soft Events provide a mechanism for sending general purpose binary signals from the remote device
to the vision system. The NDM provides 32 individual Soft Events signals which are uniquely 
identified by their indices (0-31). The remote device and the vision system can assign specific 
meanings to the each Soft Event signal based on what is useful to their application context.
</para>
                <para>
To use a Soft Event, the remote device asserts one of the "Soft Event [0-31]" signals high.
When the vision system sees this signal transition, the NDM raises the  
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEvent" /> event.
Your vision system code can optionally handle this .NET event and perform any processing
that might be necessary.
</para>
                <para>
Your event handler code should use the
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.SoftEventID" /> 
property of the event args to identify which of the 32 Soft Event signals was received.
</para>
                <para>
Additionally, your vision system event handler code should set the
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to signal to the remote device whether the vision system has
finished processing the Soft Event when the event handler returns, or if the soft event
processing will continue asynchronously after your event handler code returns.
</para>
                <para>
If you the set the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to
<see cref="T:Cognex.VisionPro.Comm.CogNdmSoftEventResponseCodeConstants">Finshed</see>,
the NDM will automatically notify the remote device by sending the appropriately indexed "Soft Event Ack"
signal.
</para>
                <para>
If you set the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to
<see cref="T:Cognex.VisionPro.Comm.CogNdmSoftEventResponseCodeConstants">NotFinshed</see>,
The NDM will wait until you call the CogNDM's
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyAsyncSoftEventComplete" /> method before sending the
corresponding "Soft Event Ack" to the remote device.
</para>
                <para>
Note that if you are processing soft events asynchronously you must save the
<see cref="P:Cognex.VisionPro.Comm.CogNdmEventArgsBase.MessageID" /> from the
event args so that you can latter pass it to the NDM's
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyAsyncSoftEventComplete" /> method to notify the
remote device that soft event processing is complete.      
</para>
                <para>
In both the synchronous and asynchronous cases the remote device should send/assert the "Soft Event" signal high.
Then wait to receive to receive the "Soft Event Ack" signal while the vision system is processing the soft event.
Once the remote device sees the "Soft Event Ack" signal go high, it can then set the original "Soft Event"
signal low.
</para>
                <para>
When the remote device sets a "Soft Event" signal low the vision system is signaled via the 
NDM's <see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEventOff" /> event.
Your vision system code can optionally handle this event.
After any user event handler code returns, the NDM automatically notifies the
remote device by setting the "Soft Event Ack" signal low.
Once the remote device sees the "Soft Event Ack" signal go low, it knows that it is now
safe to signal another instance of the same soft event.
</para>
                <para>
Note that the NDM's soft event signals are supported by the Comm Card's precision i/o event system.
You can configure the NDM soft events signals to automatically cause a
<see cref="T:Cognex.VisionPro.Comm.CogPrioEvent" />
directly on the Comm Card's real time processor without involving the host OS.
This is primarily useful if you need to deterministically set or pulse a discrete output line based on a soft
event signal from the remote device.
</para>
            </remarks>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode">
            <summary>
Gets/Sets the soft event response code.
</summary>
            <remarks>
                <para>
Soft Events provide a mechanism for sending general purpose binary signals from the remote device
to the vision system. The NDM provides 32 individual Soft Events signals which are uniquely 
identified by their indices (0-31). The remote device and the vision system can assign specific 
meanings to the each Soft Event signal based on what is useful to their application context.
</para>
                <para>
To use a Soft Event, the remote device asserts one of the "Soft Event [0-31]" signals high.
When the vision system sees this signal transition, the NDM raises the  
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEvent" /> event.
Your vision system code can optionally handle this .NET event and perform any processing
that might be necessary.
</para>
                <para>
Your event handler code should use the
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.SoftEventID" /> 
property of the event args to identify which of the 32 Soft Event signals was received.
</para>
                <para>
Additionally, your vision system event handler code should set the
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to signal to the remote device whether the vision system has
finished processing the Soft Event when the event handler returns, or if the soft event
processing will continue asynchronously after your event handler code returns.
</para>
                <para>
If you the set the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to
<see cref="T:Cognex.VisionPro.Comm.CogNdmSoftEventResponseCodeConstants">Finshed</see>,
the NDM will automatically notify the remote device by sending the appropriately indexed "Soft Event Ack"
signal.
</para>
                <para>
If you set the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to
<see cref="T:Cognex.VisionPro.Comm.CogNdmSoftEventResponseCodeConstants">NotFinshed</see>,
The NDM will wait until you call the CogNDM's
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyAsyncSoftEventComplete" /> method before sending the
corresponding "Soft Event Ack" to the remote device.
</para>
                <para>
Note that if you are processing soft events asynchronously you must save the
<see cref="P:Cognex.VisionPro.Comm.CogNdmEventArgsBase.MessageID" /> from the
event args so that you can latter pass it to the NDM's
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyAsyncSoftEventComplete" /> method to notify the
remote device that soft event processing is complete.      
</para>
                <para>
In both the synchronous and asynchronous cases the remote device should send/assert the "Soft Event" signal high.
Then wait to receive to receive the "Soft Event Ack" signal while the vision system is processing the soft event.
Once the remote device sees the "Soft Event Ack" signal go high, it can then set the original "Soft Event"
signal low.
</para>
                <para>
When the remote device sets a "Soft Event" signal low the vision system is signaled via the 
NDM's <see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEventOff" /> event.
Your vision system code can optionally handle this event.
After any user event handler code returns, the NDM automatically notifies the
remote device by setting the "Soft Event Ack" signal low.
Once the remote device sees the "Soft Event Ack" signal go low, it knows that it is now
safe to signal another instance of the same soft event.
</para>
                <para>
Note that the NDM's soft event signals are supported by the Comm Card's precision i/o event system.
You can configure the NDM soft events signals to automatically cause a
<see cref="T:Cognex.VisionPro.Comm.CogPrioEvent" />
directly on the Comm Card's real time processor without involving the host OS.
This is primarily useful if you need to deterministically set or pulse a discrete output line based on a soft
event signal from the remote device.
</para>
            </remarks>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.SoftEventID">
            <summary>
Gets the index/id number of the soft event.
</summary>
            <remarks>
                <para>
Soft Events provide a mechanism for sending general purpose binary signals from the remote device
to the vision system. The NDM provides 32 individual Soft Events signals which are uniquely 
identified by their indices (0-31). The remote device and the vision system can assign specific 
meanings to the each Soft Event signal based on what is useful to their application context.
</para>
                <para>
To use a Soft Event, the remote device asserts one of the "Soft Event [0-31]" signals high.
When the vision system sees this signal transition, the NDM raises the  
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEvent" /> event.
Your vision system code can optionally handle this .NET event and perform any processing
that might be necessary.
</para>
                <para>
Your event handler code should use the
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.SoftEventID" /> 
property of the event args to identify which of the 32 Soft Event signals was received.
</para>
                <para>
Additionally, your vision system event handler code should set the
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to signal to the remote device whether the vision system has
finished processing the Soft Event when the event handler returns, or if the soft event
processing will continue asynchronously after your event handler code returns.
</para>
                <para>
If you the set the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to
<see cref="T:Cognex.VisionPro.Comm.CogNdmSoftEventResponseCodeConstants">Finshed</see>,
the NDM will automatically notify the remote device by sending the appropriately indexed "Soft Event Ack"
signal.
</para>
                <para>
If you set the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to
<see cref="T:Cognex.VisionPro.Comm.CogNdmSoftEventResponseCodeConstants">NotFinshed</see>,
The NDM will wait until you call the CogNDM's
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyAsyncSoftEventComplete" /> method before sending the
corresponding "Soft Event Ack" to the remote device.
</para>
                <para>
Note that if you are processing soft events asynchronously you must save the
<see cref="P:Cognex.VisionPro.Comm.CogNdmEventArgsBase.MessageID" /> from the
event args so that you can latter pass it to the NDM's
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyAsyncSoftEventComplete" /> method to notify the
remote device that soft event processing is complete.      
</para>
                <para>
In both the synchronous and asynchronous cases the remote device should send/assert the "Soft Event" signal high.
Then wait to receive to receive the "Soft Event Ack" signal while the vision system is processing the soft event.
Once the remote device sees the "Soft Event Ack" signal go high, it can then set the original "Soft Event"
signal low.
</para>
                <para>
When the remote device sets a "Soft Event" signal low the vision system is signaled via the 
NDM's <see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEventOff" /> event.
Your vision system code can optionally handle this event.
After any user event handler code returns, the NDM automatically notifies the
remote device by setting the "Soft Event Ack" signal low.
Once the remote device sees the "Soft Event Ack" signal go low, it knows that it is now
safe to signal another instance of the same soft event.
</para>
                <para>
Note that the NDM's soft event signals are supported by the Comm Card's precision i/o event system.
You can configure the NDM soft events signals to automatically cause a
<see cref="T:Cognex.VisionPro.Comm.CogPrioEvent" />
directly on the Comm Card's real time processor without involving the host OS.
This is primarily useful if you need to deterministically set or pulse a discrete output line based on a soft
event signal from the remote device.
</para>
            </remarks>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.#ctor(csFfpCallbackInfo_*)">
            <summary>
Construct the event args from an instance of the 
unmanaged callback info.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs">
            <summary>
Event args returned as part of Cognex's Network Data Model (NDM)
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEvent" /> event.
</summary>
            <remarks>
                <para>
Soft Events provide a mechanism for sending general purpose binary signals from the remote device
to the vision system. The NDM provides 32 individual Soft Events signals which are uniquely 
identified by their indices (0-31). The remote device and the vision system can assign specific 
meanings to the each Soft Event signal based on what is useful to their application context.
</para>
                <para>
To use a Soft Event, the remote device asserts one of the "Soft Event [0-31]" signals high.
When the vision system sees this signal transition, the NDM raises the  
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEvent" /> event.
Your vision system code can optionally handle this .NET event and perform any processing
that might be necessary.
</para>
                <para>
Your event handler code should use the
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.SoftEventID" /> 
property of the event args to identify which of the 32 Soft Event signals was received.
</para>
                <para>
Additionally, your vision system event handler code should set the
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to signal to the remote device whether the vision system has
finished processing the Soft Event when the event handler returns, or if the soft event
processing will continue asynchronously after your event handler code returns.
</para>
                <para>
If you the set the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to
<see cref="T:Cognex.VisionPro.Comm.CogNdmSoftEventResponseCodeConstants">Finshed</see>,
the NDM will automatically notify the remote device by sending the appropriately indexed "Soft Event Ack"
signal.
</para>
                <para>
If you set the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.ResponseCode" />
property of the event args to
<see cref="T:Cognex.VisionPro.Comm.CogNdmSoftEventResponseCodeConstants">NotFinshed</see>,
The NDM will wait until you call the CogNDM's
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyAsyncSoftEventComplete" /> method before sending the
corresponding "Soft Event Ack" to the remote device.
</para>
                <para>
Note that if you are processing soft events asynchronously you must save the
<see cref="P:Cognex.VisionPro.Comm.CogNdmEventArgsBase.MessageID" /> from the
event args so that you can latter pass it to the NDM's
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyAsyncSoftEventComplete" /> method to notify the
remote device that soft event processing is complete.      
</para>
                <para>
In both the synchronous and asynchronous cases the remote device should send/assert the "Soft Event" signal high.
Then wait to receive to receive the "Soft Event Ack" signal while the vision system is processing the soft event.
Once the remote device sees the "Soft Event Ack" signal go high, it can then set the original "Soft Event"
signal low.
</para>
                <para>
When the remote device sets a "Soft Event" signal low the vision system is signaled via the 
NDM's <see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEventOff" /> event.
Your vision system code can optionally handle this event.
After any user event handler code returns, the NDM automatically notifies the
remote device by setting the "Soft Event Ack" signal low.
Once the remote device sees the "Soft Event Ack" signal go low, it knows that it is now
safe to signal another instance of the same soft event.
</para>
                <para>
Note that the NDM's soft event signals are supported by the Comm Card's precision i/o event system.
You can configure the NDM soft events signals to automatically cause a
<see cref="T:Cognex.VisionPro.Comm.CogPrioEvent" />
directly on the Comm Card's real time processor without involving the host OS.
This is primarily useful if you need to deterministically set or pulse a discrete output line based on a soft
event signal from the remote device.
</para>
            </remarks>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmNewUserDataEventArgs.ChannelIndex">
            <summary>
Gets the index of the user data slot\channel which has new user data available.
</summary>
            <remarks>
The remote device can send separate "Set User Data" signals for each
user data slot\channel, you can distinguish between these signals by examining
this property.
</remarks>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmNewUserDataEventArgs.#ctor(csFfpCallbackInfo_*)">
            <summary>
Construct the event args from an instance of the 
unmanaged callback info.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmNewUserDataEventArgs">
            <summary>
Event args returned as part of Cognex's Network Data Model (NDM)
<see cref="E:Cognex.VisionPro.Comm.CogNdm.NewUserData" /> event.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmClearErrorEventArgs.#ctor(csFfpCallbackInfo_*)">
            <summary>
Construct the event args from an instance of the 
unmanaged callback info.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmClearErrorEventArgs">
            <summary>
Event args returned as part of Cognex's Network Data Model (NDM)
<see cref="E:Cognex.VisionPro.Comm.CogNdm.ClearError" /> event.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmProtocolStatusChangedEventArgs.RemoteAddress">
            <summary>
Gets the IPAddress of the connected PLC
</summary>
            <remarks>
When the connection status is ConnectionIdle, the remote address is 
invalid and this property returns null.
</remarks>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmProtocolStatusChangedEventArgs.ProtocolStatus">
            <summary>
Gets the new status of the protocol.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmProtocolStatusChangedEventArgs.#ctor(csFfpCallbackInfo_*)">
            <summary>
Construct the event args from an instance of the 
unmanaged callback info.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmProtocolStatusChangedEventArgs">
            <summary>
Event args returned as part of Cognex's Network Data Model (NDM)
<see cref="E:Cognex.VisionPro.Comm.CogNdm.ProtocolStatusChanged" /> event.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmJobChangeRequestedEventArgs.JobSlot">
            <summary>
Gets the Job slot to change.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmJobChangeRequestedEventArgs.JobID">
            <summary>
Gets the Job ID to load.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmJobChangeRequestedEventArgs.#ctor(csFfpCallbackInfo_*)">
            <summary>
Construct the event args from an instance of the 
unmanaged callback info.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmJobChangeRequestedEventArgs">
            <summary>
Event args returned as part of Cognex's Network Data Model (NDM)
<see cref="E:Cognex.VisionPro.Comm.CogNdm.JobChangeRequested" /> event.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmEventArgsBase.MessageID">
            <summary>
An ID number that uniquely identifies the message.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmEventArgsBase.#ctor(csFfpCallbackInfo_*)">
            <summary>
Construct the event args from an instance of the 
unmanaged callback info.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmEventArgsBase">
            <summary>
Base Class for all event args types used 
by Cognex's Network Data Model (NDM).
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmInspectionResult.ResultDataOffset">
            <summary>
An offset into the overall result data packet
at which to write the result data for this
particular inspection result.
<para>
There is a single common packet format 
for all inspection result data.
It is the responsibility of the user to partition
this single data region into separate regions
to avoid overwriting result data from 
other parallel inspection slots/channels
(if they so choose).
</para></summary>
            <exception cref="T:System.ArgumentException">
Thrown if value is less than 0.
</exception>
            <exception cref="T:System.ArgumentException">
Thrown if the value is less than 0. 
</exception>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmInspectionResult.ResultData">
            <summary>
The data produced by the inspection to be 
sent to the remote device.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmInspectionResult.ResultCode">
            <summary>
A user specified code which signifies something
about the result of the inspection.
</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if the value is less than 0 or greater than UInt16.MaxValue. 
</exception>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmInspectionResult.InspectionPassed">
            <summary>
Information about whether the inspection passed or
failed.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmInspectionResult.UsedAcquisitionIDs">
            <summary>
Information about which acquired images were used by the
inspection process to produce this inspection result.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmInspectionResult.InspectionIndex">
            <summary>
The index of the inspection process\channel\slot
that produced this inspection result.
</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if the value is less than 0 or greater than 255. 
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmInspectionResult.#ctor(System.Int32,Cognex.VisionPro.Comm.CogNdmUsedAcquisitionIDCollection,System.Boolean,System.Int32,System.Byte[],System.Int32)">
            <summary>
Constructs a Network Data Model (NDM) inspection result.
NDM inspection result is a structure designed to hold
the data to be sent to a remote device over (usually a PLC).
</summary>
            <param name="inspectionIndex">
The index of the inspection process\channel\slot
that produced this inspection result.
</param>
            <param name="usedAcquisitionIDs">
Information about which acquired images were used by the
inspection process to produce this inspection result.
</param>
            <param name="inspectionPassed">
Information about whether the inspection passed or
failed.
</param>
            <param name="resultCode">
A user specified code which signifies something
about the result of the inspection.
</param>
            <param name="resultData">
The data produced by the inspection to be 
sent to the remote device.
</param>
            <param name="resultDataOffset">
An offset into the overall result data packet
at which to write the result data for this
particular inspection result.
<para>
There is a single common packet format 
for all inspection result data.
It is the responsibility of the user to partition
this single data region into separate regions
to avoid overwriting result data from 
other parallel inspection slots/channels
(if they so choose).
</para></param>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if the result code is less than 0 or greater than UInt16.MaxValue. 
</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if the inspection index is less than 0 or greater than 255. 
</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if the acquisition ID in the usedAcquisitionIDs is less than 0 or greater than UInt16.MaxValue. 
</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if the camera index in the usedAcquisitionIDs is less than 0 or greater than UInt16.MaxValue. 
</exception>
            <exception cref="T:System.ArgumentException">
Thrown if the result data offset is less than 0 or greater than UInt16.MaxValue. 
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmInspectionResult.#ctor">
            <summary>
Constructs a default Network Data Model (NDM) inspection result.
NDM inspection result is a structure designed to hold
the data to be sent to a remote device over (usually a PLC).
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmInspectionResult">
            <summary>
Represents the result of a machine vision inspection.
<para>
Construct an instance of CogNdmInspectionResult and fill it with the
information about the result of running an inspection.
</para><para>
Pass constructed CogNdmInspectionResult instances to the 
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyInspectionComplete" />
method.
</para><para>
This sends the inspection result information to the remote device
(usually a PLC) using Cognex's Network Data Model (NDM).
</para></summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmUsedAcquisitionIDCollection">
            <summary>
A collection of 
<see cref="T:Cognex.VisionPro.Comm.CogNdmUsedAcquisitionID" />
used to track which images were used to produce a particular inspection result.
<para>
The vision system must supply the acquisition IDs of the images used
when constructing a <see cref="T:Cognex.VisionPro.Comm.CogNdmInspectionResult" />.
This information is passed to the remote device and enables the remote
device to track the progress of the vision system.
</para></summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmUsedAcquisitionID.CameraIndex">
            <summary>
The camera index slot associated with a particular
acquired image used in an inspection.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogNdmUsedAcquisitionID.AcquisitionID">
            <summary>
The acquisition ID associated with a particular
acquired image used in an inspection.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogNdmUsedAcquisitionID.#ctor(System.Int32,System.Int32)">
            <summary>
Constructs a new used acquisition ID.
</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if camera index is less than 0 or greater than the number of 
supported camera acquisition channels.
</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if the acquisition ID is less than 0 or greater than UInt16.MaxValue. 
</exception>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmUsedAcquisitionID">
            <summary>
CogNdmUsedAcquisitionID uniquely identifies an 
acquired image used in an inspection.
<para>
The vision system must supply the acquisition IDs of the images used
when constructing a <see cref="T:Cognex.VisionPro.Comm.CogNdmInspectionResult" />.
This information is passed to the remote device and enables the remote
device to track the progress of the vision system.
</para></summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmStoppedCodeConstants">
            <summary>
Constants enumerating the reasons a vision system is stopped.
</summary>
            <remarks>
                <para>
The NDM supports 3 bits of stopped code information.
</para>
Currently the NDM does _not_ define its own stopped codes. 
You must supply your own meaningful stopped codes as arguments to
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyStopped" />.
</remarks>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionResponseCodeConstants">
            <summary>
Constants enumerating possible response codes from
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerAcquisition" />.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionResponseCodeConstants.AcquisitionError">
            <summary>
An acquisition error occurred and is reported to the remote device.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmTriggerAcquisitionResponseCodeConstants.Success">
            <summary>
The trigger was accepted.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmSoftEventResponseCodeConstants">
            <summary>
Constants enumerating possible response codes from
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEvent" />.
</summary>
            <remarks>
                <para>
Soft Events provide a mechanism for sending general purpose binary signals from the remote device
to the vision system. The NDM provides 32 individual Soft Events signals which are uniquely 
identified by their indices (0-31). The remote device and the vision system can assign specific 
meanings to the each Soft Event signal based on what is useful to their application context.
</para>
                <para>
To use a Soft Event, the remote device asserts one of the "Soft Event [0-31]" signals high.
When the vision system sees this signal transition, the NDM raises the  
<see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEvent" /> event.
Your vision system code can optionally handle this .NET event and perform any processing
that might be necessary.
</para>
                <para>
Your event handler code should use the
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventEventArgs.SoftEventID" /> 
property of the event args to identify which of the 32 Soft Event signals was received.
</para>
                <para>
Additionally, your vision system event handler code should set the
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventArgs.ResponseCode" />
property of the event args to signal to the remote device whether the vision system has
finished processing the Soft Event when the event handler returns, or if the soft event
processing will continue asynchronously after your event handler code returns.
</para>
                <para>
If you the set the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventArgs.ResponseCode" />
property of the event args to
<see cref="T:Cognex.VisionPro.Comm.CogNdmSoftEventResponseCodeConstants">Finshed</see>,
the NDM will automatically notify the remote device by sending the appropriately indexed "Soft Event Ack"
signal.
</para>
                <para>
If you set the 
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventArgs.ResponseCode" />
property of the event args to
<see cref="T:Cognex.VisionPro.Comm.CogNdmSoftEventResponseCodeConstants">NotFinshed</see>,
The NDM will wait until you call the CogNDM's
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyAsyncSoftEventComplete" /> method before sending the
corresponding "Soft Event Ack" to the remote device.
</para>
                <para>
Note that if you are processing soft events asynchronously you must save the
<see cref="P:Cognex.VisionPro.Comm.CogNdmTriggerSoftEventArgs.MessageID" /> from the
event args so that you can latter pass it to the NDM's
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyAsyncSoftEventComplete" /> method to notify the
remote device that soft event processing is complete.      
</para>
                <para>
In both the synchronous and asynchronous cases the remote device should send/assert the "Soft Event" signal high.
Then wait to receive to receive the "Soft Event Ack" signal while the vision system is processing the soft event.
Once the remote device sees the "Soft Event Ack" signal go high, it can then set the original "Soft Event"
signal low.
</para>
                <para>
When the remote device sets a "Soft Event" signal low the vision system is signaled via the 
NDM's <see cref="E:Cognex.VisionPro.Comm.CogNdm.TriggerSoftEventOff" /> event.
Your vision system code can optionally handle this event.
After any user event handler code returns, the NDM automatically notifies the
remote device by setting the "Soft Event Ack" signal low.
Once the remote device sees the "Soft Event Ack" signal go low, it knows that it is now
safe to signal another instance of the same soft event.
</para>
                <para>
Note that the NDM's soft event signals are supported by the Comm Card's precision i/o event system.
You can configure the NDM soft events signals to automatically cause a
<see cref="T:Cognex.VisionPro.Comm.CogPrioEvent" />
directly on the Comm Card's real time processor without involving the host OS.
This is primarily useful if you need to deterministically set or pulse a discrete output line based on a soft
event signal from the remote device.
</para>
            </remarks>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmSoftEventResponseCodeConstants.NotFinished">
            <summary>
The soft event is still executing. The user must
manually notify the remote device that the soft event has completed
by calling 
<see cref="M:Cognex.VisionPro.Comm.CogNdm.NotifyAsyncSoftEventComplete" /></summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmSoftEventResponseCodeConstants.Finished">
            <summary>
The soft event has completed executing.
The remote device is automatically notified that the soft event 
has completed.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmConnectionStatusConstants">
            <summary>
Constants enumerating the status of a factory floor
protocol connection.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmConnectionStatusConstants.NormalOperationRestored">
            <summary>
The NDM has returned to normal operation conditions.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmConnectionStatusConstants.PollRateTooLow">
            <summary>
The remote device's repsonse times are greater than the current poll rate.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmConnectionStatusConstants.ConnectionFaulted">
            <summary>
The NDM 's active connection has faulted state.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmConnectionStatusConstants.ConnectReject">
            <summary>
The NDM made a connection request which was rejected by the connection target.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmConnectionStatusConstants.Connected">
            <summary>
The NDM is in the connected state.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmConnectionStatusConstants.Connecting">
            <summary>
The NDM is in process of making a connection.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmConnectionStatusConstants.ConnectionIdle">
            <summary>
The NDM is in the idle state. 
The NDM is neither connected nor in the process of connecting. 
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogNdmSlmpSignalBlockConstants">
            <summary>
Enumerates the NDM signal blocks for SLMP.
<para>
The following table describes host the NDM signal table is layed
out into 4 seperate blocks specific to SLMP.
</para><code>
The SLMP "ControlBit" signal table/block organizes the single bit NDM signals
sent from the PLC to Vision System. The ControlBit block is 80 bits long.
+----------------+---------+-------+----------+-----------+-----------+------------+-----------+---------+
|                | Bit 7   | Bit 6 | Bit 5    | Bit 4     | Bit 3     | Bit 2      | Bit 1     | Bit 0   |
+----------------+---------+-------+----------+-----------+-----------+------------+-----------+---------+
| 0              | Set     | Clear | Rsvd     | Initiate  | Rsvd      | Rsvd       | Buffer    | Trigger |
|                | Offline | Error |          | Job       |           |            | Results   | Enable  |
|                |         |       |          | Load      |           |            | Enable    |         |
+--------------------------------------------------------------------------------------------------------+
| 1              |                              Rsvd                                                     |
+--------------------------------------------------------------------------------------------------------+
| 2-5            |                              SoftEvent 0-31                                           |
+--------------------------------------------------------------------------------------------------------+
| 6              | Rsvd    | Rsvd  | Rsvd     | Rsvd      | Set User | Clear      | Inspection | Trigger |
|                |         |       |          |           | Data 0   | Exposure   | Results    | Camera  |
|                |         |       |          |           |          | Complete 0 | Ack 0      | 0       |
+--------------------------------------------------------------------------------------------------------+
| 7              | Rsvd    | Rsvd  | Rsvd     | Rsvd      | Set User | Clear      | Inspection | Trigger |
|                |         |       |          |           | Data 1   | Exposure   | Results    | Camera  |
|                |         |       |          |           |          | Complete 1 | Ack 1      | 1       |
+--------------------------------------------------------------------------------------------------------+
| 8              | Rsvd    | Rsvd  | Rsvd     | Rsvd      | Set User | Clear      | Inspection | Trigger |
|                |         |       |          |           | Data 2   | Exposure   | Results    | Camera  |
|                |         |       |          |           |          | Complete 2 | Ack 2      | 2       |
+--------------------------------------------------------------------------------------------------------+
| 9              | Rsvd    | Rsvd  | Rsvd     | Rsvd      | Set User | Clear      | Inspection | Trigger |
|                |         |       |          |           | Data 3   | Exposure   | Results    | Camera  |
|                |         |       |          |           |          | Complete 3 | Ack 3      | 3       |
+--------------------------------------------------------------------------------------------------------+

The SLMP "StatusBit" signal table/block organizes the single bit NDM signals
sent from the Vision System to the PLC.  The StatusBit block is 112 bits long.
+----------------------------------------------------------------------------------------------------------+
¦        ¦ Bit 7     ¦ Bit 6       ¦ Bit 5     ¦ Bit 4       ¦ Bit 3      ¦ Bit 2   ¦ Bit 1    ¦ Bit 0     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 0      ¦ Online    ¦               Offline                 ¦ Rsvd       ¦ Rsvd    ¦ System   ¦ System    ¦
¦        ¦           ¦               Reason                  ¦            ¦         ¦ Busy     ¦ Ready     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 1      ¦ General   ¦ Rsvd        ¦ Job Load  ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Rsvd      ¦
¦        ¦ Fault     ¦             ¦ Completed ¦             ¦            ¦         ¦          ¦           ¦
+----------------------------------------------------------------------------------------------------------+
¦ 2-5    ¦                                  Soft Event Ack 0-31                                            ¦
+----------------------------------------------------------------------------------------------------------+
¦ 6      ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦
¦        ¦ Buffer    ¦ Passed 0    ¦ Valid 0   ¦ Completed 0 ¦ Complete 0 ¦ Error 0 ¦ Ack      ¦ Ready     ¦
¦        ¦ Overrun 0 ¦             ¦           ¦             ¦            ¦         ¦ Camera 0 ¦ Camera 0  ¦
+----------------------------------------------------------------------------------------------------------+
¦ 7      ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 0     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 8      ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦
¦        ¦ Buffer    ¦ Passed 1    ¦ Valid 1   ¦ Completed 1 ¦ Complete 1 ¦ Error 1 ¦ Ack      ¦ Ready     ¦
¦        ¦ Overrun 1 ¦             ¦           ¦             ¦            ¦         ¦ Camera 1 ¦ Camera 1  ¦
+----------------------------------------------------------------------------------------------------------+
¦ 9      ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 1     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 10     ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦
¦        ¦ Buffer    ¦ Passed 2    ¦ Valid 2   ¦ Completed 2 ¦ Complete 2 ¦ Error 2 ¦ Ack      ¦ Ready     ¦
¦        ¦ Overrun 2 ¦             ¦           ¦             ¦            ¦         ¦ Camera 2 ¦ Camera 2  ¦
+----------------------------------------------------------------------------------------------------------+
¦ 11     ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 2     ¦
+----------------------------------------------------------------------------------------------------------+
¦ 12     ¦ Results   ¦ Inspection  ¦ Results   ¦ Inspection  ¦ Exposure   ¦ Acq     ¦ Trigger  ¦ Trigger   ¦
¦        ¦ Buffer    ¦ Passed 3    ¦ Valid 3   ¦ Completed 3 ¦ Complete 3 ¦ Error 3 ¦ Ack      ¦ Ready     ¦
¦        ¦ Overrun 3 ¦             ¦           ¦             ¦            ¦         ¦ Camera 3 ¦ Camera 3  ¦
+----------------------------------------------------------------------------------------------------------+
¦ 13     ¦ Rsvd      ¦ Rsvd        ¦ Rsvd      ¦ Rsvd        ¦ Rsvd       ¦ Rsvd    ¦ Rsvd     ¦ Set       ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ UserData  ¦
¦        ¦           ¦             ¦           ¦             ¦            ¦         ¦          ¦ Ack 3     ¦
+----------------------------------------------------------------------------------------------------------+

The SLMP "StatusWord" signal table/block organizes the word length signals sent from the Vision System to the PLC.
The size of the StatusWord block can vary depending on the size of the inspection results section.
+----------------------------------------------+
¦        ¦             16Bit Word              ¦
+----------------------------------------------+
¦ 0      ¦        Current Job ID               ¦
+----------------------------------------------+
¦ 1      ¦        Error ID                     ¦
+----------------------------------------------+
¦ 2      ¦        Acquisition ID 0             ¦
+----------------------------------------------+
¦ 3      ¦        Inspected Image ID 0         ¦
+----------------------------------------------+
¦ 4      ¦        Inspection Result Code 0     ¦
+----------------------------------------------+
¦ 5      ¦        Acquisition ID 1             ¦
+----------------------------------------------+
¦ 6      ¦        Inspected Image ID 1         ¦
+----------------------------------------------+
¦ 7      ¦        Inspection Result Code 1     ¦
+----------------------------------------------+
¦ 8      ¦        Acquisition ID 2             ¦
+----------------------------------------------+
¦ 9      ¦        Inspected Image ID 2         ¦
+----------------------------------------------+
¦ 10     ¦        Inspection Result Code 2     ¦
+----------------------------------------------+
¦ 11     ¦        Acquisition ID 3             ¦
+----------------------------------------------+
¦ 12     ¦        Inspected Image ID 3         ¦
+----------------------------------------------+
¦ 13     ¦        Inspection Result Code 3     ¦
+----------------------------------------------+
¦ 14-960 ¦        Inspection Results           ¦
+----------------------------------------------+

The SLMP "ControlWord" signal table/block organizes the word length signals sent from the PLC to the Vision System.
The size of the ControlWord block can vary depending on the size of the user data section.
+----------------------------------------------+
¦        ¦             16Bit Word              ¦
+----------------------------------------------+
¦ 0      ¦         Job Load ID                 ¦
+----------------------------------------------+
¦ 1-960  ¦         User Data                   ¦
+----------------------------------------------+

You can use CogNdmSlmpSignalBlockConstants and CogNdmSlmpDeviceConstants to map blocks of NDM signals to
SLMP devices with the CogNdmSlmpBlockMappingCollection class.

The following table describes the SLMP memory block addresses supported on the Q, L, and FX PLCs:

+-------------------------------+--------+----------------+----------------------------------+-----+----+
|          Device Name          | Prefix | Bit/Word based |      Address Representation      | Q/L | FX |
+-------------------------------+--------+----------------+----------------------------------+-----+----+
| Input Relay                   | X      | Bit            | Hex(Q/L Series) Octal(FX series) | X   | X  |
| Output Relay                  | Y      | Bit            | Hex(Q/L Series) Octal(FX series) | X   | X  |
| Internal Relay                | M      | Bit            | Decimal                          | X   | X  |
| Latch Relay                   | L      | Bit            | Decimal                          | X   | -  |
| Annunciator                   | F      | Bit            | Decimal                          | X   | -  |
| Link Relay                    | B      | Bit            | Hex                              | X   | -  |
| State Relay                   | S      | Bit            | Decimal                          | -   | X  |
| Data Register                 | D      | Word           | Decimal                          | X   | X  |
| Link Register                 | W      | Word           | Hex                              | X   | -  |
| File Register                 | R      | Word           | Decimal                          | X   | X  |
| File Register Multiple Blocks | ZR     | Word           | Hex                              | X   | -  |
| Timer                         | TN     | Word           | Decimal                          | X   | X  |
| Counter                       | CN     | Word           | Decimal                          | X   | X  |
+-------------------------------+--------+----------------+----------------------------------+-----+----+

The most commonly used devices used to communicate vision data to a PLC, are the M (Internal Relay) and
D (Data Register) types.
</code></summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmSlmpSignalBlockConstants.ControlWord">
            <summary>
ControlWord is the table/block of word length NDM signals
sent from the PLC to the Vision System. The size of the
ControlWord block can vary depending on the size of the
user data section.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmSlmpSignalBlockConstants.StatusWord">
            <summary>
StatusWord is the table/block of word length NDM signals
sent from the Vision System to the PLC. The size of the 
StatusWord block can vary depending on the size of the 
inspection results section.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmSlmpSignalBlockConstants.StatusBit">
            <summary>
StatusBit is the table/block of single bit NDM signals
sent from the Vision System to the PLC. The StatusBit 
block is 112 bits long.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmSlmpSignalBlockConstants.ControlBit">
            <summary>
ControlBit is the table/block of single bit NDM signals 
sent from the PLC to Vision System. The ControlBit
block is 80 bits long.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogNdmSlmpSignalBlockConstants.None">
            <summary>
None
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogSlmpDeviceConstants">
            <summary>
Enumerates SLMP devices.
<code>
+-------------------------------+--------+----------------+----------------------------------+-----+----+
|          Device Name          | Prefix | Bit/Word based |      Address Representation      | Q/L | FX |
+-------------------------------+--------+----------------+----------------------------------+-----+----+
| Input Relay                   | X      | Bit            | Hex(Q/L Series) Octal(FX series) | X   | X  |
| Output Relay                  | Y      | Bit            | Hex(Q/L Series) Octal(FX series) | X   | X  |
| Internal Relay                | M      | Bit            | Decimal                          | X   | X  |
| Latch Relay                   | L      | Bit            | Decimal                          | X   | -  |
| Annunciator                   | F      | Bit            | Decimal                          | X   | -  |
| Link Relay                    | B      | Bit            | Hex                              | X   | -  |
| State Relay                   | S      | Bit            | Decimal                          | -   | X  |
| Data Register                 | D      | Word           | Decimal                          | X   | X  |
| Link Register                 | W      | Word           | Hex                              | X   | -  |
| File Register                 | R      | Word           | Decimal                          | X   | X  |
| File Register Multiple Blocks | ZR     | Word           | Hex                              | X   | -  |
| Timer                         | TN     | Word           | Decimal                          | X   | X  |
| Counter                       | CN     | Word           | Decimal                          | X   | X  |
+-------------------------------+--------+----------------+----------------------------------+-----+----+
</code></summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpDeviceConstants.StateRelay">
            <summary>
StateRelay
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpDeviceConstants.Timer">
            <summary>
Timer
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpDeviceConstants.Counter">
            <summary>
Counter
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpDeviceConstants.FileRegisterMultipleBlocks">
            <summary>
FileRegisterMultipleBlocks
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpDeviceConstants.FileRegister">
            <summary>
FileRegister
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpDeviceConstants.LinkRegister">
            <summary>
LinkRegister
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpDeviceConstants.DataRegister">
            <summary>
DataRegister
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpDeviceConstants.LinkRelay">
            <summary>
LinkRelay
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpDeviceConstants.Annunciator">
            <summary>
Annunciator
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpDeviceConstants.LatchRelay">
            <summary>
LatchRelay
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpDeviceConstants.InternalRelay">
            <summary>
InternalRelay
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpDeviceConstants.OutputRelay">
            <summary>
OutputRelay
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpDeviceConstants.InputRelay">
            <summary>
InputRelay
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogSlmpRemoteStationDestModuleConstants">
            <summary>
Enumerates SLMP remote station destintation modules
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpRemoteStationDestModuleConstants.Cpu4_0x3e3">
            <summary>
CPU 4 - 0x3e3
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpRemoteStationDestModuleConstants.Cpu3_0x3e2">
            <summary>
CPU 3 -0x3e2
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpRemoteStationDestModuleConstants.Cpu2_0x3e1">
            <summary>
CPU 2 - 0x3e1
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpRemoteStationDestModuleConstants.Cpu1_0x3e0">
            <summary>
CPU 1 - 0x320
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpRemoteStationDestModuleConstants.SystemBCPU_0x3d3">
            <summary>
System B CPU - 0x3d3
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpRemoteStationDestModuleConstants.SystemACPU_0x3d2">
            <summary>
System A CPU - 0x3d2
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpRemoteStationDestModuleConstants.StandbySystemCPU_0x3d1">
            <summary>
Standby System CPU - 0x3d1
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpRemoteStationDestModuleConstants.ControlSystemCPU_0x3d0">
            <summary>
Control System CPU - 0x3d0
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpRemoteStationDestModuleConstants.LocalStation_0x3ff">
            <summary>
Local Station - 0x3ff
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogSlmpMessageFormatConstants">
            <summary>
Enumerates SLMP message formats
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpMessageFormatConstants.QLSeries_3E">
            <summary>
3E SLMP message format
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogSlmpMessageFormatConstants.FXSeries_1E">
            <summary>
1E SLMP message format
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogFfpProtocolConstants">
            <summary>
Enumerates the various types of factory
floor protocols
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogFfpProtocolConstants.Slmp">
            <summary>
The SLMP protocol
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogFfpProtocolConstants.Profinet">
            <summary>
The PROFINET protocol
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogFfpProtocolConstants.EthernetIp">
            <summary>
The EtherNet/IP protocol
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogFfpProtocolConstants.None">
            <summary>
None
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Exceptions.CogFfpInvalidSlmpConfigException">
            <summary>
Thrown by Comm Card Factory Floor Protocol interfaces to indicate invalid
SLMP parameters.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Exceptions.CogFfpInvalidOperationException">
            <summary>
Thrown by Comm Card Factory Floor Protocol interfaces to indicate that 
the current operation is invalid.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Exceptions.CogFfpQueueFullException">
            <summary>
Thrown by Comm Card Factory Floor Protocol interfaces to indicate that an attempt 
to queue or buffer an item has failed.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Exceptions.CogFfpAlreadyQueuedException">
            <summary>
Thrown by Comm Card Factory Floor Protocol interfaces to indicate failures caused
by attempting to queue or buffer an item that has already been queued.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Exceptions.CogFfpConnectionFaultedException">
            <summary>
Thrown by Comm Card Factory Floor Protocol interfaces to indicate an active connection 
has faulted.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Exceptions.CogFfpConnectionRejectedException">
            <summary>
Thrown by Comm Card Factory Floor Protocol interfaces to indicate a connection request 
was rejected by the connection target.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogEthernetPortAccess.Reset">
            <summary>
Dispose any outstanding Ethernet ports.
</summary>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogHardwareInUseException">
Thrown if the hardware is in use by another process.
Only a single process may access the hardware.
When this exception is thrown, you must close any other processes that are
using the hardware, and re-start this process in order to access the hardware.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogIncompatibleFirmwareException">
Thrown if the version of the Comm Card firmware is incompatible with
the version of the host library.
Run "%VPRO_ROOT%\bin\fwuphost.exe --pkg vm56_firmware_X_X_X_X.pkg" to upgrade firmware."
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogEthernetPortAccess.GetActiveEthernetPort(System.Int32)">
            <summary>
Returns a reference to a currently active Ethernet port
object held by the Comm Card, or null if no currently
active Ethernet port object exists for the given index.
<para>
An active Ethernet port will only exist if 
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPortAccess.CreateEthernetPort(System.Int32)" />
has been called previously.
</para></summary>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogHardwareInUseException">
Thrown if the hardware is in use by another process.
Only a single process may access the hardware.
When this exception is thrown, you must close any other processes that are
using the hardware, and re-start this process in order to access the hardware.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogIncompatibleFirmwareException">
Thrown if the version of the Comm Card firmware is incompatible with
the version of the host library.
Run "%VPRO_ROOT%\bin\fwuphost.exe --pkg vm56_firmware_X_X_X_X.pkg" to upgrade firmware."
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogEthernetPortAccess.CreateEthernetPort(System.Int32)">
            <summary>
Creates an Ethernet port object.
<para>
Use the Ethernet port object to configure the properties of an 
Ethernet port of the hardware.
</para><para>
Note that the lifetime of the created object is not related to the 
state of the actual Ethernet interface.
Also note that the created Ethernet port object does not have exclusive
control over the Ethernet port hardware.
This means, for example, that the Ethernet port interface may already
be "up" and running when this method returns.
Or that the properties of the created object may report changed events
that were not instigated via its property setters.
</para></summary>
            <param name="index">
The index of the physical Ethernet port to create the configuration object for.
</param>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogAcqHardwareInUseException">
Thrown if the hardware is already in use by another process.
</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if the index is greater than or equal to NumPorts.
</exception>
            <exception cref="T:System.InvalidOperationException">
Thrown if the Ethernet port has already been created.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogHardwareInUseException">
Thrown if the hardware is in use by another process.
Only a single process may access the hardware.
When this exception is thrown, you must close any other processes that are
using the hardware, and re-start this process in order to access the hardware.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogIncompatibleFirmwareException">
Thrown if the version of the Comm Card firmware is incompatible with
the version of the host library.
Run "%VPRO_ROOT%\bin\fwuphost.exe --pkg vm56_firmware_X_X_X_X.pkg" to upgrade firmware."
</exception>
            <example>
                <!-- CogCommCardEthernetExample -->
                <!-- Shows simple use of comm card API to change Ethernet port settings-->
                <code lang="Visual Basic" />
                <code lang="C#">
using Cognex.VisionPro;
using Cognex.VisionPro.Comm;

// Change the IP address on a Comm Card Ethernet port.
public void ChangeIPAddress(
  string newAddress,
  string newSubnet,
  string newDefaultGateway)
{
CogCommCards commCardCollection = new CogCommCards();

Console.WriteLine("Found: {0} Comm Cards", commCardCollection.Count);
if (commCardCollection.Count == 0) return;

// Get a reference to the the comm card object.
CogCommCard card = commCardCollection[0];

Console.WriteLine("Name: {0}", card.Name);
Console.WriteLine("Serial: {0}", card.SerialNumber);

Console.WriteLine("NumEthernetPorts: {0}", card.EthernetPortAccess.NumPorts);
if (card.EthernetPortAccess.NumPorts == 0) return;

// Create a software object to interact with Ethernet port.
CogEthernetPort etherPort = card.EthernetPortAccess.CreateEthernetPort(0);

Console.WriteLine("Current Ethernet Port Settings:");
Console.WriteLine("  link up: {0}", etherPort.IsLinkUp);
Console.WriteLine("  iface up: {0}", etherPort.IsInterfaceUp);

// Read the persistant settings from the Comm Card.
CogEthernetPortSettings settings = etherPort.ReadSettings();

Console.WriteLine("  ip: {0}", settings.IPAddress);
Console.WriteLine("  subnet: {0}", settings.SubnetMask);
Console.WriteLine("  default gateway: {0}", settings.DefaultGateway);
Console.WriteLine("  host name: {0}", settings.HostName);
Console.WriteLine("  domain name: {0}", settings.DomainName);
Console.WriteLine("  dhcpEnable: {0}", settings.DHCPEnable);

if (etherPort.IsInterfaceUp)
{
  Console.WriteLine("Bringing Interface DOWN...");

  bool timedOut = !etherPort.BringInterfaceDownAsync().Wait(2000);
  if (timedOut)
  {
    Console.WriteLine("Bringing Interface Down TIMED OUT!!");
    return;
  }
  Console.WriteLine("The Interface is DOWN.");
}

Console.WriteLine("Writing new IP address to Comm Card.");

// Change the settings to the new ip address.
settings.IPAddress = IPAddress.Parse(newAddress);
settings.SubnetMask = IPAddress.Parse(newSubnet);
settings.DefaultGateway = IPAddress.Parse(newDefaultGateway);
settings.HostName = "hostname";
settings.DomainName = "";
settings.DHCPEnable = false;

// Write the new settings to the card.
etherPort.WriteSettings(settings);

// Bring up the interface with the new IP address.
if (!etherPort.IsInterfaceUp)
{
  Console.WriteLine("Bringing Interface UP...");

  bool timedOut = !etherPort.BringInterfaceUpAsync().Wait(2000);
  if (timedOut)
  {
    Console.WriteLine("Bringing Interface UP TIMED OUT!!");
    return;
  }
  Console.WriteLine("The Interface is UP.");
}

Console.WriteLine("New Ethernet Port Settings:");
Console.WriteLine("  link up: {0}", etherPort.IsLinkUp);
Console.WriteLine("  iface up: {0}", etherPort.IsInterfaceUp);

// Read the current settings from the Comm Card.
settings = etherPort.ReadActiveSettings();

Console.WriteLine("  ip: {0}", settings.IPAddress);
Console.WriteLine("  subnet: {0}", settings.SubnetMask);
Console.WriteLine("  default gateway: {0}", settings.DefaultGateway);
Console.WriteLine("  host name: {0}", settings.HostName);
Console.WriteLine("  domain name: {0}", settings.DomainName);
Console.WriteLine("  dhcpEnable: {0}", settings.DHCPEnable);
}


------
Output
------

Found: 1 Comm Cards
Name: Cognex Communications Card 24C
Serial: 1A1410XN002183
NumEthernetPorts: 1
Current Ethernet Port Settings:
  link up: False
  iface up: True
  ip: 192.168.1.42
  subnet: 255.255.0.0
  default gateway: 192.168.1.3
  host name: HostName
  domain name: 
  dhcpEnable: False
Bringing Interface DOWN...
The Interface is DOWN.
Writing new IP address to Comm Card.
Bringing Interface UP...
The Interface is UP.
New Ethernet Port Settings:
  link up: False
  iface up: True
  ip: 192.168.1.100
  subnet: 255.255.255.255
  default gateway: 192.168.1.1
  host name: hostname
  domain name: 
  dhcpEnable: False
</code>
            </example>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogEthernetPortAccess.NumPorts">
            <summary>
Gets the number of physical Ethernet ports on the hardware.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogEthernetPortAccess.#ctor(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Construct a dummy object with no underlying module
interface that will throw exceptions when its methods
are called.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogEthernetPortAccess.#ctor(ccIBoard_NetConfig_v0*,ccIBoard_NetConfig_v1*)">
            <summary>
Construct a VisionPro Ethernet port access object.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogEthernetPortAccess">
            <summary>
Instances of CogEthernetPortAccess class are held by the 
<see cref="T:Cognex.VisionPro.Comm.CogCommCard" /> class.
<para>
Use 
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPortAccess.CreateEthernetPort(System.Int32)" />
to factory/initialize instances of the CogEthernetPort.
</para></summary>
            <example>
                <!-- CogCommCardEthernetExample -->
                <!-- Shows simple use of comm card API to change Ethernet port settings-->
                <code lang="Visual Basic" />
                <code lang="C#">
using Cognex.VisionPro;
using Cognex.VisionPro.Comm;

// Change the IP address on a Comm Card Ethernet port.
public void ChangeIPAddress(
  string newAddress,
  string newSubnet,
  string newDefaultGateway)
{
CogCommCards commCardCollection = new CogCommCards();

Console.WriteLine("Found: {0} Comm Cards", commCardCollection.Count);
if (commCardCollection.Count == 0) return;

// Get a reference to the the comm card object.
CogCommCard card = commCardCollection[0];

Console.WriteLine("Name: {0}", card.Name);
Console.WriteLine("Serial: {0}", card.SerialNumber);

Console.WriteLine("NumEthernetPorts: {0}", card.EthernetPortAccess.NumPorts);
if (card.EthernetPortAccess.NumPorts == 0) return;

// Create a software object to interact with Ethernet port.
CogEthernetPort etherPort = card.EthernetPortAccess.CreateEthernetPort(0);

Console.WriteLine("Current Ethernet Port Settings:");
Console.WriteLine("  link up: {0}", etherPort.IsLinkUp);
Console.WriteLine("  iface up: {0}", etherPort.IsInterfaceUp);

// Read the persistant settings from the Comm Card.
CogEthernetPortSettings settings = etherPort.ReadSettings();

Console.WriteLine("  ip: {0}", settings.IPAddress);
Console.WriteLine("  subnet: {0}", settings.SubnetMask);
Console.WriteLine("  default gateway: {0}", settings.DefaultGateway);
Console.WriteLine("  host name: {0}", settings.HostName);
Console.WriteLine("  domain name: {0}", settings.DomainName);
Console.WriteLine("  dhcpEnable: {0}", settings.DHCPEnable);

if (etherPort.IsInterfaceUp)
{
  Console.WriteLine("Bringing Interface DOWN...");

  bool timedOut = !etherPort.BringInterfaceDownAsync().Wait(2000);
  if (timedOut)
  {
    Console.WriteLine("Bringing Interface Down TIMED OUT!!");
    return;
  }
  Console.WriteLine("The Interface is DOWN.");
}

Console.WriteLine("Writing new IP address to Comm Card.");

// Change the settings to the new ip address.
settings.IPAddress = IPAddress.Parse(newAddress);
settings.SubnetMask = IPAddress.Parse(newSubnet);
settings.DefaultGateway = IPAddress.Parse(newDefaultGateway);
settings.HostName = "hostname";
settings.DomainName = "";
settings.DHCPEnable = false;

// Write the new settings to the card.
etherPort.WriteSettings(settings);

// Bring up the interface with the new IP address.
if (!etherPort.IsInterfaceUp)
{
  Console.WriteLine("Bringing Interface UP...");

  bool timedOut = !etherPort.BringInterfaceUpAsync().Wait(2000);
  if (timedOut)
  {
    Console.WriteLine("Bringing Interface UP TIMED OUT!!");
    return;
  }
  Console.WriteLine("The Interface is UP.");
}

Console.WriteLine("New Ethernet Port Settings:");
Console.WriteLine("  link up: {0}", etherPort.IsLinkUp);
Console.WriteLine("  iface up: {0}", etherPort.IsInterfaceUp);

// Read the current settings from the Comm Card.
settings = etherPort.ReadActiveSettings();

Console.WriteLine("  ip: {0}", settings.IPAddress);
Console.WriteLine("  subnet: {0}", settings.SubnetMask);
Console.WriteLine("  default gateway: {0}", settings.DefaultGateway);
Console.WriteLine("  host name: {0}", settings.HostName);
Console.WriteLine("  domain name: {0}", settings.DomainName);
Console.WriteLine("  dhcpEnable: {0}", settings.DHCPEnable);
}


------
Output
------

Found: 1 Comm Cards
Name: Cognex Communications Card 24C
Serial: 1A1410XN002183
NumEthernetPorts: 1
Current Ethernet Port Settings:
  link up: False
  iface up: True
  ip: 192.168.1.42
  subnet: 255.255.0.0
  default gateway: 192.168.1.3
  host name: HostName
  domain name: 
  dhcpEnable: False
Bringing Interface DOWN...
The Interface is DOWN.
Writing new IP address to Comm Card.
Bringing Interface UP...
The Interface is UP.
New Ethernet Port Settings:
  link up: False
  iface up: True
  ip: 192.168.1.100
  subnet: 255.255.255.255
  default gateway: 192.168.1.1
  host name: hostname
  domain name: 
  dhcpEnable: False
</code>
            </example>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogEthernetPort.ReadActiveSettings">
            <summary>
Returns the "active" Ethernet port settings from the hardware.
<para /></summary>
            <remarks>
                <para>
Ethernet settings are written to the Comm Card using
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.WriteSettings(Cognex.VisionPro.Comm.CogEthernetPortSettings)" />.
These settings are stored in flash memory directly on the Comm Card.
</para>
                <para>
When a VisionPro application first connects to a Comm Card, the Comm Card
automatically attempts to bring the Ethernet port interface "UP" using the 
stored settings. Later, when the VisionPro application exits, the Comm Card 
will automatically bring the Interface "DOWN", removing the card from the 
network.
</para>
                <para>
Both the Link (physical connection present) and the Interface (IP settings
activated) need to be in the "UP" state for the Ethernet port to participate
in an IP network. When the link or interface is "DOWN", the Ethernet port
cannot communicate over an IP network.
</para>
                <para>
Use
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPort.IsLinkUp" />
to see if the Link is in the "UP" state. When the Link is up, the Ethenet port
is physically connected to a network and can physically transmit and receive data.
</para>
                <para>
Use
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPort.IsInterfaceUp" />
to see if the Interface is in the "UP" state. When the Interface is up, the Ethernet port
has been activated with IP network settings and can participate in an IP network.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.WriteSettings(Cognex.VisionPro.Comm.CogEthernetPortSettings)" />
and
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.ReadSettings" />
to read and write network settings to the Comm Card.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceUpAsync" />
and
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceDownAsync" />
to manually bring the interface "UP" and "DOWN" using the settings stored on the Card.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.ReadActiveSettings" />
to read the currently active settings while the Interface is "UP".
The currently active settings may be different from the settings stored on the card
in cases where the card is configured for DHCP, or if something (i.e. PROFINET) changes
the active settings without also writing them to the storage location on the card.
</para>
                <para>
Note that CogEthernetPort does not have exclusive control over the Ethernet port
hardware. The Ethernet port interface may already be "UP" when a CogEthernetPort is
created. Furthermore, the state of the Ethernet interface may report changes and 
events that were _not_ initiated from user calls into its own properties and methods.
</para>
                <para>
Note also that the lifetime of this object is not related to the state ("UP" or "DOWN")
of the Ethernet port interface. Disposing the CogEthernetPort object will not affect
the state of actual Ethernet settings running on the card (even though exiting 
the _process_ will bring the network interface "DOWN").
</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">
Thrown if interface is in "DOWN" state.
</exception>
            <example>
                <!-- CogCommCardEthernetExample -->
                <!-- Shows simple use of comm card API to change Ethernet port settings-->
                <code lang="Visual Basic" />
                <code lang="C#">
using Cognex.VisionPro;
using Cognex.VisionPro.Comm;

// Change the IP address on a Comm Card Ethernet port.
public void ChangeIPAddress(
  string newAddress,
  string newSubnet,
  string newDefaultGateway)
{
CogCommCards commCardCollection = new CogCommCards();

Console.WriteLine("Found: {0} Comm Cards", commCardCollection.Count);
if (commCardCollection.Count == 0) return;

// Get a reference to the the comm card object.
CogCommCard card = commCardCollection[0];

Console.WriteLine("Name: {0}", card.Name);
Console.WriteLine("Serial: {0}", card.SerialNumber);

Console.WriteLine("NumEthernetPorts: {0}", card.EthernetPortAccess.NumPorts);
if (card.EthernetPortAccess.NumPorts == 0) return;

// Create a software object to interact with Ethernet port.
CogEthernetPort etherPort = card.EthernetPortAccess.CreateEthernetPort(0);

Console.WriteLine("Current Ethernet Port Settings:");
Console.WriteLine("  link up: {0}", etherPort.IsLinkUp);
Console.WriteLine("  iface up: {0}", etherPort.IsInterfaceUp);

// Read the persistant settings from the Comm Card.
CogEthernetPortSettings settings = etherPort.ReadSettings();

Console.WriteLine("  ip: {0}", settings.IPAddress);
Console.WriteLine("  subnet: {0}", settings.SubnetMask);
Console.WriteLine("  default gateway: {0}", settings.DefaultGateway);
Console.WriteLine("  host name: {0}", settings.HostName);
Console.WriteLine("  domain name: {0}", settings.DomainName);
Console.WriteLine("  dhcpEnable: {0}", settings.DHCPEnable);

if (etherPort.IsInterfaceUp)
{
  Console.WriteLine("Bringing Interface DOWN...");

  bool timedOut = !etherPort.BringInterfaceDownAsync().Wait(2000);
  if (timedOut)
  {
    Console.WriteLine("Bringing Interface Down TIMED OUT!!");
    return;
  }
  Console.WriteLine("The Interface is DOWN.");
}

Console.WriteLine("Writing new IP address to Comm Card.");

// Change the settings to the new ip address.
settings.IPAddress = IPAddress.Parse(newAddress);
settings.SubnetMask = IPAddress.Parse(newSubnet);
settings.DefaultGateway = IPAddress.Parse(newDefaultGateway);
settings.HostName = "hostname";
settings.DomainName = "";
settings.DHCPEnable = false;

// Write the new settings to the card.
etherPort.WriteSettings(settings);

// Bring up the interface with the new IP address.
if (!etherPort.IsInterfaceUp)
{
  Console.WriteLine("Bringing Interface UP...");

  bool timedOut = !etherPort.BringInterfaceUpAsync().Wait(2000);
  if (timedOut)
  {
    Console.WriteLine("Bringing Interface UP TIMED OUT!!");
    return;
  }
  Console.WriteLine("The Interface is UP.");
}

Console.WriteLine("New Ethernet Port Settings:");
Console.WriteLine("  link up: {0}", etherPort.IsLinkUp);
Console.WriteLine("  iface up: {0}", etherPort.IsInterfaceUp);

// Read the current settings from the Comm Card.
settings = etherPort.ReadActiveSettings();

Console.WriteLine("  ip: {0}", settings.IPAddress);
Console.WriteLine("  subnet: {0}", settings.SubnetMask);
Console.WriteLine("  default gateway: {0}", settings.DefaultGateway);
Console.WriteLine("  host name: {0}", settings.HostName);
Console.WriteLine("  domain name: {0}", settings.DomainName);
Console.WriteLine("  dhcpEnable: {0}", settings.DHCPEnable);
}


------
Output
------

Found: 1 Comm Cards
Name: Cognex Communications Card 24C
Serial: 1A1410XN002183
NumEthernetPorts: 1
Current Ethernet Port Settings:
  link up: False
  iface up: True
  ip: 192.168.1.42
  subnet: 255.255.0.0
  default gateway: 192.168.1.3
  host name: HostName
  domain name: 
  dhcpEnable: False
Bringing Interface DOWN...
The Interface is DOWN.
Writing new IP address to Comm Card.
Bringing Interface UP...
The Interface is UP.
New Ethernet Port Settings:
  link up: False
  iface up: True
  ip: 192.168.1.100
  subnet: 255.255.255.255
  default gateway: 192.168.1.1
  host name: hostname
  domain name: 
  dhcpEnable: False
</code>
            </example>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogEthernetPort.WriteSettings(Cognex.VisionPro.Comm.CogEthernetPortSettings)">
            <summary>
Writes the Ethernet port settings to storage on the hardware.
<para>
You must call
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceDownAsync" />
followed by <see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceUpAsync" />
(or restart your application) for the new settings to actually take effect
on the network.
</para></summary>
            <remarks>
                <para>
Ethernet settings are written to the Comm Card using
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.WriteSettings(Cognex.VisionPro.Comm.CogEthernetPortSettings)" />.
These settings are stored in flash memory directly on the Comm Card.
</para>
                <para>
When a VisionPro application first connects to a Comm Card, the Comm Card
automatically attempts to bring the Ethernet port interface "UP" using the 
stored settings. Later, when the VisionPro application exits, the Comm Card 
will automatically bring the Interface "DOWN", removing the card from the 
network.
</para>
                <para>
Both the Link (physical connection present) and the Interface (IP settings
activated) need to be in the "UP" state for the Ethernet port to participate
in an IP network. When the link or interface is "DOWN", the Ethernet port
cannot communicate over an IP network.
</para>
                <para>
Use
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPort.IsLinkUp" />
to see if the Link is in the "UP" state. When the Link is up, the Ethenet port
is physically connected to a network and can physically transmit and receive data.
</para>
                <para>
Use
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPort.IsInterfaceUp" />
to see if the Interface is in the "UP" state. When the Interface is up, the Ethernet port
has been activated with IP network settings and can participate in an IP network.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.WriteSettings(Cognex.VisionPro.Comm.CogEthernetPortSettings)" />
and
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.ReadSettings" />
to read and write network settings to the Comm Card.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceUpAsync" />
and
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceDownAsync" />
to manually bring the interface "UP" and "DOWN" using the settings stored on the Card.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.ReadActiveSettings" />
to read the currently active settings while the Interface is "UP".
The currently active settings may be different from the settings stored on the card
in cases where the card is configured for DHCP, or if something (i.e. PROFINET) changes
the active settings without also writing them to the storage location on the card.
</para>
                <para>
Note that CogEthernetPort does not have exclusive control over the Ethernet port
hardware. The Ethernet port interface may already be "UP" when a CogEthernetPort is
created. Furthermore, the state of the Ethernet interface may report changes and 
events that were _not_ initiated from user calls into its own properties and methods.
</para>
                <para>
Note also that the lifetime of this object is not related to the state ("UP" or "DOWN")
of the Ethernet port interface. Disposing the CogEthernetPort object will not affect
the state of actual Ethernet settings running on the card (even though exiting 
the _process_ will bring the network interface "DOWN").
</para>
            </remarks>
            <exception cref="T:System.ArgumentException">
The domain name must be either null, or the empty string.
</exception>
            <example>
                <!-- CogCommCardEthernetExample -->
                <!-- Shows simple use of comm card API to change Ethernet port settings-->
                <code lang="Visual Basic" />
                <code lang="C#">
using Cognex.VisionPro;
using Cognex.VisionPro.Comm;

// Change the IP address on a Comm Card Ethernet port.
public void ChangeIPAddress(
  string newAddress,
  string newSubnet,
  string newDefaultGateway)
{
CogCommCards commCardCollection = new CogCommCards();

Console.WriteLine("Found: {0} Comm Cards", commCardCollection.Count);
if (commCardCollection.Count == 0) return;

// Get a reference to the the comm card object.
CogCommCard card = commCardCollection[0];

Console.WriteLine("Name: {0}", card.Name);
Console.WriteLine("Serial: {0}", card.SerialNumber);

Console.WriteLine("NumEthernetPorts: {0}", card.EthernetPortAccess.NumPorts);
if (card.EthernetPortAccess.NumPorts == 0) return;

// Create a software object to interact with Ethernet port.
CogEthernetPort etherPort = card.EthernetPortAccess.CreateEthernetPort(0);

Console.WriteLine("Current Ethernet Port Settings:");
Console.WriteLine("  link up: {0}", etherPort.IsLinkUp);
Console.WriteLine("  iface up: {0}", etherPort.IsInterfaceUp);

// Read the persistant settings from the Comm Card.
CogEthernetPortSettings settings = etherPort.ReadSettings();

Console.WriteLine("  ip: {0}", settings.IPAddress);
Console.WriteLine("  subnet: {0}", settings.SubnetMask);
Console.WriteLine("  default gateway: {0}", settings.DefaultGateway);
Console.WriteLine("  host name: {0}", settings.HostName);
Console.WriteLine("  domain name: {0}", settings.DomainName);
Console.WriteLine("  dhcpEnable: {0}", settings.DHCPEnable);

if (etherPort.IsInterfaceUp)
{
  Console.WriteLine("Bringing Interface DOWN...");

  bool timedOut = !etherPort.BringInterfaceDownAsync().Wait(2000);
  if (timedOut)
  {
    Console.WriteLine("Bringing Interface Down TIMED OUT!!");
    return;
  }
  Console.WriteLine("The Interface is DOWN.");
}

Console.WriteLine("Writing new IP address to Comm Card.");

// Change the settings to the new ip address.
settings.IPAddress = IPAddress.Parse(newAddress);
settings.SubnetMask = IPAddress.Parse(newSubnet);
settings.DefaultGateway = IPAddress.Parse(newDefaultGateway);
settings.HostName = "hostname";
settings.DomainName = "";
settings.DHCPEnable = false;

// Write the new settings to the card.
etherPort.WriteSettings(settings);

// Bring up the interface with the new IP address.
if (!etherPort.IsInterfaceUp)
{
  Console.WriteLine("Bringing Interface UP...");

  bool timedOut = !etherPort.BringInterfaceUpAsync().Wait(2000);
  if (timedOut)
  {
    Console.WriteLine("Bringing Interface UP TIMED OUT!!");
    return;
  }
  Console.WriteLine("The Interface is UP.");
}

Console.WriteLine("New Ethernet Port Settings:");
Console.WriteLine("  link up: {0}", etherPort.IsLinkUp);
Console.WriteLine("  iface up: {0}", etherPort.IsInterfaceUp);

// Read the current settings from the Comm Card.
settings = etherPort.ReadActiveSettings();

Console.WriteLine("  ip: {0}", settings.IPAddress);
Console.WriteLine("  subnet: {0}", settings.SubnetMask);
Console.WriteLine("  default gateway: {0}", settings.DefaultGateway);
Console.WriteLine("  host name: {0}", settings.HostName);
Console.WriteLine("  domain name: {0}", settings.DomainName);
Console.WriteLine("  dhcpEnable: {0}", settings.DHCPEnable);
}


------
Output
------

Found: 1 Comm Cards
Name: Cognex Communications Card 24C
Serial: 1A1410XN002183
NumEthernetPorts: 1
Current Ethernet Port Settings:
  link up: False
  iface up: True
  ip: 192.168.1.42
  subnet: 255.255.0.0
  default gateway: 192.168.1.3
  host name: HostName
  domain name: 
  dhcpEnable: False
Bringing Interface DOWN...
The Interface is DOWN.
Writing new IP address to Comm Card.
Bringing Interface UP...
The Interface is UP.
New Ethernet Port Settings:
  link up: False
  iface up: True
  ip: 192.168.1.100
  subnet: 255.255.255.255
  default gateway: 192.168.1.1
  host name: hostname
  domain name: 
  dhcpEnable: False
</code>
            </example>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogEthernetPort.ReadSettings">
            <summary>
Returns the Ethernet port settings stored on the hardware.
</summary>
            <remarks>
                <para>
Ethernet settings are written to the Comm Card using
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.WriteSettings(Cognex.VisionPro.Comm.CogEthernetPortSettings)" />.
These settings are stored in flash memory directly on the Comm Card.
</para>
                <para>
When a VisionPro application first connects to a Comm Card, the Comm Card
automatically attempts to bring the Ethernet port interface "UP" using the 
stored settings. Later, when the VisionPro application exits, the Comm Card 
will automatically bring the Interface "DOWN", removing the card from the 
network.
</para>
                <para>
Both the Link (physical connection present) and the Interface (IP settings
activated) need to be in the "UP" state for the Ethernet port to participate
in an IP network. When the link or interface is "DOWN", the Ethernet port
cannot communicate over an IP network.
</para>
                <para>
Use
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPort.IsLinkUp" />
to see if the Link is in the "UP" state. When the Link is up, the Ethenet port
is physically connected to a network and can physically transmit and receive data.
</para>
                <para>
Use
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPort.IsInterfaceUp" />
to see if the Interface is in the "UP" state. When the Interface is up, the Ethernet port
has been activated with IP network settings and can participate in an IP network.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.WriteSettings(Cognex.VisionPro.Comm.CogEthernetPortSettings)" />
and
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.ReadSettings" />
to read and write network settings to the Comm Card.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceUpAsync" />
and
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceDownAsync" />
to manually bring the interface "UP" and "DOWN" using the settings stored on the Card.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.ReadActiveSettings" />
to read the currently active settings while the Interface is "UP".
The currently active settings may be different from the settings stored on the card
in cases where the card is configured for DHCP, or if something (i.e. PROFINET) changes
the active settings without also writing them to the storage location on the card.
</para>
                <para>
Note that CogEthernetPort does not have exclusive control over the Ethernet port
hardware. The Ethernet port interface may already be "UP" when a CogEthernetPort is
created. Furthermore, the state of the Ethernet interface may report changes and 
events that were _not_ initiated from user calls into its own properties and methods.
</para>
                <para>
Note also that the lifetime of this object is not related to the state ("UP" or "DOWN")
of the Ethernet port interface. Disposing the CogEthernetPort object will not affect
the state of actual Ethernet settings running on the card (even though exiting 
the _process_ will bring the network interface "DOWN").
</para>
            </remarks>
            <example>
                <!-- CogCommCardEthernetExample -->
                <!-- Shows simple use of comm card API to change Ethernet port settings-->
                <code lang="Visual Basic" />
                <code lang="C#">
using Cognex.VisionPro;
using Cognex.VisionPro.Comm;

// Change the IP address on a Comm Card Ethernet port.
public void ChangeIPAddress(
  string newAddress,
  string newSubnet,
  string newDefaultGateway)
{
CogCommCards commCardCollection = new CogCommCards();

Console.WriteLine("Found: {0} Comm Cards", commCardCollection.Count);
if (commCardCollection.Count == 0) return;

// Get a reference to the the comm card object.
CogCommCard card = commCardCollection[0];

Console.WriteLine("Name: {0}", card.Name);
Console.WriteLine("Serial: {0}", card.SerialNumber);

Console.WriteLine("NumEthernetPorts: {0}", card.EthernetPortAccess.NumPorts);
if (card.EthernetPortAccess.NumPorts == 0) return;

// Create a software object to interact with Ethernet port.
CogEthernetPort etherPort = card.EthernetPortAccess.CreateEthernetPort(0);

Console.WriteLine("Current Ethernet Port Settings:");
Console.WriteLine("  link up: {0}", etherPort.IsLinkUp);
Console.WriteLine("  iface up: {0}", etherPort.IsInterfaceUp);

// Read the persistant settings from the Comm Card.
CogEthernetPortSettings settings = etherPort.ReadSettings();

Console.WriteLine("  ip: {0}", settings.IPAddress);
Console.WriteLine("  subnet: {0}", settings.SubnetMask);
Console.WriteLine("  default gateway: {0}", settings.DefaultGateway);
Console.WriteLine("  host name: {0}", settings.HostName);
Console.WriteLine("  domain name: {0}", settings.DomainName);
Console.WriteLine("  dhcpEnable: {0}", settings.DHCPEnable);

if (etherPort.IsInterfaceUp)
{
  Console.WriteLine("Bringing Interface DOWN...");

  bool timedOut = !etherPort.BringInterfaceDownAsync().Wait(2000);
  if (timedOut)
  {
    Console.WriteLine("Bringing Interface Down TIMED OUT!!");
    return;
  }
  Console.WriteLine("The Interface is DOWN.");
}

Console.WriteLine("Writing new IP address to Comm Card.");

// Change the settings to the new ip address.
settings.IPAddress = IPAddress.Parse(newAddress);
settings.SubnetMask = IPAddress.Parse(newSubnet);
settings.DefaultGateway = IPAddress.Parse(newDefaultGateway);
settings.HostName = "hostname";
settings.DomainName = "";
settings.DHCPEnable = false;

// Write the new settings to the card.
etherPort.WriteSettings(settings);

// Bring up the interface with the new IP address.
if (!etherPort.IsInterfaceUp)
{
  Console.WriteLine("Bringing Interface UP...");

  bool timedOut = !etherPort.BringInterfaceUpAsync().Wait(2000);
  if (timedOut)
  {
    Console.WriteLine("Bringing Interface UP TIMED OUT!!");
    return;
  }
  Console.WriteLine("The Interface is UP.");
}

Console.WriteLine("New Ethernet Port Settings:");
Console.WriteLine("  link up: {0}", etherPort.IsLinkUp);
Console.WriteLine("  iface up: {0}", etherPort.IsInterfaceUp);

// Read the current settings from the Comm Card.
settings = etherPort.ReadActiveSettings();

Console.WriteLine("  ip: {0}", settings.IPAddress);
Console.WriteLine("  subnet: {0}", settings.SubnetMask);
Console.WriteLine("  default gateway: {0}", settings.DefaultGateway);
Console.WriteLine("  host name: {0}", settings.HostName);
Console.WriteLine("  domain name: {0}", settings.DomainName);
Console.WriteLine("  dhcpEnable: {0}", settings.DHCPEnable);
}


------
Output
------

Found: 1 Comm Cards
Name: Cognex Communications Card 24C
Serial: 1A1410XN002183
NumEthernetPorts: 1
Current Ethernet Port Settings:
  link up: False
  iface up: True
  ip: 192.168.1.42
  subnet: 255.255.0.0
  default gateway: 192.168.1.3
  host name: HostName
  domain name: 
  dhcpEnable: False
Bringing Interface DOWN...
The Interface is DOWN.
Writing new IP address to Comm Card.
Bringing Interface UP...
The Interface is UP.
New Ethernet Port Settings:
  link up: False
  iface up: True
  ip: 192.168.1.100
  subnet: 255.255.255.255
  default gateway: 192.168.1.1
  host name: hostname
  domain name: 
  dhcpEnable: False
</code>
            </example>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceDownAsync">
            <summary>
Manually bring down the Ethernet port interface.
<para>
This method returns immediately. You can wait on the returned task to be notified       
when the interface actually comes down. The task completes the next time the 
interface comes down. Note that if the interface is already down the task will never
complete. This makes it important to include a timeout when waiting on the returned task.
</para></summary>
            <remarks>
                <para>
Ethernet settings are written to the Comm Card using
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.WriteSettings(Cognex.VisionPro.Comm.CogEthernetPortSettings)" />.
These settings are stored in flash memory directly on the Comm Card.
</para>
                <para>
When a VisionPro application first connects to a Comm Card, the Comm Card
automatically attempts to bring the Ethernet port interface "UP" using the 
stored settings. Later, when the VisionPro application exits, the Comm Card 
will automatically bring the Interface "DOWN", removing the card from the 
network.
</para>
                <para>
Both the Link (physical connection present) and the Interface (IP settings
activated) need to be in the "UP" state for the Ethernet port to participate
in an IP network. When the link or interface is "DOWN", the Ethernet port
cannot communicate over an IP network.
</para>
                <para>
Use
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPort.IsLinkUp" />
to see if the Link is in the "UP" state. When the Link is up, the Ethenet port
is physically connected to a network and can physically transmit and receive data.
</para>
                <para>
Use
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPort.IsInterfaceUp" />
to see if the Interface is in the "UP" state. When the Interface is up, the Ethernet port
has been activated with IP network settings and can participate in an IP network.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.WriteSettings(Cognex.VisionPro.Comm.CogEthernetPortSettings)" />
and
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.ReadSettings" />
to read and write network settings to the Comm Card.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceUpAsync" />
and
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceDownAsync" />
to manually bring the interface "UP" and "DOWN" using the settings stored on the Card.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.ReadActiveSettings" />
to read the currently active settings while the Interface is "UP".
The currently active settings may be different from the settings stored on the card
in cases where the card is configured for DHCP, or if something (i.e. PROFINET) changes
the active settings without also writing them to the storage location on the card.
</para>
                <para>
Note that CogEthernetPort does not have exclusive control over the Ethernet port
hardware. The Ethernet port interface may already be "UP" when a CogEthernetPort is
created. Furthermore, the state of the Ethernet interface may report changes and 
events that were _not_ initiated from user calls into its own properties and methods.
</para>
                <para>
Note also that the lifetime of this object is not related to the state ("UP" or "DOWN")
of the Ethernet port interface. Disposing the CogEthernetPort object will not affect
the state of actual Ethernet settings running on the card (even though exiting 
the _process_ will bring the network interface "DOWN").
</para>
            </remarks>
            <example>
                <!-- CogCommCardEthernetExample -->
                <!-- Shows simple use of comm card API to change Ethernet port settings-->
                <code lang="Visual Basic" />
                <code lang="C#">
using Cognex.VisionPro;
using Cognex.VisionPro.Comm;

// Change the IP address on a Comm Card Ethernet port.
public void ChangeIPAddress(
  string newAddress,
  string newSubnet,
  string newDefaultGateway)
{
CogCommCards commCardCollection = new CogCommCards();

Console.WriteLine("Found: {0} Comm Cards", commCardCollection.Count);
if (commCardCollection.Count == 0) return;

// Get a reference to the the comm card object.
CogCommCard card = commCardCollection[0];

Console.WriteLine("Name: {0}", card.Name);
Console.WriteLine("Serial: {0}", card.SerialNumber);

Console.WriteLine("NumEthernetPorts: {0}", card.EthernetPortAccess.NumPorts);
if (card.EthernetPortAccess.NumPorts == 0) return;

// Create a software object to interact with Ethernet port.
CogEthernetPort etherPort = card.EthernetPortAccess.CreateEthernetPort(0);

Console.WriteLine("Current Ethernet Port Settings:");
Console.WriteLine("  link up: {0}", etherPort.IsLinkUp);
Console.WriteLine("  iface up: {0}", etherPort.IsInterfaceUp);

// Read the persistant settings from the Comm Card.
CogEthernetPortSettings settings = etherPort.ReadSettings();

Console.WriteLine("  ip: {0}", settings.IPAddress);
Console.WriteLine("  subnet: {0}", settings.SubnetMask);
Console.WriteLine("  default gateway: {0}", settings.DefaultGateway);
Console.WriteLine("  host name: {0}", settings.HostName);
Console.WriteLine("  domain name: {0}", settings.DomainName);
Console.WriteLine("  dhcpEnable: {0}", settings.DHCPEnable);

if (etherPort.IsInterfaceUp)
{
  Console.WriteLine("Bringing Interface DOWN...");

  bool timedOut = !etherPort.BringInterfaceDownAsync().Wait(2000);
  if (timedOut)
  {
    Console.WriteLine("Bringing Interface Down TIMED OUT!!");
    return;
  }
  Console.WriteLine("The Interface is DOWN.");
}

Console.WriteLine("Writing new IP address to Comm Card.");

// Change the settings to the new ip address.
settings.IPAddress = IPAddress.Parse(newAddress);
settings.SubnetMask = IPAddress.Parse(newSubnet);
settings.DefaultGateway = IPAddress.Parse(newDefaultGateway);
settings.HostName = "hostname";
settings.DomainName = "";
settings.DHCPEnable = false;

// Write the new settings to the card.
etherPort.WriteSettings(settings);

// Bring up the interface with the new IP address.
if (!etherPort.IsInterfaceUp)
{
  Console.WriteLine("Bringing Interface UP...");

  bool timedOut = !etherPort.BringInterfaceUpAsync().Wait(2000);
  if (timedOut)
  {
    Console.WriteLine("Bringing Interface UP TIMED OUT!!");
    return;
  }
  Console.WriteLine("The Interface is UP.");
}

Console.WriteLine("New Ethernet Port Settings:");
Console.WriteLine("  link up: {0}", etherPort.IsLinkUp);
Console.WriteLine("  iface up: {0}", etherPort.IsInterfaceUp);

// Read the current settings from the Comm Card.
settings = etherPort.ReadActiveSettings();

Console.WriteLine("  ip: {0}", settings.IPAddress);
Console.WriteLine("  subnet: {0}", settings.SubnetMask);
Console.WriteLine("  default gateway: {0}", settings.DefaultGateway);
Console.WriteLine("  host name: {0}", settings.HostName);
Console.WriteLine("  domain name: {0}", settings.DomainName);
Console.WriteLine("  dhcpEnable: {0}", settings.DHCPEnable);
}


------
Output
------

Found: 1 Comm Cards
Name: Cognex Communications Card 24C
Serial: 1A1410XN002183
NumEthernetPorts: 1
Current Ethernet Port Settings:
  link up: False
  iface up: True
  ip: 192.168.1.42
  subnet: 255.255.0.0
  default gateway: 192.168.1.3
  host name: HostName
  domain name: 
  dhcpEnable: False
Bringing Interface DOWN...
The Interface is DOWN.
Writing new IP address to Comm Card.
Bringing Interface UP...
The Interface is UP.
New Ethernet Port Settings:
  link up: False
  iface up: True
  ip: 192.168.1.100
  subnet: 255.255.255.255
  default gateway: 192.168.1.1
  host name: hostname
  domain name: 
  dhcpEnable: False
</code>
            </example>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceUpAsync">
            <summary>
Manually bring up the Ethernet port interface using the Comm Card's stored
network settings.
<para>
This method returns immediately. You can wait on the returned task to be notified       
when the interface actually comes up. The task completes the next time the 
interface comes up.  Note that if the interface never comes up the task will never
complete. This may happen if DHCP is unable to resolve the settings.
This makes it important to include a timeout when waiting on the returned task.
</para></summary>
            <remarks>
                <para>
Ethernet settings are written to the Comm Card using
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.WriteSettings(Cognex.VisionPro.Comm.CogEthernetPortSettings)" />.
These settings are stored in flash memory directly on the Comm Card.
</para>
                <para>
When a VisionPro application first connects to a Comm Card, the Comm Card
automatically attempts to bring the Ethernet port interface "UP" using the 
stored settings. Later, when the VisionPro application exits, the Comm Card 
will automatically bring the Interface "DOWN", removing the card from the 
network.
</para>
                <para>
Both the Link (physical connection present) and the Interface (IP settings
activated) need to be in the "UP" state for the Ethernet port to participate
in an IP network. When the link or interface is "DOWN", the Ethernet port
cannot communicate over an IP network.
</para>
                <para>
Use
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPort.IsLinkUp" />
to see if the Link is in the "UP" state. When the Link is up, the Ethenet port
is physically connected to a network and can physically transmit and receive data.
</para>
                <para>
Use
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPort.IsInterfaceUp" />
to see if the Interface is in the "UP" state. When the Interface is up, the Ethernet port
has been activated with IP network settings and can participate in an IP network.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.WriteSettings(Cognex.VisionPro.Comm.CogEthernetPortSettings)" />
and
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.ReadSettings" />
to read and write network settings to the Comm Card.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceUpAsync" />
and
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceDownAsync" />
to manually bring the interface "UP" and "DOWN" using the settings stored on the Card.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.ReadActiveSettings" />
to read the currently active settings while the Interface is "UP".
The currently active settings may be different from the settings stored on the card
in cases where the card is configured for DHCP, or if something (i.e. PROFINET) changes
the active settings without also writing them to the storage location on the card.
</para>
                <para>
Note that CogEthernetPort does not have exclusive control over the Ethernet port
hardware. The Ethernet port interface may already be "UP" when a CogEthernetPort is
created. Furthermore, the state of the Ethernet interface may report changes and 
events that were _not_ initiated from user calls into its own properties and methods.
</para>
                <para>
Note also that the lifetime of this object is not related to the state ("UP" or "DOWN")
of the Ethernet port interface. Disposing the CogEthernetPort object will not affect
the state of actual Ethernet settings running on the card (even though exiting 
the _process_ will bring the network interface "DOWN").
</para>
            </remarks>
            <example>
                <!-- CogCommCardEthernetExample -->
                <!-- Shows simple use of comm card API to change Ethernet port settings-->
                <code lang="Visual Basic" />
                <code lang="C#">
using Cognex.VisionPro;
using Cognex.VisionPro.Comm;

// Change the IP address on a Comm Card Ethernet port.
public void ChangeIPAddress(
  string newAddress,
  string newSubnet,
  string newDefaultGateway)
{
CogCommCards commCardCollection = new CogCommCards();

Console.WriteLine("Found: {0} Comm Cards", commCardCollection.Count);
if (commCardCollection.Count == 0) return;

// Get a reference to the the comm card object.
CogCommCard card = commCardCollection[0];

Console.WriteLine("Name: {0}", card.Name);
Console.WriteLine("Serial: {0}", card.SerialNumber);

Console.WriteLine("NumEthernetPorts: {0}", card.EthernetPortAccess.NumPorts);
if (card.EthernetPortAccess.NumPorts == 0) return;

// Create a software object to interact with Ethernet port.
CogEthernetPort etherPort = card.EthernetPortAccess.CreateEthernetPort(0);

Console.WriteLine("Current Ethernet Port Settings:");
Console.WriteLine("  link up: {0}", etherPort.IsLinkUp);
Console.WriteLine("  iface up: {0}", etherPort.IsInterfaceUp);

// Read the persistant settings from the Comm Card.
CogEthernetPortSettings settings = etherPort.ReadSettings();

Console.WriteLine("  ip: {0}", settings.IPAddress);
Console.WriteLine("  subnet: {0}", settings.SubnetMask);
Console.WriteLine("  default gateway: {0}", settings.DefaultGateway);
Console.WriteLine("  host name: {0}", settings.HostName);
Console.WriteLine("  domain name: {0}", settings.DomainName);
Console.WriteLine("  dhcpEnable: {0}", settings.DHCPEnable);

if (etherPort.IsInterfaceUp)
{
  Console.WriteLine("Bringing Interface DOWN...");

  bool timedOut = !etherPort.BringInterfaceDownAsync().Wait(2000);
  if (timedOut)
  {
    Console.WriteLine("Bringing Interface Down TIMED OUT!!");
    return;
  }
  Console.WriteLine("The Interface is DOWN.");
}

Console.WriteLine("Writing new IP address to Comm Card.");

// Change the settings to the new ip address.
settings.IPAddress = IPAddress.Parse(newAddress);
settings.SubnetMask = IPAddress.Parse(newSubnet);
settings.DefaultGateway = IPAddress.Parse(newDefaultGateway);
settings.HostName = "hostname";
settings.DomainName = "";
settings.DHCPEnable = false;

// Write the new settings to the card.
etherPort.WriteSettings(settings);

// Bring up the interface with the new IP address.
if (!etherPort.IsInterfaceUp)
{
  Console.WriteLine("Bringing Interface UP...");

  bool timedOut = !etherPort.BringInterfaceUpAsync().Wait(2000);
  if (timedOut)
  {
    Console.WriteLine("Bringing Interface UP TIMED OUT!!");
    return;
  }
  Console.WriteLine("The Interface is UP.");
}

Console.WriteLine("New Ethernet Port Settings:");
Console.WriteLine("  link up: {0}", etherPort.IsLinkUp);
Console.WriteLine("  iface up: {0}", etherPort.IsInterfaceUp);

// Read the current settings from the Comm Card.
settings = etherPort.ReadActiveSettings();

Console.WriteLine("  ip: {0}", settings.IPAddress);
Console.WriteLine("  subnet: {0}", settings.SubnetMask);
Console.WriteLine("  default gateway: {0}", settings.DefaultGateway);
Console.WriteLine("  host name: {0}", settings.HostName);
Console.WriteLine("  domain name: {0}", settings.DomainName);
Console.WriteLine("  dhcpEnable: {0}", settings.DHCPEnable);
}


------
Output
------

Found: 1 Comm Cards
Name: Cognex Communications Card 24C
Serial: 1A1410XN002183
NumEthernetPorts: 1
Current Ethernet Port Settings:
  link up: False
  iface up: True
  ip: 192.168.1.42
  subnet: 255.255.0.0
  default gateway: 192.168.1.3
  host name: HostName
  domain name: 
  dhcpEnable: False
Bringing Interface DOWN...
The Interface is DOWN.
Writing new IP address to Comm Card.
Bringing Interface UP...
The Interface is UP.
New Ethernet Port Settings:
  link up: False
  iface up: True
  ip: 192.168.1.100
  subnet: 255.255.255.255
  default gateway: 192.168.1.1
  host name: hostname
  domain name: 
  dhcpEnable: False
</code>
            </example>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogEthernetPort.IsLinkUp">
            <summary>
Gets the state of the Ethernet port link. 
A link is "up" if the Ethernet port is electrically connected.
</summary>
            <remarks>
                <para>
Ethernet settings are written to the Comm Card using
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.WriteSettings(Cognex.VisionPro.Comm.CogEthernetPortSettings)" />.
These settings are stored in flash memory directly on the Comm Card.
</para>
                <para>
When a VisionPro application first connects to a Comm Card, the Comm Card
automatically attempts to bring the Ethernet port interface "UP" using the 
stored settings. Later, when the VisionPro application exits, the Comm Card 
will automatically bring the Interface "DOWN", removing the card from the 
network.
</para>
                <para>
Both the Link (physical connection present) and the Interface (IP settings
activated) need to be in the "UP" state for the Ethernet port to participate
in an IP network. When the link or interface is "DOWN", the Ethernet port
cannot communicate over an IP network.
</para>
                <para>
Use
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPort.IsLinkUp" />
to see if the Link is in the "UP" state. When the Link is up, the Ethenet port
is physically connected to a network and can physically transmit and receive data.
</para>
                <para>
Use
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPort.IsInterfaceUp" />
to see if the Interface is in the "UP" state. When the Interface is up, the Ethernet port
has been activated with IP network settings and can participate in an IP network.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.WriteSettings(Cognex.VisionPro.Comm.CogEthernetPortSettings)" />
and
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.ReadSettings" />
to read and write network settings to the Comm Card.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceUpAsync" />
and
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceDownAsync" />
to manually bring the interface "UP" and "DOWN" using the settings stored on the Card.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.ReadActiveSettings" />
to read the currently active settings while the Interface is "UP".
The currently active settings may be different from the settings stored on the card
in cases where the card is configured for DHCP, or if something (i.e. PROFINET) changes
the active settings without also writing them to the storage location on the card.
</para>
                <para>
Note that CogEthernetPort does not have exclusive control over the Ethernet port
hardware. The Ethernet port interface may already be "UP" when a CogEthernetPort is
created. Furthermore, the state of the Ethernet interface may report changes and 
events that were _not_ initiated from user calls into its own properties and methods.
</para>
                <para>
Note also that the lifetime of this object is not related to the state ("UP" or "DOWN")
of the Ethernet port interface. Disposing the CogEthernetPort object will not affect
the state of actual Ethernet settings running on the card (even though exiting 
the _process_ will bring the network interface "DOWN").
</para>
            </remarks>
            <event cref="E:Cognex.VisionPro.ICogChangedEvent.Changed">
                <para>Raised when this property changes.</para>
                <para>The following state flag may be affected:</para>
                <list type="bullet">
                    <item>SfIsLinkUp</item>
                </list>
            </event>
            <example>
                <!-- CogCommCardEthernetExample -->
                <!-- Shows simple use of comm card API to change Ethernet port settings-->
                <code lang="Visual Basic" />
                <code lang="C#">
using Cognex.VisionPro;
using Cognex.VisionPro.Comm;

// Change the IP address on a Comm Card Ethernet port.
public void ChangeIPAddress(
  string newAddress,
  string newSubnet,
  string newDefaultGateway)
{
CogCommCards commCardCollection = new CogCommCards();

Console.WriteLine("Found: {0} Comm Cards", commCardCollection.Count);
if (commCardCollection.Count == 0) return;

// Get a reference to the the comm card object.
CogCommCard card = commCardCollection[0];

Console.WriteLine("Name: {0}", card.Name);
Console.WriteLine("Serial: {0}", card.SerialNumber);

Console.WriteLine("NumEthernetPorts: {0}", card.EthernetPortAccess.NumPorts);
if (card.EthernetPortAccess.NumPorts == 0) return;

// Create a software object to interact with Ethernet port.
CogEthernetPort etherPort = card.EthernetPortAccess.CreateEthernetPort(0);

Console.WriteLine("Current Ethernet Port Settings:");
Console.WriteLine("  link up: {0}", etherPort.IsLinkUp);
Console.WriteLine("  iface up: {0}", etherPort.IsInterfaceUp);

// Read the persistant settings from the Comm Card.
CogEthernetPortSettings settings = etherPort.ReadSettings();

Console.WriteLine("  ip: {0}", settings.IPAddress);
Console.WriteLine("  subnet: {0}", settings.SubnetMask);
Console.WriteLine("  default gateway: {0}", settings.DefaultGateway);
Console.WriteLine("  host name: {0}", settings.HostName);
Console.WriteLine("  domain name: {0}", settings.DomainName);
Console.WriteLine("  dhcpEnable: {0}", settings.DHCPEnable);

if (etherPort.IsInterfaceUp)
{
  Console.WriteLine("Bringing Interface DOWN...");

  bool timedOut = !etherPort.BringInterfaceDownAsync().Wait(2000);
  if (timedOut)
  {
    Console.WriteLine("Bringing Interface Down TIMED OUT!!");
    return;
  }
  Console.WriteLine("The Interface is DOWN.");
}

Console.WriteLine("Writing new IP address to Comm Card.");

// Change the settings to the new ip address.
settings.IPAddress = IPAddress.Parse(newAddress);
settings.SubnetMask = IPAddress.Parse(newSubnet);
settings.DefaultGateway = IPAddress.Parse(newDefaultGateway);
settings.HostName = "hostname";
settings.DomainName = "";
settings.DHCPEnable = false;

// Write the new settings to the card.
etherPort.WriteSettings(settings);

// Bring up the interface with the new IP address.
if (!etherPort.IsInterfaceUp)
{
  Console.WriteLine("Bringing Interface UP...");

  bool timedOut = !etherPort.BringInterfaceUpAsync().Wait(2000);
  if (timedOut)
  {
    Console.WriteLine("Bringing Interface UP TIMED OUT!!");
    return;
  }
  Console.WriteLine("The Interface is UP.");
}

Console.WriteLine("New Ethernet Port Settings:");
Console.WriteLine("  link up: {0}", etherPort.IsLinkUp);
Console.WriteLine("  iface up: {0}", etherPort.IsInterfaceUp);

// Read the current settings from the Comm Card.
settings = etherPort.ReadActiveSettings();

Console.WriteLine("  ip: {0}", settings.IPAddress);
Console.WriteLine("  subnet: {0}", settings.SubnetMask);
Console.WriteLine("  default gateway: {0}", settings.DefaultGateway);
Console.WriteLine("  host name: {0}", settings.HostName);
Console.WriteLine("  domain name: {0}", settings.DomainName);
Console.WriteLine("  dhcpEnable: {0}", settings.DHCPEnable);
}


------
Output
------

Found: 1 Comm Cards
Name: Cognex Communications Card 24C
Serial: 1A1410XN002183
NumEthernetPorts: 1
Current Ethernet Port Settings:
  link up: False
  iface up: True
  ip: 192.168.1.42
  subnet: 255.255.0.0
  default gateway: 192.168.1.3
  host name: HostName
  domain name: 
  dhcpEnable: False
Bringing Interface DOWN...
The Interface is DOWN.
Writing new IP address to Comm Card.
Bringing Interface UP...
The Interface is UP.
New Ethernet Port Settings:
  link up: False
  iface up: True
  ip: 192.168.1.100
  subnet: 255.255.255.255
  default gateway: 192.168.1.1
  host name: hostname
  domain name: 
  dhcpEnable: False
</code>
            </example>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogEthernetPort.IsInterfaceUp">
            <summary>
Gets the state of the Ethernet port interface.
An interface is "UP" if it has been successfully configured
with an IP address, sub-net mask, etc...
</summary>
            <remarks>
                <para>
Ethernet settings are written to the Comm Card using
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.WriteSettings(Cognex.VisionPro.Comm.CogEthernetPortSettings)" />.
These settings are stored in flash memory directly on the Comm Card.
</para>
                <para>
When a VisionPro application first connects to a Comm Card, the Comm Card
automatically attempts to bring the Ethernet port interface "UP" using the 
stored settings. Later, when the VisionPro application exits, the Comm Card 
will automatically bring the Interface "DOWN", removing the card from the 
network.
</para>
                <para>
Both the Link (physical connection present) and the Interface (IP settings
activated) need to be in the "UP" state for the Ethernet port to participate
in an IP network. When the link or interface is "DOWN", the Ethernet port
cannot communicate over an IP network.
</para>
                <para>
Use
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPort.IsLinkUp" />
to see if the Link is in the "UP" state. When the Link is up, the Ethenet port
is physically connected to a network and can physically transmit and receive data.
</para>
                <para>
Use
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPort.IsInterfaceUp" />
to see if the Interface is in the "UP" state. When the Interface is up, the Ethernet port
has been activated with IP network settings and can participate in an IP network.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.WriteSettings(Cognex.VisionPro.Comm.CogEthernetPortSettings)" />
and
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.ReadSettings" />
to read and write network settings to the Comm Card.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceUpAsync" />
and
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceDownAsync" />
to manually bring the interface "UP" and "DOWN" using the settings stored on the Card.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.ReadActiveSettings" />
to read the currently active settings while the Interface is "UP".
The currently active settings may be different from the settings stored on the card
in cases where the card is configured for DHCP, or if something (i.e. PROFINET) changes
the active settings without also writing them to the storage location on the card.
</para>
                <para>
Note that CogEthernetPort does not have exclusive control over the Ethernet port
hardware. The Ethernet port interface may already be "UP" when a CogEthernetPort is
created. Furthermore, the state of the Ethernet interface may report changes and 
events that were _not_ initiated from user calls into its own properties and methods.
</para>
                <para>
Note also that the lifetime of this object is not related to the state ("UP" or "DOWN")
of the Ethernet port interface. Disposing the CogEthernetPort object will not affect
the state of actual Ethernet settings running on the card (even though exiting 
the _process_ will bring the network interface "DOWN").
</para>
            </remarks>
            <event cref="E:Cognex.VisionPro.ICogChangedEvent.Changed">
                <para>Raised when this property changes.</para>
                <para>The following state flag may be affected:</para>
                <list type="bullet">
                    <item>SfIsInterfaceUp</item>
                </list>
            </event>
            <example>
                <!-- CogCommCardEthernetExample -->
                <!-- Shows simple use of comm card API to change Ethernet port settings-->
                <code lang="Visual Basic" />
                <code lang="C#">
using Cognex.VisionPro;
using Cognex.VisionPro.Comm;

// Change the IP address on a Comm Card Ethernet port.
public void ChangeIPAddress(
  string newAddress,
  string newSubnet,
  string newDefaultGateway)
{
CogCommCards commCardCollection = new CogCommCards();

Console.WriteLine("Found: {0} Comm Cards", commCardCollection.Count);
if (commCardCollection.Count == 0) return;

// Get a reference to the the comm card object.
CogCommCard card = commCardCollection[0];

Console.WriteLine("Name: {0}", card.Name);
Console.WriteLine("Serial: {0}", card.SerialNumber);

Console.WriteLine("NumEthernetPorts: {0}", card.EthernetPortAccess.NumPorts);
if (card.EthernetPortAccess.NumPorts == 0) return;

// Create a software object to interact with Ethernet port.
CogEthernetPort etherPort = card.EthernetPortAccess.CreateEthernetPort(0);

Console.WriteLine("Current Ethernet Port Settings:");
Console.WriteLine("  link up: {0}", etherPort.IsLinkUp);
Console.WriteLine("  iface up: {0}", etherPort.IsInterfaceUp);

// Read the persistant settings from the Comm Card.
CogEthernetPortSettings settings = etherPort.ReadSettings();

Console.WriteLine("  ip: {0}", settings.IPAddress);
Console.WriteLine("  subnet: {0}", settings.SubnetMask);
Console.WriteLine("  default gateway: {0}", settings.DefaultGateway);
Console.WriteLine("  host name: {0}", settings.HostName);
Console.WriteLine("  domain name: {0}", settings.DomainName);
Console.WriteLine("  dhcpEnable: {0}", settings.DHCPEnable);

if (etherPort.IsInterfaceUp)
{
  Console.WriteLine("Bringing Interface DOWN...");

  bool timedOut = !etherPort.BringInterfaceDownAsync().Wait(2000);
  if (timedOut)
  {
    Console.WriteLine("Bringing Interface Down TIMED OUT!!");
    return;
  }
  Console.WriteLine("The Interface is DOWN.");
}

Console.WriteLine("Writing new IP address to Comm Card.");

// Change the settings to the new ip address.
settings.IPAddress = IPAddress.Parse(newAddress);
settings.SubnetMask = IPAddress.Parse(newSubnet);
settings.DefaultGateway = IPAddress.Parse(newDefaultGateway);
settings.HostName = "hostname";
settings.DomainName = "";
settings.DHCPEnable = false;

// Write the new settings to the card.
etherPort.WriteSettings(settings);

// Bring up the interface with the new IP address.
if (!etherPort.IsInterfaceUp)
{
  Console.WriteLine("Bringing Interface UP...");

  bool timedOut = !etherPort.BringInterfaceUpAsync().Wait(2000);
  if (timedOut)
  {
    Console.WriteLine("Bringing Interface UP TIMED OUT!!");
    return;
  }
  Console.WriteLine("The Interface is UP.");
}

Console.WriteLine("New Ethernet Port Settings:");
Console.WriteLine("  link up: {0}", etherPort.IsLinkUp);
Console.WriteLine("  iface up: {0}", etherPort.IsInterfaceUp);

// Read the current settings from the Comm Card.
settings = etherPort.ReadActiveSettings();

Console.WriteLine("  ip: {0}", settings.IPAddress);
Console.WriteLine("  subnet: {0}", settings.SubnetMask);
Console.WriteLine("  default gateway: {0}", settings.DefaultGateway);
Console.WriteLine("  host name: {0}", settings.HostName);
Console.WriteLine("  domain name: {0}", settings.DomainName);
Console.WriteLine("  dhcpEnable: {0}", settings.DHCPEnable);
}


------
Output
------

Found: 1 Comm Cards
Name: Cognex Communications Card 24C
Serial: 1A1410XN002183
NumEthernetPorts: 1
Current Ethernet Port Settings:
  link up: False
  iface up: True
  ip: 192.168.1.42
  subnet: 255.255.0.0
  default gateway: 192.168.1.3
  host name: HostName
  domain name: 
  dhcpEnable: False
Bringing Interface DOWN...
The Interface is DOWN.
Writing new IP address to Comm Card.
Bringing Interface UP...
The Interface is UP.
New Ethernet Port Settings:
  link up: False
  iface up: True
  ip: 192.168.1.100
  subnet: 255.255.255.255
  default gateway: 192.168.1.1
  host name: hostname
  domain name: 
  dhcpEnable: False
</code>
            </example>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogEthernetPort.MacAddress">
            <summary>
Gets the MAC address of the Ethernet port.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogEthernetPort.Index">
            <summary>
Gets the index of the physical Ethernet port.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogEthernetPort.#ctor(ccINetConfig_Core_v0*,ccINetConfig_Core_v1*,System.Int32)">
            <summary>
Only the CogEthernetPortAccess should construct 
a CogEthernetPort object.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogEthernetPort.fCallback(System.Int32,ceNetConfigEventType_,System.Void*)">
            <summary>
Called when an Ethernet event/callback happens
</summary>
        </member>
        <member name="E:Cognex.VisionPro.Comm.CogEthernetPort.InterfaceUp">
            <summary>
This event is raised whenever the interface comes up.
The event args contain the currently active settings.
</summary>
            <remarks>
                <para>
Ethernet settings are written to the Comm Card using
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.WriteSettings(Cognex.VisionPro.Comm.CogEthernetPortSettings)" />.
These settings are stored in flash memory directly on the Comm Card.
</para>
                <para>
When a VisionPro application first connects to a Comm Card, the Comm Card
automatically attempts to bring the Ethernet port interface "UP" using the 
stored settings. Later, when the VisionPro application exits, the Comm Card 
will automatically bring the Interface "DOWN", removing the card from the 
network.
</para>
                <para>
Both the Link (physical connection present) and the Interface (IP settings
activated) need to be in the "UP" state for the Ethernet port to participate
in an IP network. When the link or interface is "DOWN", the Ethernet port
cannot communicate over an IP network.
</para>
                <para>
Use
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPort.IsLinkUp" />
to see if the Link is in the "UP" state. When the Link is up, the Ethenet port
is physically connected to a network and can physically transmit and receive data.
</para>
                <para>
Use
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPort.IsInterfaceUp" />
to see if the Interface is in the "UP" state. When the Interface is up, the Ethernet port
has been activated with IP network settings and can participate in an IP network.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.WriteSettings(Cognex.VisionPro.Comm.CogEthernetPortSettings)" />
and
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.ReadSettings" />
to read and write network settings to the Comm Card.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceUpAsync" />
and
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceDownAsync" />
to manually bring the interface "UP" and "DOWN" using the settings stored on the Card.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.ReadActiveSettings" />
to read the currently active settings while the Interface is "UP".
The currently active settings may be different from the settings stored on the card
in cases where the card is configured for DHCP, or if something (i.e. PROFINET) changes
the active settings without also writing them to the storage location on the card.
</para>
                <para>
Note that CogEthernetPort does not have exclusive control over the Ethernet port
hardware. The Ethernet port interface may already be "UP" when a CogEthernetPort is
created. Furthermore, the state of the Ethernet interface may report changes and 
events that were _not_ initiated from user calls into its own properties and methods.
</para>
                <para>
Note also that the lifetime of this object is not related to the state ("UP" or "DOWN")
of the Ethernet port interface. Disposing the CogEthernetPort object will not affect
the state of actual Ethernet settings running on the card (even though exiting 
the _process_ will bring the network interface "DOWN").
</para>
            </remarks>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogEthernetPort.SfIsLinkUp">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by IsLinkUp may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogEthernetPort.SfIsInterfaceUp">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by IsInterfaceUp may have changed.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogEthernetPort">
            <summary>
                <para>
The CogEthernetPort class supports configuring an Ethernet port present
on a device.
</para>
                <para>
Use the
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPortAccess.CreateEthernetPort" />
method of 
<see cref="T:Cognex.VisionPro.Comm.CogEthernetPortAccess" />
to factory/initialize instances of the CogEthernetPort class.
</para>
                <para>
Ethernet settings are written to the Comm Card using
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.WriteSettings(Cognex.VisionPro.Comm.CogEthernetPortSettings)" />.
These settings are stored in flash memory directly on the Comm Card.
</para>
                <para>
When a VisionPro application first connects to a Comm Card, the Comm Card
automatically attempts to bring the Ethernet port interface "UP" using the 
stored settings. Later, when the VisionPro application exits, the Comm Card 
will automatically bring the Interface "DOWN", removing the card from the 
network.
</para>
                <para>
Both the Link (physical connection present) and the Interface (IP settings
activated) need to be in the "UP" state for the Ethernet port to participate
in an IP network. When the link or interface is "DOWN", the Ethernet port
cannot communicate over an IP network.
</para>
                <para>
Use
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPort.IsLinkUp" />
to see if the Link is in the "UP" state. When the Link is up, the Ethenet port
is physically connected to a network and can physically transmit and receive data.
</para>
                <para>
Use
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPort.IsInterfaceUp" />
to see if the Interface is in the "UP" state. When the Interface is up, the Ethernet port
has been activated with IP network settings and can participate in an IP network.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.WriteSettings(Cognex.VisionPro.Comm.CogEthernetPortSettings)" />
and
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.ReadSettings" />
to read and write network settings to the Comm Card.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceUpAsync" />
and
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceDownAsync" />
to manually bring the interface "UP" and "DOWN" using the settings stored on the Card.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.ReadActiveSettings" />
to read the currently active settings while the Interface is "UP".
The currently active settings may be different from the settings stored on the card
in cases where the card is configured for DHCP, or if something (i.e. PROFINET) changes
the active settings without also writing them to the storage location on the card.
</para>
                <para>
Note that CogEthernetPort does not have exclusive control over the Ethernet port
hardware. The Ethernet port interface may already be "UP" when a CogEthernetPort is
created. Furthermore, the state of the Ethernet interface may report changes and 
events that were _not_ initiated from user calls into its own properties and methods.
</para>
                <para>
Note also that the lifetime of this object is not related to the state ("UP" or "DOWN")
of the Ethernet port interface. Disposing the CogEthernetPort object will not affect
the state of actual Ethernet settings running on the card (even though exiting 
the _process_ will bring the network interface "DOWN").
</para>
            </summary>
            <example>
                <!-- CogCommCardEthernetExample -->
                <!-- Shows simple use of comm card API to change Ethernet port settings-->
                <code lang="Visual Basic" />
                <code lang="C#">
using Cognex.VisionPro;
using Cognex.VisionPro.Comm;

// Change the IP address on a Comm Card Ethernet port.
public void ChangeIPAddress(
  string newAddress,
  string newSubnet,
  string newDefaultGateway)
{
CogCommCards commCardCollection = new CogCommCards();

Console.WriteLine("Found: {0} Comm Cards", commCardCollection.Count);
if (commCardCollection.Count == 0) return;

// Get a reference to the the comm card object.
CogCommCard card = commCardCollection[0];

Console.WriteLine("Name: {0}", card.Name);
Console.WriteLine("Serial: {0}", card.SerialNumber);

Console.WriteLine("NumEthernetPorts: {0}", card.EthernetPortAccess.NumPorts);
if (card.EthernetPortAccess.NumPorts == 0) return;

// Create a software object to interact with Ethernet port.
CogEthernetPort etherPort = card.EthernetPortAccess.CreateEthernetPort(0);

Console.WriteLine("Current Ethernet Port Settings:");
Console.WriteLine("  link up: {0}", etherPort.IsLinkUp);
Console.WriteLine("  iface up: {0}", etherPort.IsInterfaceUp);

// Read the persistant settings from the Comm Card.
CogEthernetPortSettings settings = etherPort.ReadSettings();

Console.WriteLine("  ip: {0}", settings.IPAddress);
Console.WriteLine("  subnet: {0}", settings.SubnetMask);
Console.WriteLine("  default gateway: {0}", settings.DefaultGateway);
Console.WriteLine("  host name: {0}", settings.HostName);
Console.WriteLine("  domain name: {0}", settings.DomainName);
Console.WriteLine("  dhcpEnable: {0}", settings.DHCPEnable);

if (etherPort.IsInterfaceUp)
{
  Console.WriteLine("Bringing Interface DOWN...");

  bool timedOut = !etherPort.BringInterfaceDownAsync().Wait(2000);
  if (timedOut)
  {
    Console.WriteLine("Bringing Interface Down TIMED OUT!!");
    return;
  }
  Console.WriteLine("The Interface is DOWN.");
}

Console.WriteLine("Writing new IP address to Comm Card.");

// Change the settings to the new ip address.
settings.IPAddress = IPAddress.Parse(newAddress);
settings.SubnetMask = IPAddress.Parse(newSubnet);
settings.DefaultGateway = IPAddress.Parse(newDefaultGateway);
settings.HostName = "hostname";
settings.DomainName = "";
settings.DHCPEnable = false;

// Write the new settings to the card.
etherPort.WriteSettings(settings);

// Bring up the interface with the new IP address.
if (!etherPort.IsInterfaceUp)
{
  Console.WriteLine("Bringing Interface UP...");

  bool timedOut = !etherPort.BringInterfaceUpAsync().Wait(2000);
  if (timedOut)
  {
    Console.WriteLine("Bringing Interface UP TIMED OUT!!");
    return;
  }
  Console.WriteLine("The Interface is UP.");
}

Console.WriteLine("New Ethernet Port Settings:");
Console.WriteLine("  link up: {0}", etherPort.IsLinkUp);
Console.WriteLine("  iface up: {0}", etherPort.IsInterfaceUp);

// Read the current settings from the Comm Card.
settings = etherPort.ReadActiveSettings();

Console.WriteLine("  ip: {0}", settings.IPAddress);
Console.WriteLine("  subnet: {0}", settings.SubnetMask);
Console.WriteLine("  default gateway: {0}", settings.DefaultGateway);
Console.WriteLine("  host name: {0}", settings.HostName);
Console.WriteLine("  domain name: {0}", settings.DomainName);
Console.WriteLine("  dhcpEnable: {0}", settings.DHCPEnable);
}


------
Output
------

Found: 1 Comm Cards
Name: Cognex Communications Card 24C
Serial: 1A1410XN002183
NumEthernetPorts: 1
Current Ethernet Port Settings:
  link up: False
  iface up: True
  ip: 192.168.1.42
  subnet: 255.255.0.0
  default gateway: 192.168.1.3
  host name: HostName
  domain name: 
  dhcpEnable: False
Bringing Interface DOWN...
The Interface is DOWN.
Writing new IP address to Comm Card.
Bringing Interface UP...
The Interface is UP.
New Ethernet Port Settings:
  link up: False
  iface up: True
  ip: 192.168.1.100
  subnet: 255.255.255.255
  default gateway: 192.168.1.1
  host name: hostname
  domain name: 
  dhcpEnable: False
</code>
            </example>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogEthernetPortInterfaceUpEventHandler">
            <summary>
Event handler for 
<see cref="E:Cognex.VisionPro.Comm.CogEthernetPort.InterfaceUp" />
event.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogEthernetPortInterfaceUpEventArgs.Settings">
            <summary>
The current Ethernet port settings
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogEthernetPortInterfaceUpEventArgs.#ctor(csNetConfigInfo_*,csNetConfigInetAddr_*)">
            <summary>
Construct the event args from an instance of the 
unmanaged callback info.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogEthernetPortInterfaceUpEventArgs.#ctor(csNetConfigInfoV1_*)">
            <summary>
Construct the event args from an instance of the 
unmanaged callback info.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogEthernetPortInterfaceUpEventArgs">
            <summary>
Event args returned as part of CogEthernetPort InterfaceUp event.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogEthernetPortSettings.DomainName">
            <summary>
Gets or sets the domain name.
</summary>
            <exception cref="T:System.ArgumentException">
Thrown if the supplied domain name has more than 255 characters
or the domain name contains illegal characters.
</exception>
            <event cref="E:Cognex.VisionPro.ICogChangedEvent.Changed">
                <para>Raised when this property changes.</para>
                <para>The following state flag may be affected:</para>
                <list type="bullet">
                    <item>SfDomainName</item>
                </list>
            </event>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogEthernetPortSettings.DefaultGateway">
            <summary>
Gets or sets the default gateway of the Ethernet port.
<para>
Attempts to set this property are ignored when
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPortSettings.DHCPEnable" /> is true.
</para></summary>
            <event cref="E:Cognex.VisionPro.ICogChangedEvent.Changed">
                <para>Raised when this property changes.</para>
                <para>The following state flag may be affected:</para>
                <list type="bullet">
                    <item>SfDefaultGateway</item>
                </list>
            </event>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogEthernetPortSettings.SubnetMask">
            <summary>
Gets or sets the subnet mask of the Ethernet port.
<para>
Attempts to set this property are ignored when
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPortSettings.DHCPEnable" /> is true.
</para></summary>
            <event cref="E:Cognex.VisionPro.ICogChangedEvent.Changed">
                <para>Raised when this property changes.</para>
                <para>The following state flag may be affected:</para>
                <list type="bullet">
                    <item>SfSubnetMask</item>
                </list>
            </event>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogEthernetPortSettings.IPAddress">
            <summary>
Gets or sets the IP address of the Ethernet port.
<para>
Attempts to set this property are ignored when
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPortSettings.DHCPEnable" /> is true.
</para></summary>
            <event cref="E:Cognex.VisionPro.ICogChangedEvent.Changed">
                <para>Raised when this property changes.</para>
                <para>The following state flag may be affected:</para>
                <list type="bullet">
                    <item>SfIPAddress</item>
                </list>
            </event>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogEthernetPortSettings.DHCPEnable">
            <summary>
Gets or sets whether DHCP is enabled for the Ethernet port.
</summary>
            <event cref="E:Cognex.VisionPro.ICogChangedEvent.Changed">
                <para>Raised when this property changes.</para>
                <para>The following state flag may be affected:</para>
                <list type="bullet">
                    <item>SfDHCPEnable</item>
                </list>
            </event>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogEthernetPortSettings.HostName">
            <summary>
Gets or sets the host name.
</summary>
            <exception cref="T:System.ArgumentException">
Thrown if the hostname contains more than 63 characters
or the hostname contains illegal characters.
</exception>
            <event cref="E:Cognex.VisionPro.ICogChangedEvent.Changed">
                <para>Raised when this property changes.</para>
                <para>The following state flag may be affected:</para>
                <list type="bullet">
                    <item>SfHostName</item>
                </list>
            </event>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogEthernetPortSettings.ConvertToNative(csNetConfigInfoV1_*)">
            <summary>
Fill up the unmanaged configInfo from the managed data held
by this class.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogEthernetPortSettings.CopyStringToNative(System.String,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*)">
            <summary>
Copies a .net string to an ascii encoded native string.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogEthernetPortSettings.SfDefaultGateway">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by DefaultGateway may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogEthernetPortSettings.SfSubnetMask">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by SubnetMask may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogEthernetPortSettings.SfIPAddress">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by IPAddress may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogEthernetPortSettings.SfDHCPEnable">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by DHCPEnable may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogEthernetPortSettings.SfDomainName">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by DomainName may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogEthernetPortSettings.SfHostName">
            <summary>
This bit will be set in the EventArgs of a Changed event every time the
value returned by HostName may have changed.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogEthernetPortSettings">
            <summary>
The CogEthernetPortSettings class groups together related 
IP network settings like IPAddress and SubnetMask.
The CogEthernetPortSettings class is used by the
<see cref="T:Cognex.VisionPro.Comm.CogEthernetPort" />
class to read/write IP network configuration settings from/to
Comm Card hardware.
</summary>
            <remarks>
                <para>
Ethernet settings are written to the Comm Card using
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.WriteSettings" />.
These settings are stored in flash memory directly on the Comm Card.
</para>
                <para>
When a VisionPro application first connects to a Comm Card, the Comm Card
automatically attempts to bring the Ethernet port interface "UP" using the 
stored settings. Later, when the VisionPro application exits, the Comm Card 
will automatically bring the Interface "DOWN", removing the card from the 
network.
</para>
                <para>
Both the Link (physical connection present) and the Interface (IP settings
activated) need to be in the "UP" state for the Ethernet port to participate
in an IP network. When the link or interface is "DOWN", the Ethernet port
cannot communicate over an IP network.
</para>
                <para>
Use
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPort.IsLinkUp" />
to see if the Link is in the "UP" state. When the Link is up, the Ethenet port
is physically connected to a network and can physically transmit and receive data.
</para>
                <para>
Use
<see cref="P:Cognex.VisionPro.Comm.CogEthernetPort.IsInterfaceUp" />
to see if the Interface is in the "UP" state. When the Interface is up, the Ethernet port
has been activated with IP network settings and can participate in an IP network.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.WriteSettings" />
and
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.ReadSettings" />
to read and write network settings to the Comm Card.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceUpAsync" />
and
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.BringInterfaceDownAsync" />
to manually bring the interface "UP" and "DOWN" using the settings stored on the Card.
</para>
                <para>
Use
<see cref="M:Cognex.VisionPro.Comm.CogEthernetPort.ReadActiveSettings" />
to read the currently active settings while the Interface is "UP".
The currently active settings may be different from the settings stored on the card
in cases where the card is configured for DHCP, or if something (i.e. PROFINET) changes
the active settings without also writing them to the storage location on the card.
</para>
                <para>
Note that CogEthernetPort does not have exclusive control over the Ethernet port
hardware. The Ethernet port interface may already be "UP" when a CogEthernetPort is
created. Furthermore, the state of the Ethernet interface may report changes and 
events that were _not_ initiated from user calls into its own properties and methods.
</para>
                <para>
Note also that the lifetime of this object is not related to the state ("UP" or "DOWN")
of the Ethernet port interface. Disposing the CogEthernetPort object will not affect
the state of actual Ethernet settings running on the card (even though exiting 
the _process_ will bring the network interface "DOWN").
</para>
            </remarks>
            <example>
                <!-- CogCommCardEthernetExample -->
                <!-- Shows simple use of comm card API to change Ethernet port settings-->
                <code lang="Visual Basic" />
                <code lang="C#">
using Cognex.VisionPro;
using Cognex.VisionPro.Comm;

// Change the IP address on a Comm Card Ethernet port.
public void ChangeIPAddress(
  string newAddress,
  string newSubnet,
  string newDefaultGateway)
{
CogCommCards commCardCollection = new CogCommCards();

Console.WriteLine("Found: {0} Comm Cards", commCardCollection.Count);
if (commCardCollection.Count == 0) return;

// Get a reference to the the comm card object.
CogCommCard card = commCardCollection[0];

Console.WriteLine("Name: {0}", card.Name);
Console.WriteLine("Serial: {0}", card.SerialNumber);

Console.WriteLine("NumEthernetPorts: {0}", card.EthernetPortAccess.NumPorts);
if (card.EthernetPortAccess.NumPorts == 0) return;

// Create a software object to interact with Ethernet port.
CogEthernetPort etherPort = card.EthernetPortAccess.CreateEthernetPort(0);

Console.WriteLine("Current Ethernet Port Settings:");
Console.WriteLine("  link up: {0}", etherPort.IsLinkUp);
Console.WriteLine("  iface up: {0}", etherPort.IsInterfaceUp);

// Read the persistant settings from the Comm Card.
CogEthernetPortSettings settings = etherPort.ReadSettings();

Console.WriteLine("  ip: {0}", settings.IPAddress);
Console.WriteLine("  subnet: {0}", settings.SubnetMask);
Console.WriteLine("  default gateway: {0}", settings.DefaultGateway);
Console.WriteLine("  host name: {0}", settings.HostName);
Console.WriteLine("  domain name: {0}", settings.DomainName);
Console.WriteLine("  dhcpEnable: {0}", settings.DHCPEnable);

if (etherPort.IsInterfaceUp)
{
  Console.WriteLine("Bringing Interface DOWN...");

  bool timedOut = !etherPort.BringInterfaceDownAsync().Wait(2000);
  if (timedOut)
  {
    Console.WriteLine("Bringing Interface Down TIMED OUT!!");
    return;
  }
  Console.WriteLine("The Interface is DOWN.");
}

Console.WriteLine("Writing new IP address to Comm Card.");

// Change the settings to the new ip address.
settings.IPAddress = IPAddress.Parse(newAddress);
settings.SubnetMask = IPAddress.Parse(newSubnet);
settings.DefaultGateway = IPAddress.Parse(newDefaultGateway);
settings.HostName = "hostname";
settings.DomainName = "";
settings.DHCPEnable = false;

// Write the new settings to the card.
etherPort.WriteSettings(settings);

// Bring up the interface with the new IP address.
if (!etherPort.IsInterfaceUp)
{
  Console.WriteLine("Bringing Interface UP...");

  bool timedOut = !etherPort.BringInterfaceUpAsync().Wait(2000);
  if (timedOut)
  {
    Console.WriteLine("Bringing Interface UP TIMED OUT!!");
    return;
  }
  Console.WriteLine("The Interface is UP.");
}

Console.WriteLine("New Ethernet Port Settings:");
Console.WriteLine("  link up: {0}", etherPort.IsLinkUp);
Console.WriteLine("  iface up: {0}", etherPort.IsInterfaceUp);

// Read the current settings from the Comm Card.
settings = etherPort.ReadActiveSettings();

Console.WriteLine("  ip: {0}", settings.IPAddress);
Console.WriteLine("  subnet: {0}", settings.SubnetMask);
Console.WriteLine("  default gateway: {0}", settings.DefaultGateway);
Console.WriteLine("  host name: {0}", settings.HostName);
Console.WriteLine("  domain name: {0}", settings.DomainName);
Console.WriteLine("  dhcpEnable: {0}", settings.DHCPEnable);
}


------
Output
------

Found: 1 Comm Cards
Name: Cognex Communications Card 24C
Serial: 1A1410XN002183
NumEthernetPorts: 1
Current Ethernet Port Settings:
  link up: False
  iface up: True
  ip: 192.168.1.42
  subnet: 255.255.0.0
  default gateway: 192.168.1.3
  host name: HostName
  domain name: 
  dhcpEnable: False
Bringing Interface DOWN...
The Interface is DOWN.
Writing new IP address to Comm Card.
Bringing Interface UP...
The Interface is UP.
New Ethernet Port Settings:
  link up: False
  iface up: True
  ip: 192.168.1.100
  subnet: 255.255.255.255
  default gateway: 192.168.1.1
  host name: hostname
  domain name: 
  dhcpEnable: False
</code>
            </example>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogEthernetMarshalledCallbackDelegate">
            <summary>
Delegate type which is marshaled to an unmanaged function pointer and
passed to the ffp module call back.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogDiscreteIOAccess.Dispose">
            <summary>
Disposes any outstanding discrete i/o hardware resources.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogDiscreteIOAccess.Reset">
            <summary>
Resets the state of the i/o subsystem by
disposing any outstanding hardware resources.
</summary>
            <remarks>
                <list type="bullet">
                    <item>
Clears all configured precision I/O events from the Events collection.
</item>
                    <item>
Cancels any outstanding scheduled events.
</item>
                    <item>
Resets the output lines to their default states.
</item>
                </list>
            </remarks>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogHardwareInUseException">
Thrown if the hardware is in use by another process.
Only a single process may access the hardware.
When this exception is thrown, you must close any other processes that are
using the hardware, and re-start this process in order to access the hardware.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogIncompatibleFirmwareException">
Thrown if the version of the Comm Card firmware is incompatible with
the version of the host library.
Run "%VPRO_ROOT%\bin\fwuphost.exe --pkg vm56_firmware_X_X_X_X.pkg" to upgrade firmware."
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogDiscreteIOAccess.GetActivePrecisionIO">
            <summary>
Returns a reference to the currently active precision I/O
object held by the Comm Card or null if no currently active 
precision I/O object exists. 
<para>
An active precision I/O object will only exist if one of the
<see cref="M:Cognex.VisionPro.Comm.CogDiscreteIOAccess.CreatePrecisionIO" />
methods has been called previously.
</para></summary>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogHardwareInUseException">
Thrown if the hardware is in use by another process.
Only a single process may access the hardware.
When this exception is thrown, you must close any other processes that are
using the hardware, and re-start this process in order to access the hardware.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogIncompatibleFirmwareException">
Thrown if the version of the Comm Card firmware is incompatible with
the version of the host library.
Run "%VPRO_ROOT%\bin\fwuphost.exe --pkg vm56_firmware_X_X_X_X.pkg" to upgrade firmware."
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogDiscreteIOAccess.CreatePrecisionIO">
            <summary>
Creates and returns a precision I/O object.
The user interacts with the precision I/O capabilities of the comm card
though the returned object.
</summary>
            <exception cref="T:System.InvalidOperationException">
Thrown if a precision I/O interface has already been created.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogHardwareInUseException">
Thrown if the hardware is in use by another process.
Only a single process may access the hardware.
When this exception is thrown, you must close any other processes that are
using the hardware, and re-start this process in order to access the hardware.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogIncompatibleFirmwareException">
Thrown if the version of the Comm Card firmware is incompatible with
the version of the host library.
Run "%VPRO_ROOT%\bin\fwuphost.exe --pkg vm56_firmware_X_X_X_X.pkg" to upgrade firmware."
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogDiscreteIOAccess.CreatePrecisionIOImpl">
CreatePrecisionIOImpl may be useful in advanced scenarios
which require more direct access to the lower level io
API/capabilities.
<summary>
Cognex Internal Use Only
</summary><exception cref="T:System.InvalidOperationException">
Thrown if a precision I/O interface has already been created.
</exception><exception cref="T:Cognex.VisionPro.Exceptions.CogHardwareInUseException">
Thrown if the hardware is in use by another process.
Only a single process may access the hardware.
When this exception is thrown, you must close any other processes that are
using the hardware, and re-start this process in order to access the hardware.
</exception><exception cref="T:Cognex.VisionPro.Exceptions.CogIncompatibleFirmwareException">
Thrown if the version of the Comm Card firmware is incompatible with
the version of the host library.
Run "%VPRO_ROOT%\bin\fwuphost.exe --pkg vm56_firmware_X_X_X_X.pkg" to upgrade firmware."
</exception></member>
        <member name="M:Cognex.VisionPro.Comm.CogDiscreteIOAccess.#ctor(ccIBoard_PrecisionIO_v0*)">
            <summary>
Construct a VisionPro precision I/O access that wraps
the underlying nv module interface.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogDiscreteIOAccess">
            <summary>
Instances of CogDiscreteIOAccess class are held by the 
<see cref="T:Cognex.VisionPro.Comm.CogCommCard" /> class.
<para>
CogDiscreteIOAccess is used to factory/initialize instances of the 
precision I/O event system running on the comm card by calling 
<see cref="M:Cognex.VisionPro.Comm.CogDiscreteIOAccess.CreatePrecisionIO" />.
</para></summary>
            <remarks>
                <para>
Precision I/O supports getting and setting the state of 
the Comm Card's Discrete I/O lines.
</para>
                <para>
Precision I/O also supports configuration of an event system
that runs on the Comm Card's real-time processor.
</para>
                <para>
The precision I/O event system allows the Comm Card to receive
inputs and automatically react to them without involving the host PC.
</para>
                <para>
This enables accurate configuration and reporting of I/O 
events and avoids typical host PC latency issues.
</para>
                <list type="bullet">
                    <item>
Use 
<see cref="M:Cognex.VisionPro.Comm.CogPrio.SetOutput(Cognex.VisionPro.Comm.CogPrioBankConstants,System.Int32,Cognex.VisionPro.Comm.CogPrioOutputLineValueConstants)" />
to manually set an I/O line high or low.</item>
                    <item>
Use
<see cref="M:Cognex.VisionPro.Comm.CogPrio.ReadState" />
to get the current state the I/O lines.
</item>
                    <item>
Construct instances of
<see cref="T:Cognex.VisionPro.Comm.CogPrioEvent" />
and add them to the 
<see cref="P:Cognex.VisionPro.Comm.CogPrio.Events" /> 
collection to configure a set of named events that correspond to
different actions of interest that occur on the I/O card.
</item>
                    <item>
Use
<see cref="P:Cognex.VisionPro.Comm.CogPrioEvent.CausesLine" />
to configure which I/O line transitions cause a precision I/O event to occur.
</item>
                    <item>
Use
<see cref="P:Cognex.VisionPro.Comm.CogPrioEvent.CausesNdm" />
to configure which NDM signals of the factory floor protocol cause a precision I/O event to occur.
</item>
                    <item>
Use
<see cref="P:Cognex.VisionPro.Comm.CogPrioEvent.ResponsesLine" />
to configure an automatic I/O line response to a precision I/O event.
</item>
                    <item>
Use
<see cref="M:Cognex.VisionPro.Comm.CogPrioEvent.Schedule(Cognex.VisionPro.Comm.CogPrioEventScheduleTypeConstants,System.Double,Cognex.VisionPro.Comm.CogPrioState)" />
to manually schedule a configured precision I/O event to occur at an precise instant.
</item>
                    <item>
Use
<see cref="E:Cognex.VisionPro.Comm.CogPrioEvent.HostNotification" />
to receive notifications whenever a configured event occurs.
</item>
                </list>
                <para>
    Hardware platforms and supported I/O lines:
  </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Cognex Communication Card 24C</term>
                            <description />
                        </listheader>
                        <item>
                            <term>InputBank0, Line0-Line7</term>
                            <description>8 general purpose inputs numbered 0-7</description>
                        </item>
                        <item>
                            <term>OutputBank0, Line0-Line15</term>
                            <description>16 general purpose outputs numbered 0-15</description>
                        </item>
                    </list>
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Cognex Communication Card 24A (Cognex Vision Controller)</term>
                            <description />
                        </listheader>
                        <item>
                            <term>InputBank0, Line0-Line7</term>
                            <description>8 general purpose inputs numbered 0-7</description>
                        </item>
                        <item>
                            <term>OutputBank0, Line0-Line15</term>
                            <description>16 general purpose outputs numbered 0-15</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line0</term>
                            <description>Camera 0 Enable (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line1</term>
                            <description>Camera 1 Enable (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line2</term>
                            <description>Camera 0 Trigger</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line3</term>
                            <description>Camera 1 Trigger</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line4</term>
                            <description>Camera 0 Control (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line5</term>
                            <description>Camera 1 Control (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line6</term>
                            <description>Camera 0 Power (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line7</term>
                            <description>Camera 1 Power (Not For Application Use)</description>
                        </item>
                    </list>
                </para>
            </remarks>
            <example>
                <!-- CogCommCardExample1 -->
                <!-- Shows simple use of comm card API
     The sample:
     1. initializes software access to the comm card.
     2. initializes software access to the Network Data Model (NDM).
          a. Signs up for the NewUserData event     
-->
                <code lang="Visual Basic" />
                <code lang="C#">
  // This code shows simple use of
  // Comm Card API. This sample:
  //
  // 1. Initializes comm card's i/o interface.
  // 2. Reads input line 0.
  // 3. Signs up for host notification when input line 0 toggles.
  // 4. Sets an output line 0 high.
  [Test]
  public void Example2()
  {
  CogCommCards commCardCollection = new CogCommCards();

  Console.WriteLine("Found: {0} comm cards", commCardCollection.Count);

  if (commCardCollection.Count == 0)
  return;

  CogCommCard card = commCardCollection[0];

  Console.WriteLine("Name: {0}", card.Name);
  Console.WriteLine("Serial: {0}", card.SerialNumber);

  CogDiscreteIOAccess discreteIOAccess = card.DiscreteIOAccess;
  if (discreteIOAccess == null)
  throw new Exception("discrete IO is not supported.");

  // Create the prio interface
  CogPrio prio = discreteIOAccess.CreatePrecisionIO();

  // Read input 0
  bool isInputLine0High = mPrio.ReadState()[CogPrioBankConstants.InputBank0, 0];
  Console.WriteLine("Input line 0 is " + (isInputLine0High ? "high" : "low"));

  // Create an event that occurs when Input 0 changes
  prio.Events.Add(
  new CogPrioEvent() {
  Name = "InputChanged_0",
  CausesLine = new CogPrioEventCauseLineCollection() {
  new CogPrioEventCauseLine() {
  LineBank = CogPrioBankConstants.InputBank0,
  LineNumber = 0,
  LineTransition = CogPrioLineTransitionConstants.Any }}});

  // Sign up for host notification when on the event
  prio.Events["InputChanged_0"].HostNotification +=
  new CogPrioEventHandler(InputChanged_0_HostNotification);

  // Always ensure the events collection is valid.
  if(!prio.Valid)
  { 
    Console.WrtieLine(prio.ValidationErrorMsg[0]);
  }

  // Set output 0 high
  prio.SetOutput(CogPrioBankConstants.OutputBank0,         // i/o bank
  0,                                        // line number
  CogPrioOutputLineValueConstants.SetHigh); // line value to set
  }

  void InputChanged_0_HostNotification(object sender, CogPrioEventArgs e)
  {
  Console.WriteLine("rcvd host notification for InputChanged_0 event");
  }
</code>
            </example>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.Cancel(Cognex.VisionPro.Comm.CogPrioScheduledEventToken)">
            <summary>
Cancel a manually scheduled event.
</summary>
            <returns>
True if the event was successfully cancelled.
False if the event could not be cancelled, perhaps because it has
already occurred.
</returns>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.Schedule(Cognex.VisionPro.Comm.CogPrioEvent,Cognex.VisionPro.Comm.CogPrioEventScheduleTypeConstants,System.Double,Cognex.VisionPro.Comm.CogPrioState)">
            <summary>
Manually schedule the event to occur at a specific time or encoder count.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.ReadState">
            <summary>
Get the current state of the I/O interface.
</summary>
            <returns>
A <see cref="T:Cognex.VisionPro.Comm.CogPrioState" /> which contains 
the current state of the I/O interface.
</returns>
            <remarks>
The state contains information about the current values of all input
and output lines as well as the exact time stamp and encoder count at
which the state was read.
</remarks>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.DisableEvents">
            <summary>
Disables all configured events from firing.
</summary>
            <remarks>
                <para>
EnableEvents/DisableEvents affects whether precision I/O events will occur.
While events are disabled, precision I/O events will not occur.
This includes both scheduled and non-scheduled events.
If you schedule an event while events are disabled, the event will
still be scheduled. Whether or not the event actually occurs is determined
based on the Enabled/Disabled state at the instant the event would have
occured.
</para>
                <para>
The default Enabled/Disabled state of the Comm Cards Precision I/O
is Enabled.
</para>
                <para>
You may want to call DisableEvents while configuring the event collection
and call EnableEvents once configuration of the collection is complete.
</para>
                <para>
Calling EnableEvents events while events are already enabled has no effect.
</para>
                <para>
Calling DisableEvents events while events are already disabled has no effect.
</para>
            </remarks>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.EnableEvents">
            <summary>
Enables the configured events.
</summary>
            <remarks>
                <para>
EnableEvents/DisableEvents affects whether precision I/O events will occur.
While events are disabled, precision I/O events will not occur.
This includes both scheduled and non-scheduled events.
If you schedule an event while events are disabled, the event will
still be scheduled. Whether or not the event actually occurs is determined
based on the Enabled/Disabled state at the instant the event would have
occured.
</para>
                <para>
The default Enabled/Disabled state of the Comm Cards Precision I/O
is Enabled.
</para>
                <para>
You may want to call DisableEvents while configuring the event collection
and call EnableEvents once configuration of the collection is complete.
</para>
                <para>
Calling EnableEvents events while events are already enabled has no effect.
</para>
                <para>
Calling DisableEvents events while events are already disabled has no effect.
</para>
            </remarks>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.IsLineSupported(Cognex.VisionPro.Comm.CogPrioBankConstants,System.Int32)">
            <summary>
Returns true if the hardware supports the given I/O bank.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.IsBankSupported(Cognex.VisionPro.Comm.CogPrioBankConstants)">
            <summary>
Returns true if the hardware supports the given I/O bank.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogPrio.ClockFrequency">
            <summary>
Get the frequency of the clock. Use this value 
to convert clock ticks to wall clock time.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.GetBanks(Cognex.VisionPro.Comm.CogPrioBankTypeConstants)">
            <summary>
Returns an array of the supported I/O banks of the current hardware.
</summary>
            <remarks>
                <para>
    Hardware platforms and supported I/O lines:
  </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Cognex Communication Card 24C</term>
                            <description />
                        </listheader>
                        <item>
                            <term>InputBank0, Line0-Line7</term>
                            <description>8 general purpose inputs numbered 0-7</description>
                        </item>
                        <item>
                            <term>OutputBank0, Line0-Line15</term>
                            <description>16 general purpose outputs numbered 0-15</description>
                        </item>
                    </list>
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Cognex Communication Card 24A (Cognex Vision Controller)</term>
                            <description />
                        </listheader>
                        <item>
                            <term>InputBank0, Line0-Line7</term>
                            <description>8 general purpose inputs numbered 0-7</description>
                        </item>
                        <item>
                            <term>OutputBank0, Line0-Line15</term>
                            <description>16 general purpose outputs numbered 0-15</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line0</term>
                            <description>Camera 0 Enable (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line1</term>
                            <description>Camera 1 Enable (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line2</term>
                            <description>Camera 0 Trigger</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line3</term>
                            <description>Camera 1 Trigger</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line4</term>
                            <description>Camera 0 Control (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line5</term>
                            <description>Camera 1 Control (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line6</term>
                            <description>Camera 0 Power (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line7</term>
                            <description>Camera 1 Power (Not For Application Use)</description>
                        </item>
                    </list>
                </para>
            </remarks>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.IsOutputBank(Cognex.VisionPro.Comm.CogPrioBankConstants)">
            <summary>
Returns true if the bank is an output bank.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.IsInputBank(Cognex.VisionPro.Comm.CogPrioBankConstants)">
            <summary>
Returns true if the bank is an input bank.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.GetBankType(Cognex.VisionPro.Comm.CogPrioBankConstants)">
            <summary>
Returns the type (input, output, etc...) of a given I/O bank
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.GetNumLines(Cognex.VisionPro.Comm.CogPrioBankConstants)">
            <summary>
Returns the number of I/O lines the hardware supports in the given bank.
</summary>
            <remarks>
                <para>
    Hardware platforms and supported I/O lines:
  </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Cognex Communication Card 24C</term>
                            <description />
                        </listheader>
                        <item>
                            <term>InputBank0, Line0-Line7</term>
                            <description>8 general purpose inputs numbered 0-7</description>
                        </item>
                        <item>
                            <term>OutputBank0, Line0-Line15</term>
                            <description>16 general purpose outputs numbered 0-15</description>
                        </item>
                    </list>
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Cognex Communication Card 24A (Cognex Vision Controller)</term>
                            <description />
                        </listheader>
                        <item>
                            <term>InputBank0, Line0-Line7</term>
                            <description>8 general purpose inputs numbered 0-7</description>
                        </item>
                        <item>
                            <term>OutputBank0, Line0-Line15</term>
                            <description>16 general purpose outputs numbered 0-15</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line0</term>
                            <description>Camera 0 Enable (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line1</term>
                            <description>Camera 1 Enable (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line2</term>
                            <description>Camera 0 Trigger</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line3</term>
                            <description>Camera 1 Trigger</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line4</term>
                            <description>Camera 0 Control (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line5</term>
                            <description>Camera 1 Control (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line6</term>
                            <description>Camera 0 Power (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line7</term>
                            <description>Camera 1 Power (Not For Application Use)</description>
                        </item>
                    </list>
                </para>
            </remarks>
            <param name="bank">
The I/O bank.
</param>
            <returns>
The number of input or output lines in the given bank.
</returns>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.SetOutputs(Cognex.VisionPro.Comm.CogPrioBankConstants,System.Int64)">
            <summary>
Set multiple output lines at the same time.
</summary>
            <remarks>
                <para>
    Hardware platforms and supported I/O lines:
  </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Cognex Communication Card 24C</term>
                            <description />
                        </listheader>
                        <item>
                            <term>InputBank0, Line0-Line7</term>
                            <description>8 general purpose inputs numbered 0-7</description>
                        </item>
                        <item>
                            <term>OutputBank0, Line0-Line15</term>
                            <description>16 general purpose outputs numbered 0-15</description>
                        </item>
                    </list>
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Cognex Communication Card 24A (Cognex Vision Controller)</term>
                            <description />
                        </listheader>
                        <item>
                            <term>InputBank0, Line0-Line7</term>
                            <description>8 general purpose inputs numbered 0-7</description>
                        </item>
                        <item>
                            <term>OutputBank0, Line0-Line15</term>
                            <description>16 general purpose outputs numbered 0-15</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line0</term>
                            <description>Camera 0 Enable (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line1</term>
                            <description>Camera 1 Enable (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line2</term>
                            <description>Camera 0 Trigger</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line3</term>
                            <description>Camera 1 Trigger</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line4</term>
                            <description>Camera 0 Control (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line5</term>
                            <description>Camera 1 Control (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line6</term>
                            <description>Camera 0 Power (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line7</term>
                            <description>Camera 1 Power (Not For Application Use)</description>
                        </item>
                    </list>
                </para>
            </remarks>
            <param name="outputBank">
The I/O bank of the output lines to set.
</param>
            <param name="valuesToSet">
The values to set as a 64 bit integer.
The 0th bit represents output line 0,
The 1st bit represents output line 1, and so on...
Bits greater than the number of lines in the bank are ignored.
1 is "high", 0 is "low".
</param>
            <exception cref="T:System.ArgumentException">
Thrown if outputBank is set to an invalid bank.
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.SetOutputs(Cognex.VisionPro.Comm.CogPrioBankConstants,System.Int64,System.Int64)">
            <summary>
Set multiple output lines at the same time.
</summary>
            <remarks>
                <para>
    Hardware platforms and supported I/O lines:
  </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Cognex Communication Card 24C</term>
                            <description />
                        </listheader>
                        <item>
                            <term>InputBank0, Line0-Line7</term>
                            <description>8 general purpose inputs numbered 0-7</description>
                        </item>
                        <item>
                            <term>OutputBank0, Line0-Line15</term>
                            <description>16 general purpose outputs numbered 0-15</description>
                        </item>
                    </list>
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Cognex Communication Card 24A (Cognex Vision Controller)</term>
                            <description />
                        </listheader>
                        <item>
                            <term>InputBank0, Line0-Line7</term>
                            <description>8 general purpose inputs numbered 0-7</description>
                        </item>
                        <item>
                            <term>OutputBank0, Line0-Line15</term>
                            <description>16 general purpose outputs numbered 0-15</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line0</term>
                            <description>Camera 0 Enable (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line1</term>
                            <description>Camera 1 Enable (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line2</term>
                            <description>Camera 0 Trigger</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line3</term>
                            <description>Camera 1 Trigger</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line4</term>
                            <description>Camera 0 Control (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line5</term>
                            <description>Camera 1 Control (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line6</term>
                            <description>Camera 0 Power (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line7</term>
                            <description>Camera 1 Power (Not For Application Use)</description>
                        </item>
                    </list>
                </para>
            </remarks>
            <param name="outputBank">
The I/O bank of the output lines to set.
</param>
            <param name="valuesToSet">
The values to set as an integer.
The 0th bit represents output line 0,
The 1st bit represents output line 1, and so on...
Bits greater than the number of lines in the bank are ignored.
1 is "high", 0 is "low".
</param>
            <param name="mask">
A mask. Controls which bits/lines in values argument are set 
(mask = 1) and which bits/lines in values argument are ignored
(make = 0).
</param>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogPrioInvalidBankException">
Thrown if outputBank is set to an invalid bank.
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.SetOutput(Cognex.VisionPro.Comm.CogPrioBankConstants,System.Int32,Cognex.VisionPro.Comm.CogPrioOutputLineValueConstants)">
            <summary>
Set an output line.
</summary>
            <remarks>
                <para>
    Hardware platforms and supported I/O lines:
  </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Cognex Communication Card 24C</term>
                            <description />
                        </listheader>
                        <item>
                            <term>InputBank0, Line0-Line7</term>
                            <description>8 general purpose inputs numbered 0-7</description>
                        </item>
                        <item>
                            <term>OutputBank0, Line0-Line15</term>
                            <description>16 general purpose outputs numbered 0-15</description>
                        </item>
                    </list>
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Cognex Communication Card 24A (Cognex Vision Controller)</term>
                            <description />
                        </listheader>
                        <item>
                            <term>InputBank0, Line0-Line7</term>
                            <description>8 general purpose inputs numbered 0-7</description>
                        </item>
                        <item>
                            <term>OutputBank0, Line0-Line15</term>
                            <description>16 general purpose outputs numbered 0-15</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line0</term>
                            <description>Camera 0 Enable (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line1</term>
                            <description>Camera 1 Enable (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line2</term>
                            <description>Camera 0 Trigger</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line3</term>
                            <description>Camera 1 Trigger</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line4</term>
                            <description>Camera 0 Control (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line5</term>
                            <description>Camera 1 Control (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line6</term>
                            <description>Camera 0 Power (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line7</term>
                            <description>Camera 1 Power (Not For Application Use)</description>
                        </item>
                    </list>
                </para>
            </remarks>
            <param name="outputBank">
The I/O bank of the output line to set.
</param>
            <param name="outputLineNumber">
The line number of the output line to set.
</param>
            <param name="valueToSet">
The value to set the output line to.
</param>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogPrioInvalidBankException">
Thrown if outputBank is set to an invalid bank.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogPrioInvalidLineException">
Thrown if outputLineNumber is set to an invalid line.
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.SetEncoderCount(System.Int64)">
            <summary>
Set the encoder count.
<para>
Note that current hardware platforms only report 32-bits of encoder data.
This means that, depending on the hardware, the encoder may rollover
(go back to 0) when the encoder count reaches 4294967295, (0xFFFFFFFF).
</para><para>
On platforms like this only the lower 32 bits of the encoderCount argument 
are used when calling SetEncoderCount()... So don't try to set the encoder
count to a negative number or a number greater than 4294967295.
</para></summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogPrio.DebounceDuration">
            <summary>
Gets or sets the debounce duration in milliseconds for all input lines.
</summary>
            <default>
0.005 milliseconds
</default>
            <exception cref="T:System.ArgumentOutOfRangeException">
Thrown if set to less than 0.005 or greater than 65.0
</exception>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogPrio.Events">
            <summary>
A collection of
<see cref="T:Cognex.VisionPro.Comm.CogPrioEvent" />.
Add and configure events within this collection to interact with the
precision I/O event system.
</summary>
            <remarks>
                <para>
When the CogPrio.Events collection is modified, 
VisionPro resets the hardware event system and reconfigures
Comm Card with the new event configuration. This means that 
modifying the events collection will also prevent any currently
outstanding scheduled events from occurring. It is recommended 
that Events collection be configured once at set up time, and
should not be changed dynamically during application "run-time".
</para>
                <para>
Before configuring the Comm Card with an updated events
collection, VisionPro must validate the new configuration.
Invalid events configurations will _not_ be written to the hardware.
Always check the <see cref="P:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioEventConfigObjectBase.Valid" /> property
after changing the events collection to make sure that your changes are valid.
The <see cref="P:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioEventConfigObjectBase.ValidationErrorMsg" /> property
will contain information about why a particular configuration of events is 
invalid and how to fix it.
</para>
                <para>
Precision I/O supports getting and setting the state of 
the Comm Card's Discrete I/O lines.
</para>
                <para>
Precision I/O also supports configuration of an event system
that runs on the Comm Card's real-time processor.
</para>
                <para>
The precision I/O event system allows the Comm Card to receive
inputs and automatically react to them without involving the host PC.
</para>
                <para>
This enables accurate configuration and reporting of I/O 
events and avoids typical host PC latency issues.
</para>
                <list type="bullet">
                    <item>
Use 
<see cref="M:Cognex.VisionPro.Comm.CogPrio.SetOutput(Cognex.VisionPro.Comm.CogPrioBankConstants,System.Int32,Cognex.VisionPro.Comm.CogPrioOutputLineValueConstants)" />
to manually set an I/O line high or low.</item>
                    <item>
Use
<see cref="M:Cognex.VisionPro.Comm.CogPrio.ReadState" />
to get the current state the I/O lines.
</item>
                    <item>
Construct instances of
<see cref="T:Cognex.VisionPro.Comm.CogPrioEvent" />
and add them to the 
<see cref="P:Cognex.VisionPro.Comm.CogPrio.Events" /> 
collection to configure a set of named events that correspond to
different actions of interest that occur on the I/O card.
</item>
                    <item>
Use
<see cref="P:Cognex.VisionPro.Comm.CogPrioEvent.CausesLine" />
to configure which I/O line transitions cause a precision I/O event to occur.
</item>
                    <item>
Use
<see cref="P:Cognex.VisionPro.Comm.CogPrioEvent.CausesNdm" />
to configure which NDM signals of the factory floor protocol cause a precision I/O event to occur.
</item>
                    <item>
Use
<see cref="P:Cognex.VisionPro.Comm.CogPrioEvent.ResponsesLine" />
to configure an automatic I/O line response to a precision I/O event.
</item>
                    <item>
Use
<see cref="M:Cognex.VisionPro.Comm.CogPrioEvent.Schedule(Cognex.VisionPro.Comm.CogPrioEventScheduleTypeConstants,System.Double,Cognex.VisionPro.Comm.CogPrioState)" />
to manually schedule a configured precision I/O event to occur at an precise instant.
</item>
                    <item>
Use
<see cref="E:Cognex.VisionPro.Comm.CogPrioEvent.HostNotification" />
to receive notifications whenever a configured event occurs.
</item>
                </list>
            </remarks>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.CreateDefaultEvents">
            <summary>
Create and return set of default precision i/o events for this hardware.
<para>
Adds an "InputChanged_" event for each input line.
The event for input line 0 is named "InputChanged_0" and so on...
The input events are _CAUSED_ by any signal transition on the dedicated input line.
The input events are not configured with a _RESPONSE_.
</para><para>
Adds an "PulseOutput_" event for each output line.
The event for output line 0 is named "PulseOutput_0" and so on...
The output events _RESPOND_ by pulsing the the dedicated output line high for 10.0ms.
The output events are not configured with a _CAUSE_ and only occcur as a result direct user scheduling.
</para><para>
This method creates and returns a collection of events.
Note that you need to assign the returned collection of default events to the
Comm Card Prio object (i.e. mPrio.Events = mPrio.CreateDefaultEvents()) if you wish to
actually configure and use these events on the hardware.
</para></summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.SetFfpEnabler(Cognex.VisionPro.Comm.Implementation.Internal.ICogPrioFfpEventEnabler)">
            <summary>
This is a quick and dirty way to allow precision i/o
to access to the ffp interface for the purpose of configuring
ffp based precision i/o events.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.#ctor(ccIPrecisionIO_Core_v0*)">
            <summary>
Construct a VisionPro precision I/O object that wraps
the underlying implementation object.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.Validate">
            <summary>
Checks to see if Events collection is valid and can be written to
the hardware.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.OnEventsChanged(System.Object,Cognex.VisionPro.CogChangedEventArgs)">
            <summary>
Refresh the unmanaged side when the managed
side changes.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.StartListening">
            <summary>
Listen to events from the managed objects.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrio.WriteConfiguredEventsToCommCard">
            <summary>
Refreshes the state of precision I/O on the comm card
from the state held in this object.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogPrio.SfEvents">
            <summary>
This bit will be set in the EventArgs of a Changed event
every time the value returned by Events may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogPrio.SfDebounceDuration">
            <summary>
This bit will be set in the EventArgs of a Changed event
every time the value returned by DebounceDuration
may have changed.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogPrio">
            <summary>
CogPrio is used to configure and interact with the 
precision I/O event system.
</summary>
            <remarks>
                <para>
Precision I/O supports getting and setting the state of 
the Comm Card's Discrete I/O lines.
</para>
                <para>
Precision I/O also supports configuration of an event system
that runs on the Comm Card's real-time processor.
</para>
                <para>
The precision I/O event system allows the Comm Card to receive
inputs and automatically react to them without involving the host PC.
</para>
                <para>
This enables accurate configuration and reporting of I/O 
events and avoids typical host PC latency issues.
</para>
                <list type="bullet">
                    <item>
Use 
<see cref="M:Cognex.VisionPro.Comm.CogPrio.SetOutput(Cognex.VisionPro.Comm.CogPrioBankConstants,System.Int32,Cognex.VisionPro.Comm.CogPrioOutputLineValueConstants)" />
to manually set an I/O line high or low.</item>
                    <item>
Use
<see cref="M:Cognex.VisionPro.Comm.CogPrio.ReadState" />
to get the current state the I/O lines.
</item>
                    <item>
Construct instances of
<see cref="T:Cognex.VisionPro.Comm.CogPrioEvent" />
and add them to the 
<see cref="P:Cognex.VisionPro.Comm.CogPrio.Events" /> 
collection to configure a set of named events that correspond to
different actions of interest that occur on the I/O card.
</item>
                    <item>
Use
<see cref="P:Cognex.VisionPro.Comm.CogPrioEvent.CausesLine" />
to configure which I/O line transitions cause a precision I/O event to occur.
</item>
                    <item>
Use
<see cref="P:Cognex.VisionPro.Comm.CogPrioEvent.CausesNdm" />
to configure which NDM signals of the factory floor protocol cause a precision I/O event to occur.
</item>
                    <item>
Use
<see cref="P:Cognex.VisionPro.Comm.CogPrioEvent.ResponsesLine" />
to configure an automatic I/O line response to a precision I/O event.
</item>
                    <item>
Use
<see cref="M:Cognex.VisionPro.Comm.CogPrioEvent.Schedule(Cognex.VisionPro.Comm.CogPrioEventScheduleTypeConstants,System.Double,Cognex.VisionPro.Comm.CogPrioState)" />
to manually schedule a configured precision I/O event to occur at an precise instant.
</item>
                    <item>
Use
<see cref="E:Cognex.VisionPro.Comm.CogPrioEvent.HostNotification" />
to receive notifications whenever a configured event occurs.
</item>
                </list>
                <para>
    Hardware platforms and supported I/O lines:
  </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Cognex Communication Card 24C</term>
                            <description />
                        </listheader>
                        <item>
                            <term>InputBank0, Line0-Line7</term>
                            <description>8 general purpose inputs numbered 0-7</description>
                        </item>
                        <item>
                            <term>OutputBank0, Line0-Line15</term>
                            <description>16 general purpose outputs numbered 0-15</description>
                        </item>
                    </list>
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Cognex Communication Card 24A (Cognex Vision Controller)</term>
                            <description />
                        </listheader>
                        <item>
                            <term>InputBank0, Line0-Line7</term>
                            <description>8 general purpose inputs numbered 0-7</description>
                        </item>
                        <item>
                            <term>OutputBank0, Line0-Line15</term>
                            <description>16 general purpose outputs numbered 0-15</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line0</term>
                            <description>Camera 0 Enable (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line1</term>
                            <description>Camera 1 Enable (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line2</term>
                            <description>Camera 0 Trigger</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line3</term>
                            <description>Camera 1 Trigger</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line4</term>
                            <description>Camera 0 Control (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line5</term>
                            <description>Camera 1 Control (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line6</term>
                            <description>Camera 0 Power (Not For Application Use)</description>
                        </item>
                        <item>
                            <term>DS1000OutputBank0, Line7</term>
                            <description>Camera 1 Power (Not For Application Use)</description>
                        </item>
                    </list>
                </para>
            </remarks>
            <example>
                <!-- CogCommCardExample1 -->
                <!-- Shows simple use of comm card API
     The sample:
     1. initializes software access to the comm card.
     2. initializes software access to the Network Data Model (NDM).
          a. Signs up for the NewUserData event     
-->
                <code lang="Visual Basic" />
                <code lang="C#">
  // This code shows simple use of
  // Comm Card API. This sample:
  //
  // 1. Initializes comm card's i/o interface.
  // 2. Reads input line 0.
  // 3. Signs up for host notification when input line 0 toggles.
  // 4. Sets an output line 0 high.
  [Test]
  public void Example2()
  {
  CogCommCards commCardCollection = new CogCommCards();

  Console.WriteLine("Found: {0} comm cards", commCardCollection.Count);

  if (commCardCollection.Count == 0)
  return;

  CogCommCard card = commCardCollection[0];

  Console.WriteLine("Name: {0}", card.Name);
  Console.WriteLine("Serial: {0}", card.SerialNumber);

  CogDiscreteIOAccess discreteIOAccess = card.DiscreteIOAccess;
  if (discreteIOAccess == null)
  throw new Exception("discrete IO is not supported.");

  // Create the prio interface
  CogPrio prio = discreteIOAccess.CreatePrecisionIO();

  // Read input 0
  bool isInputLine0High = mPrio.ReadState()[CogPrioBankConstants.InputBank0, 0];
  Console.WriteLine("Input line 0 is " + (isInputLine0High ? "high" : "low"));

  // Create an event that occurs when Input 0 changes
  prio.Events.Add(
  new CogPrioEvent() {
  Name = "InputChanged_0",
  CausesLine = new CogPrioEventCauseLineCollection() {
  new CogPrioEventCauseLine() {
  LineBank = CogPrioBankConstants.InputBank0,
  LineNumber = 0,
  LineTransition = CogPrioLineTransitionConstants.Any }}});

  // Sign up for host notification when on the event
  prio.Events["InputChanged_0"].HostNotification +=
  new CogPrioEventHandler(InputChanged_0_HostNotification);

  // Always ensure the events collection is valid.
  if(!prio.Valid)
  { 
    Console.WrtieLine(prio.ValidationErrorMsg[0]);
  }

  // Set output 0 high
  prio.SetOutput(CogPrioBankConstants.OutputBank0,         // i/o bank
  0,                                        // line number
  CogPrioOutputLineValueConstants.SetHigh); // line value to set
  }

  void InputChanged_0_HostNotification(object sender, CogPrioEventArgs e)
  {
  Console.WriteLine("rcvd host notification for InputChanged_0 event");
  }
</code>
            </example>
        </member>
        <member name="M:Cognex.VisionPro.Comm.Implementation.Internal.ICogPrioFfpEventEnabler.ClearNdmEvents">
            <summary>
Clears all the Ndm transition based events.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.Implementation.Internal.ICogPrioFfpEventEnabler.AddNdmEvent(Cognex.VisionPro.Comm.CogPrioNdmSignalConstants,System.Int32,System.Int32,System.Boolean)">
            <summary>
Enable the Ndm transition to cause an event.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.Implementation.Internal.ICogPrioFfpEventEnabler">
            <summary>
This interface is held by a precision I/O instance
and is used to enable Ndm based events.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.ReadState">
            <summary>
Gets the current state of the precision I/O hardware.
</summary>
            <returns>
A <see cref="T:Cognex.VisionPro.Comm.CogPrioState" /> which contains 
the current state of the I/O interface.
</returns>
            <remarks>
The state contains information about the current values of all input
and output lines as well as the exact time stamp and encoder count at
which the state was read.
</remarks>
        </member>
        <member name="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.GetClockFrequency">
            <summary>
Gets the clock frequency. Use this value to convert
clock ticks to wall clock time.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.DisableEvents">
            <summary>
Disables all the configured events from firing.
Events can be disabled during configuration, and
re-enabled when configuration is complete.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.EnableEvents">
            <summary>
Enables the configured events.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.SetOutput(Cognex.VisionPro.Comm.CogPrioBankConstants,System.Int32,Cognex.VisionPro.Comm.CogPrioOutputLineValueConstants)">
            <summary>
Sets an output line without having to schedule an event.     
</summary>
            <param name="outputBank">
The I/O bank of the output line number to set.
</param>
            <param name="outputLineNumber">
The line number the output line to set.
</param>
            <param name="valueToSet">
The value to set the output line to.
</param>
        </member>
        <member name="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.ClearOutputLineResponse(Cognex.VisionPro.Comm.CogPrioBankConstants,System.Int32)">
            <summary>
Clears all usages of the given output line from the event
system.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.ConfigureOutputLineResponse(Cognex.VisionPro.Comm.CogPrioBankConstants,System.Int32,System.Int32,Cognex.VisionPro.Comm.CogPrioOutputLineValueConstants,Cognex.VisionPro.Comm.CogPrioDelayTypeConstants,System.Double,System.Double)">
            <summary>
Configures an output line to react to a registered I/O event in
a specific way.
</summary>
            <param name="outputBank">
The bank containing the output line.
</param>
            <param name="outputLineNumber">
The line number on which the configured output response occurs.
</param>
            <param name="antecedantEventNumber">
An I/O event number which will cause the configured output response
each time the event occurs.</param>
            <param name="valueToSet">
The value that is set on the configured output line when the 
event occurs.
</param>
            <param name="delayType">
The type of delay (encoder or time based) to wait after the 
event occurs before applying the output response to the I/O line. 
</param>
            <param name="delayValue">
The amount of delay (encoder ticks, or milliseconds) to wait
after the event occurs to apply the output response.
Note that delayValue may be negative in the case of an 
encoder based delay.
</param>
            <param name="pulseDuration">
The length of the pulse applied to the output line in milliseconds
when the event occurs (set to 0 for a signal that is not pulsed).
</param>
            <remarks>
Note: pulseDuration is ignored when valueToSet is "Toggle";
"Toggling" an output line is always results in a single transition
and never a pulse.
</remarks>
        </member>
        <member name="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.SetEncoderCount(System.Int64)">
            <summary>
Sets the encoder count to the specified value.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.SetDebounceDuration(System.Double)">
            <summary>
Sets the debounce duration for all input lines to the specified number of milliseconds.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.DisableHostNotificationForIOEvent(System.Int32)">
            <summary>
Disables the <see cref="E:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.HostNotification" />
.NET Event for the configured precision I/O comm card event.
The host PC will _NOT_ be interrupted/notified when the precision I/O
event occurs on the comm card.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.EnableHostNotificationForIOEvent(System.Int32)">
            <summary>
Enables the <see cref="E:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.HostNotification" />
.NET Event for the configured precision I/O comm card event.
The host PC will be interrupted/notified when the precision I/O
event occurs on the comm card.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.Reset">
            <summary>
Resets the entire precision I/O system to the default state.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.CancelScheduledEvent(System.Int32)">
            <summary>
Cancel a scheduled event using the instance tag returned from
<see cref="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.ScheduleIOEvent(System.Int32,Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImplEventScheduleTypeConstants,System.Int64,System.Int32,System.Int32@,Cognex.VisionPro.Comm.CogPrioState@)" /></summary>
            <param name="scheduledEventInstanceTag">
The scheduled event instance tag to cancel.
</param>
        </member>
        <member name="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.ScheduleIOEvent(System.Int32,Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImplEventScheduleTypeConstants,System.Int64,System.Int32,System.Int32@,Cognex.VisionPro.Comm.CogPrioState@)">
            <summary>
Manually schedules an I/O event to occur.
</summary>
            <param name="eventNumber">
The registered IO Event ID to schedule.
</param>
            <param name="scheduleType">
An enum which controls which type of scheduling to use 
(i.e. encoder based, or time based scheduling).
</param>
            <param name="scheduleValue">
A value which controls when the event is scheduled to occur
(i.e. number of encoder ticks, or a particular time stamp)
depending on the scheduleType.
</param>
            <param name="scheduledUserDataTag">
A return value which can be used to identify a particular
scheduled event instance from the
<see cref="E:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.HostNotification" />
event.
</param>
            <param name="scheduledEventInstanceTag">
A return value which can be used to identify and cancel
the instance of the scheduled event.
</param>
            <param name="state">
Returns the state of the comm card immediately after the event
was scheduled. The I/O state includes the timestamp and encoder count.
These values can be useful when trying to determine if the event
was scheduled "in time".
</param>
        </member>
        <member name="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.RemoveEvent(Cognex.VisionPro.Comm.CogPrioBankConstants,System.Int32,Cognex.VisionPro.Comm.CogPrioLineTransitionConstants,System.Int32)">
            <summary>
Removes the previously configured event 
for a particular I/O line transition.
</summary>
            <param name="bank">
The bank containing the I/O line for the
configured event to remove.
</param>
            <param name="lineNumber">
The line number of the I/O line for the
configured event to remove.
</param>
            <param name="transitionType">
The transition type of the I/O line for the
configured event to remove.
</param>
            <param name="eventNumber">
The event number of the event to remove.
</param>
        </member>
        <member name="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.RemoveEventFromAll(System.Int32)">
            <summary>
Completely removes an event from the set of 
configured precision I/O events.
</summary>
            <param name="eventNumber">
The number of the event to remove.
</param>
        </member>
        <member name="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.AddEvent(System.Int32,Cognex.VisionPro.Comm.CogPrioBankConstants,System.Int32,Cognex.VisionPro.Comm.CogPrioLineTransitionConstants)">
            <summary>
Registers a precision I/O event ID number to monitor an input 
or output line for a particular transition.
<para>
The registered I/O event is raised whenever the configured I/O line
transition occurs.
</para><para>
Once an event is added it can be used as an argument to
<see cref="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.ConfigureOutputLineResponse(Cognex.VisionPro.Comm.CogPrioBankConstants,System.Int32,System.Int32,Cognex.VisionPro.Comm.CogPrioOutputLineValueConstants,Cognex.VisionPro.Comm.CogPrioDelayTypeConstants,System.Double,System.Double)" />
to set up automatic I/O responses that automatically occur in reaction
the event firing.
</para><para>
The user can also manually schedule a configured event to occur at an
exact time stamp or encoder count using 
<see cref="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.ScheduleIOEvent(System.Int32,Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImplEventScheduleTypeConstants,System.Int64,System.Int32,System.Int32@,Cognex.VisionPro.Comm.CogPrioState@)" />.
</para><para>
Additionally the user can receive notifications whenever a configured event
occurs using <see cref="E:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.HostNotification" />.
</para></summary>
            <param name="eventNumber">
A unique ID for the registered I/O Event which occurs whenever
the transition configured by lineBank, lineNumber, and transitionType
is observed on the comm card.
</param>
            <param name="lineBank">
The bank of the I/O line that the event will monitor.
</param>
            <param name="lineNumber">
The line number to monitor.
</param>
            <param name="transitionType">
The type of edge transition to look for.
</param>
        </member>
        <member name="E:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.HostNotification">
            <summary>
The HostNotification event is raised to signal the PC that a 
precision I/O event has occurred.
<para>
NOTE: HostNotification events must be explicitly enabled for each
event number by calling 
<see cref="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.EnableHostNotificationForIOEvent(System.Int32)" />.
</para></summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.#ctor(ccIPrecisionIO_Core_v0*)">
            <summary>
Construct a precision I/O object which is a thin
.NET wrap of the underlying nv module interface.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.fCallback(csPrecisionIOCallbackData_*)">
            <summary>
Called when a precision i/o event/callback occurs
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl">
            <summary>
CogPrioImpl provides a low level wrap
of the precision I/O event system.
<list type="bullet"><item>
Use <see cref="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.AddEvent(System.Int32,Cognex.VisionPro.Comm.CogPrioBankConstants,System.Int32,Cognex.VisionPro.Comm.CogPrioLineTransitionConstants)" />
to configure a set of events that correspond to different actions 
occurring on the hardware.
</item><item>
Use <see cref="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.ConfigureOutputLineResponse(Cognex.VisionPro.Comm.CogPrioBankConstants,System.Int32,System.Int32,Cognex.VisionPro.Comm.CogPrioOutputLineValueConstants,Cognex.VisionPro.Comm.CogPrioDelayTypeConstants,System.Double,System.Double)" />
to set up automatic I/O responses that automatically occur in reaction
an event.
</item><item>
Use <see cref="M:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.ScheduleIOEvent(System.Int32,Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImplEventScheduleTypeConstants,System.Int64,System.Int32,System.Int32@,Cognex.VisionPro.Comm.CogPrioState@)" />
to manually schedule a configured event to occur at an exact time stamp or encoder count.
</item><item>
Use <see cref="E:Cognex.VisionPro.Comm.Implementation.Internal.CogPrioImpl.HostNotification" />
to receive notifications whenever a configured event occurs.
</item></list></summary>
            <remarks>
This class is a thin wrap of the unmanaged precision I/O interface.
</remarks>
            <example>
                <!-- CogCommCardExample1 -->
                <!-- Shows simple use of comm card API
     The sample:
     1. initializes software access to the comm card.
     2. initializes software access to the Network Data Model (NDM).
          a. Signs up for the NewUserData event     
-->
                <code lang="Visual Basic" />
                <code lang="C#">
using Cognex.VisionPro;
using Cognex.VisionPro.Comm;

// Shows simple use of comm card API.
//
// Initializes a connection to a Rockwell Control Logix PLC
// using the EtherNet/IP protocol and the Cognex generic
// Factory Floor Protocol (FFP) interface known as the 
// Network Data Model (NDM).
//
// Signs up for the NDM's "NewUserData" event and prints out the 
// NewUserData as it's received.
public void Example()
{
  CogCommCards commCardCollection = new CogCommCards();
      
  Console.WriteLine("Found: {0} comm cards", commCardCollection.Count);
      
  if (commCardCollection.Count == 0)
    return;

  CogCommCard card = commCardCollection[0];

  Console.WriteLine("Name: {0}", card.Name);
  Console.WriteLine("Serial: {0}", card.SerialNumber);

  Console.WriteLine("Initializing comm card Factory Floor Protocol (FFP)");

  CogFfpAccess ffpAccess = card.FfpAccess;

  if (ffpAccess == null)
    throw new Exception("FFP is not supported.");     

  CogNdm ffpNdm =
    ffpAccess.CreateNetworkDataModel(CogFfpProtocolConstants.EthernetIp);

  ffpNdm.Start();

  Console.WriteLine("Sign up for the NewUserData Event");
  ffpNdm.NewUserData += new CogNdmNewUserDataEventHandler(ffpNdm_NewUserData);    
}

void ffpNdm_NewUserData(object sender, CogNdmNewUserDataEventArgs e)
{
  CogNdm ndm = sender as CogNdm;
  if (ndm != null)
    Console.WriteLine(BitConverter.ToString(ndm.ReadUserData(0, 100)));
}
</code>
            </example>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrioEventCollection.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
Serialization constructor for CogPrioEventCollection.
</summary>
            <param name="info">
The standard SerializationInfo argument.
</param>
            <param name="ctxt">
The standard StreamingContext argument.
</param>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrioEventCollection.#ctor">
            <summary>
Construct an empty collection of <see cref="T:Cognex.VisionPro.Comm.CogPrioEvent" /> objects.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogPrioEventCollection">
            <summary>
A collection of 
<see cref="T:Cognex.VisionPro.Comm.CogPrioEvent" /></summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrioEvent.Schedule">
            <summary>
Manually schedules an I/O event to occur as soon as possible.
</summary>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogScheduledEventOverflowException">
Thrown if event scheduling failed because the maximum number of outstanding
scheduled events has been reached (Current firmware sets this limit at 1000).
</exception>
            <exception cref="T:System.InvalidOperationException">
Thrown if this object is not part of the CogPrio.Events collection or if 
CogPrio.Valid is false when Schedule() is called.
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrioEvent.Schedule(Cognex.VisionPro.Comm.CogPrioEventScheduleTypeConstants,System.Double)">
            <summary>
Manually schedules an I/O event to occur.
</summary>
            <param name="scheduleType">
Which type of scheduling to use (time or encoder based).
</param>
            <param name="scheduleValue">
How many milliseconds or encoder ticks from now until
the scheduled event occurs.
</param>
            <returns>
A CogPrioScheduledEventToken which can be used to 
discover the instant at which the I/O event was scheduled
or to cancel a scheduled event.
</returns>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogScheduledEventOverflowException">
Thrown if event scheduling failed because the maximum number of outstanding
scheduled events has been reached (Current firmware sets this limit at 1000).
</exception>
            <exception cref="T:System.NotImplementedException">
Thrown if scheduleType is set to Encoder.
</exception>
            <exception cref="T:System.InvalidOperationException">
Thrown if this object is not part of the CogPrio.Events collection or if 
CogPrio.Valid is false when Schedule() is called.
</exception>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrioEvent.Schedule(Cognex.VisionPro.Comm.CogPrioEventScheduleTypeConstants,System.Double,Cognex.VisionPro.Comm.CogPrioState)">
            <summary>
Manually schedules an I/O event to occur relative to
some other previous state.
</summary>
            <param name="scheduleType">
Which type of scheduling to use (time or encoder based).
</param>
            <param name="scheduleValue">
How many milliseconds or encoder ticks from the previous
state until the event occurs.
</param>
            <param name="relativeState">
The event is scheduled relative to this previous state.
</param>
            <returns>
A CogPrioScheduledEventToken which can be used to 
discover the instant at which the I/O event was scheduled
or to cancel a scheduled event.
</returns>
            <remarks>
                <para>
A precision I/O event can occur as a result of one of the configured event causes 
(see 
<see cref="P:Cognex.VisionPro.Comm.CogPrioEvent.CausesNdm">
CausesNdm
</see>
,
<see cref="P:Cognex.VisionPro.Comm.CogPrioEvent.CausesLine">
CausesLine
</see>
).
</para>
                <para>
A precision I/O event can also occur as a result of manual user scheduling.
</para>
                <list type="bullet">
                    <item>
Use
<see cref="M:Cognex.VisionPro.Comm.CogPrioEvent.Schedule(Cognex.VisionPro.Comm.CogPrioEventScheduleTypeConstants,System.Double,Cognex.VisionPro.Comm.CogPrioState)" />
to manually schedule precision I/O events to occur at a specific instant.
Scheduling an event returns a
<see cref="T:Cognex.VisionPro.Comm.CogPrioScheduledEventToken" />.
</item>
                    <item>
Use
<see cref="P:Cognex.VisionPro.Comm.CogPrioScheduledEventToken.State" />
to discover the state of the Comm Card at the instant the scheduled event was accepted
by the scheduling mechanism. This is useful when you need to know if the event was
scheduled "in time".
</item>
                    <item>
Use
<see cref="M:Cognex.VisionPro.Comm.CogPrioScheduledEventToken.Cancel" />
to cancel the scheduled event before it occurs. 
</item>
                </list>
            </remarks>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogScheduledEventTooLateException">
Thrown if event scheduling failed because the event would have occurred in the past.
</exception>
            <exception cref="T:Cognex.VisionPro.Exceptions.CogScheduledEventOverflowException">
Thrown if event scheduling failed because the maximum number of outstanding
scheduled events has been reached (Current firmware sets this limit at 1000).
</exception>
            <exception cref="T:System.NotImplementedException">
Thrown if scheduleType is set to Encoder.
</exception>
            <exception cref="T:System.InvalidOperationException">
Thrown if this object is not part of the CogPrio.Events collection or if 
CogPrio.Valid is false when Schedule() is called.
</exception>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogPrioEvent.EventNumber">
            <summary>
A value which uniquely identifies this event.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogPrioEvent.ResponsesLine">
            <summary>
A collection of <see cref="T:Cognex.VisionPro.Comm.CogPrioEventResponseLine" />
which occur in response to the event.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogPrioEvent.CausesNdm">
            <summary>
A collection of <see cref="T:Cognex.VisionPro.Comm.CogPrioEventCauseNdm" /> which
cause the event to occur.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogPrioEvent.CausesLine">
            <summary>
A collection of <see cref="T:Cognex.VisionPro.Comm.CogPrioEventCauseLine" /> which
cause the event to occur.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogPrioEvent.HasHostNotificationListener">
            <summary>
Returns true if there is currently an event handler listening
for host notification of this event.
</summary>
        </member>
        <member name="E:Cognex.VisionPro.Comm.CogPrioEvent.HostNotification">
            <summary>
The HostNotification event is raised to signal the PC that a 
precision I/O event has occurred on the comm card hardware.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrioEvent.#ctor(System.String,Cognex.VisionPro.Comm.CogPrioEventCauseLineCollection,Cognex.VisionPro.Comm.CogPrioEventCauseNdmCollection,Cognex.VisionPro.Comm.CogPrioEventResponseLineCollection)">
            <summary>
Construct a new precision i/o event instance.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrioEvent.#ctor(System.String)">
            <summary>
Construct a new precision i/o event instance.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrioEvent.#ctor">
            <summary>
Construct a new precision i/o event instance.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrioEvent.Init(Cognex.VisionPro.Comm.CogPrioEventCauseLineCollection,Cognex.VisionPro.Comm.CogPrioEventCauseNdmCollection,Cognex.VisionPro.Comm.CogPrioEventResponseLineCollection)">
            <summary>
Called from ctors to init a new instance.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrioEvent.Init">
            <summary>
Called from ctors to init a new instance.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrioEvent.RegisterCallback(ccIPrecisionIO_Core_v0*)">
            <summary>
Registers the host callback for this event with the underlying 
module but only if anyone is actually listening for HostNotification
on this event.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrioEvent.SetScheduler(Cognex.VisionPro.Comm.ICogPrioEventScheduler)">
            <summary>
The event container/parent class uses this method
to pass in a reference to the scheduler interface
that the contained event can use to schedule itself.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrioEvent.SetEventNumber(System.Int32)">
            <summary>
Called by an event collection to 
set the event number immediately
before adding it to the collection.
This ensures that each event gets a unique number
which is used as the event identifier in the
underlying implementation.
Nothing else should call this function!
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrioEvent.fCallback(csPrecisionIOCallbackData_*)">
            <summary>
This function is passed to the nv module as a callback.
</summary>
            <summary>
This function is passed to the nv module as a callback.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrioEvent.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
Serialization constructor for CogPrioEvent.
</summary>
            <param name="info">
The standard SerializationInfo argument.
</param>
            <param name="ctxt">
The standard StreamingContext argument.
</param>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogPrioEvent.SfResponsesLine">
            <summary>
This bit will be set in the EventArgs of a Changed event
every time the value returned by ResponsesLine may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogPrioEvent.SfCausesNdm">
            <summary>
This bit will be set in the EventArgs of a Changed event
every time the value returned by CausesNdm may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogPrioEvent.SfCausesLine">
            <summary>
This bit will be set in the EventArgs of a Changed event
every time the value returned by CausesLine may have changed.
</summary>
        </member>
        <member name="F:Cognex.VisionPro.Comm.CogPrioEvent.SfHasHostNotificationListener">
            <summary>
This bit will be set in the EventArgs of a Changed event
every time a handler is added or removed to the HostNotification
Event.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogPrioEvent">
            <summary>
Class which represents a precision I/O event.
</summary>
            <remarks>
                <para>
Precision I/O supports getting and setting the state of 
the Comm Card's Discrete I/O lines.
</para>
                <para>
Precision I/O also supports configuration of an event system
that runs on the Comm Card's real-time processor.
</para>
                <para>
The precision I/O event system allows the Comm Card to receive
inputs and automatically react to them without involving the host PC.
</para>
                <para>
This enables accurate configuration and reporting of I/O 
events and avoids typical host PC latency issues.
</para>
                <list type="bullet">
                    <item>
Use 
<see cref="M:Cognex.VisionPro.Comm.CogPrio.SetOutput" />
to manually set an I/O line high or low.</item>
                    <item>
Use
<see cref="M:Cognex.VisionPro.Comm.CogPrio.ReadState" />
to get the current state the I/O lines.
</item>
                    <item>
Construct instances of
<see cref="T:Cognex.VisionPro.Comm.CogPrioEvent" />
and add them to the 
<see cref="P:Cognex.VisionPro.Comm.CogPrio.Events" /> 
collection to configure a set of named events that correspond to
different actions of interest that occur on the I/O card.
</item>
                    <item>
Use
<see cref="P:Cognex.VisionPro.Comm.CogPrioEvent.CausesLine" />
to configure which I/O line transitions cause a precision I/O event to occur.
</item>
                    <item>
Use
<see cref="P:Cognex.VisionPro.Comm.CogPrioEvent.CausesNdm" />
to configure which NDM signals of the factory floor protocol cause a precision I/O event to occur.
</item>
                    <item>
Use
<see cref="P:Cognex.VisionPro.Comm.CogPrioEvent.ResponsesLine" />
to configure an automatic I/O line response to a precision I/O event.
</item>
                    <item>
Use
<see cref="M:Cognex.VisionPro.Comm.CogPrioEvent.Schedule(Cognex.VisionPro.Comm.CogPrioEventScheduleTypeConstants,System.Double,Cognex.VisionPro.Comm.CogPrioState)" />
to manually schedule a configured precision I/O event to occur at an precise instant.
</item>
                    <item>
Use
<see cref="E:Cognex.VisionPro.Comm.CogPrioEvent.HostNotification" />
to receive notifications whenever a configured event occurs.
</item>
                </list>
            </remarks>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogPrioScheduledEventToken.InstanceID">
            <summary>
A value which uniquely identifies this scheduled event instance
which corresponds to this token.
</summary>
        </member>
        <member name="P:Cognex.VisionPro.Comm.CogPrioScheduledEventToken.State">
            <summary>
The precision I/O state at the instant the event was scheduled.
<para>
Use this value to determine if the event was scheduled "in time".
</para></summary>
            <remarks>
                <para>
A precision I/O event can occur as a result of one of the configured event causes 
(see 
<see cref="M:Cognex.VisionPro.Comm.CogPrioEvent.CausesNdm">
CausesNdm
</see>
,
<see cref="M:Cognex.VisionPro.Comm.CogPrioEvent.CausesLine">
CausesLine
</see>
).
</para>
                <para>
A precision I/O event can also occur as a result of manual user scheduling.
</para>
                <list type="bullet">
                    <item>
Use
<see cref="M:Cognex.VisionPro.Comm.CogPrioEvent.Schedule" />
to manually schedule precision I/O events to occur at a specific instant.
Scheduling an event returns a
<see cref="T:Cognex.VisionPro.Comm.CogPrioScheduledEventToken" />.
</item>
                    <item>
Use
<see cref="P:Cognex.VisionPro.Comm.CogPrioScheduledEventToken.State" />
to discover the state of the Comm Card at the instant the scheduled event was accepted
by the scheduling mechanism. This is useful when you need to know if the event was
scheduled "in time".
</item>
                    <item>
Use
<see cref="M:Cognex.VisionPro.Comm.CogPrioScheduledEventToken.Cancel" />
to cancel the scheduled event before it occurs. 
</item>
                </list>
            </remarks>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrioScheduledEventToken.Cancel">
            <summary>
Cancels the scheduled event.
</summary>
            <value>
Returns true if the scheduled event was successfully canceled,
false if the event cannot be canceled.
</value>
            <remarks>
                <para>
A precision I/O event can occur as a result of one of the configured event causes 
(see 
<see cref="M:Cognex.VisionPro.Comm.CogPrioEvent.CausesNdm">
CausesNdm
</see>
,
<see cref="M:Cognex.VisionPro.Comm.CogPrioEvent.CausesLine">
CausesLine
</see>
).
</para>
                <para>
A precision I/O event can also occur as a result of manual user scheduling.
</para>
                <list type="bullet">
                    <item>
Use
<see cref="M:Cognex.VisionPro.Comm.CogPrioEvent.Schedule" />
to manually schedule precision I/O events to occur at a specific instant.
Scheduling an event returns a
<see cref="T:Cognex.VisionPro.Comm.CogPrioScheduledEventToken" />.
</item>
                    <item>
Use
<see cref="P:Cognex.VisionPro.Comm.CogPrioScheduledEventToken.State" />
to discover the state of the Comm Card at the instant the scheduled event was accepted
by the scheduling mechanism. This is useful when you need to know if the event was
scheduled "in time".
</item>
                    <item>
Use
<see cref="M:Cognex.VisionPro.Comm.CogPrioScheduledEventToken.Cancel" />
to cancel the scheduled event before it occurs. 
</item>
                </list>
            </remarks>
        </member>
        <member name="M:Cognex.VisionPro.Comm.CogPrioScheduledEventToken.#ctor(System.Int32,Cognex.VisionPro.Comm.CogPrioState,Cognex.VisionPro.Comm.ICogPrioEventScheduler)">
            <summary>
Internal ctor for use by the precision I/O event scheduling mechanism.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogPrioScheduledEventToken">
            <summary>
Token returned when a precision I/O event is manually scheduled.
</summary>
            <remarks>
                <para>
A precision I/O event can occur as a result of one of the configured event causes 
(see 
<see cref="M:Cognex.VisionPro.Comm.CogPrioEvent.CausesNdm">
CausesNdm
</see>
,
<see cref="M:Cognex.VisionPro.Comm.CogPrioEvent.CausesLine">
CausesLine
</see>
).
</para>
                <para>
A precision I/O event can also occur as a result of manual user scheduling.
</para>
                <list type="bullet">
                    <item>
Use
<see cref="M:Cognex.VisionPro.Comm.CogPrioEvent.Schedule" />
to manually schedule precision I/O events to occur at a specific instant.
Scheduling an event returns a
<see cref="T:Cognex.VisionPro.Comm.CogPrioScheduledEventToken" />.
</item>
                    <item>
Use
<see cref="P:Cognex.VisionPro.Comm.CogPrioScheduledEventToken.State" />
to discover the state of the Comm Card at the instant the scheduled event was accepted
by the scheduling mechanism. This is useful when you need to know if the event was
scheduled "in time".
</item>
                    <item>
Use
<see cref="M:Cognex.VisionPro.Comm.CogPrioScheduledEventToken.Cancel" />
to cancel the scheduled event before it occurs. 
</item>
                </list>
            </remarks>
        </member>
        <member name="M:Cognex.VisionPro.Comm.ICogPrioEventScheduler.Cancel(Cognex.VisionPro.Comm.CogPrioScheduledEventToken)">
            <summary>
Cancels a previously scheduled precision I/O event.
</summary>
        </member>
        <member name="M:Cognex.VisionPro.Comm.ICogPrioEventScheduler.Schedule(Cognex.VisionPro.Comm.CogPrioEvent,Cognex.VisionPro.Comm.CogPrioEventScheduleTypeConstants,System.Double,Cognex.VisionPro.Comm.CogPrioState)">
            <summary>
Manually schedule an event to occur at an precise time stamp or encoder count.
</summary>
        </member>
        <member name="T:Cognex.VisionPro.Comm.ICogPrioEventScheduler">
            <summary>
Supports scheduling and cancellation of precision I/O events.
</summary>
            <remarks>
                <para>
A precision I/O event can occur as a result of one of the configured event causes 
(see 
<see cref="M:Cognex.VisionPro.Comm.CogPrioEvent.CausesNdm">
CausesNdm
</see>
,
<see cref="M:Cognex.VisionPro.Comm.CogPrioEvent.CausesLine">
CausesLine
</see>
).
</para>
                <para>
A precision I/O event can also occur as a result of manual user scheduling.
</para>
                <list type="bullet">
                    <item>
Use
<see cref="M:Cognex.VisionPro.Comm.CogPrioEvent.Schedule" />
to manually schedule precision I/O events to occur at a specific instant.
Scheduling an event returns a
<see cref="T:Cognex.VisionPro.Comm.CogPrioScheduledEventToken" />.
</item>
                    <item>
Use
<see cref="P:Cognex.VisionPro.Comm.CogPrioScheduledEventToken.State" />
to discover the state of the Comm Card at the instant the scheduled event was accepted
by the scheduling mechanism. This is useful when you need to know if the event was
scheduled "in time".
</item>
                    <item>
Use
<see cref="M:Cognex.VisionPro.Comm.CogPrioScheduledEventToken.Cancel" />
to cancel the scheduled event before it occurs. 
</item>
                </list>
            </remarks>
        </member>
        <member name="T:Cognex.VisionPro.Comm.CogPrioUnmanagedCallbackDelegate">
            <summary>
Delegate type which is marshaled to an unmanaged function pointer and
passed to the precision I/O module call back.
</summary>
        </member>
    </members>
</doc>